/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.lnrpc = (function() {

    /**
     * Namespace lnrpc.
     * @exports lnrpc
     * @namespace
     */
    var lnrpc = {};

    lnrpc.WalletUnlocker = (function() {

        /**
         * Constructs a new WalletUnlocker service.
         * @memberof lnrpc
         * @classdesc Represents a WalletUnlocker
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function WalletUnlocker(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (WalletUnlocker.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = WalletUnlocker;

        /**
         * Creates new WalletUnlocker service using the specified rpc implementation.
         * @function create
         * @memberof lnrpc.WalletUnlocker
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {WalletUnlocker} RPC service. Useful where requests and/or responses are streamed.
         */
        WalletUnlocker.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#genSeed}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef GenSeedCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GenSeedResponse} [response] GenSeedResponse
         */

        /**
         * GenSeed is the first method that should be used to instantiate a new lnd
         * instance. This method allows a caller to generate a new aezeed cipher seed
         * given an optional passphrase. If provided, the passphrase will be necessary
         * to decrypt the cipherseed to expose the internal wallet seed.
         * 
         * Once the cipherseed is obtained and verified by the user, the InitWallet
         * method should be used to commit the newly generated seed, and create the
         * wallet.
         * @function genSeed
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IGenSeedRequest} request GenSeedRequest message or plain object
         * @param {lnrpc.WalletUnlocker.GenSeedCallback} callback Node-style callback called with the error, if any, and GenSeedResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.genSeed = function genSeed(request, callback) {
            return this.rpcCall(genSeed, $root.lnrpc.GenSeedRequest, $root.lnrpc.GenSeedResponse, request, callback);
        }, "name", { value: "GenSeed" });

        /**
         * GenSeed is the first method that should be used to instantiate a new lnd
         * instance. This method allows a caller to generate a new aezeed cipher seed
         * given an optional passphrase. If provided, the passphrase will be necessary
         * to decrypt the cipherseed to expose the internal wallet seed.
         * 
         * Once the cipherseed is obtained and verified by the user, the InitWallet
         * method should be used to commit the newly generated seed, and create the
         * wallet.
         * @function genSeed
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IGenSeedRequest} request GenSeedRequest message or plain object
         * @returns {Promise<lnrpc.GenSeedResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#initWallet}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef InitWalletCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.InitWalletResponse} [response] InitWalletResponse
         */

        /**
         * InitWallet is used when lnd is starting up for the first time to fully
         * initialize the daemon and its internal wallet. At the very least a wallet
         * password must be provided. This will be used to encrypt sensitive material
         * on disk.
         * 
         * In the case of a recovery scenario, the user can also specify their aezeed
         * mnemonic and passphrase. If set, then the daemon will use this prior state
         * to initialize its internal wallet.
         * 
         * Alternatively, this can be used along with the GenSeed RPC to obtain a
         * seed, then present it to the user. Once it has been verified by the user,
         * the seed can be fed into this RPC in order to commit the new wallet.
         * @function initWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IInitWalletRequest} request InitWalletRequest message or plain object
         * @param {lnrpc.WalletUnlocker.InitWalletCallback} callback Node-style callback called with the error, if any, and InitWalletResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.initWallet = function initWallet(request, callback) {
            return this.rpcCall(initWallet, $root.lnrpc.InitWalletRequest, $root.lnrpc.InitWalletResponse, request, callback);
        }, "name", { value: "InitWallet" });

        /**
         * InitWallet is used when lnd is starting up for the first time to fully
         * initialize the daemon and its internal wallet. At the very least a wallet
         * password must be provided. This will be used to encrypt sensitive material
         * on disk.
         * 
         * In the case of a recovery scenario, the user can also specify their aezeed
         * mnemonic and passphrase. If set, then the daemon will use this prior state
         * to initialize its internal wallet.
         * 
         * Alternatively, this can be used along with the GenSeed RPC to obtain a
         * seed, then present it to the user. Once it has been verified by the user,
         * the seed can be fed into this RPC in order to commit the new wallet.
         * @function initWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IInitWalletRequest} request InitWalletRequest message or plain object
         * @returns {Promise<lnrpc.InitWalletResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#unlockWallet}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef UnlockWalletCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.UnlockWalletResponse} [response] UnlockWalletResponse
         */

        /**
         * lncli: `unlock`
         * UnlockWallet is used at startup of lnd to provide a password to unlock
         * the wallet database.
         * @function unlockWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IUnlockWalletRequest} request UnlockWalletRequest message or plain object
         * @param {lnrpc.WalletUnlocker.UnlockWalletCallback} callback Node-style callback called with the error, if any, and UnlockWalletResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.unlockWallet = function unlockWallet(request, callback) {
            return this.rpcCall(unlockWallet, $root.lnrpc.UnlockWalletRequest, $root.lnrpc.UnlockWalletResponse, request, callback);
        }, "name", { value: "UnlockWallet" });

        /**
         * lncli: `unlock`
         * UnlockWallet is used at startup of lnd to provide a password to unlock
         * the wallet database.
         * @function unlockWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IUnlockWalletRequest} request UnlockWalletRequest message or plain object
         * @returns {Promise<lnrpc.UnlockWalletResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#changePassword}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef ChangePasswordCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChangePasswordResponse} [response] ChangePasswordResponse
         */

        /**
         * lncli: `changepassword`
         * ChangePassword changes the password of the encrypted wallet. This will
         * automatically unlock the wallet database if successful.
         * @function changePassword
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IChangePasswordRequest} request ChangePasswordRequest message or plain object
         * @param {lnrpc.WalletUnlocker.ChangePasswordCallback} callback Node-style callback called with the error, if any, and ChangePasswordResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.changePassword = function changePassword(request, callback) {
            return this.rpcCall(changePassword, $root.lnrpc.ChangePasswordRequest, $root.lnrpc.ChangePasswordResponse, request, callback);
        }, "name", { value: "ChangePassword" });

        /**
         * lncli: `changepassword`
         * ChangePassword changes the password of the encrypted wallet. This will
         * automatically unlock the wallet database if successful.
         * @function changePassword
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IChangePasswordRequest} request ChangePasswordRequest message or plain object
         * @returns {Promise<lnrpc.ChangePasswordResponse>} Promise
         * @variation 2
         */

        return WalletUnlocker;
    })();

    lnrpc.GenSeedRequest = (function() {

        /**
         * Properties of a GenSeedRequest.
         * @memberof lnrpc
         * @interface IGenSeedRequest
         * @property {Uint8Array|null} [aezeedPassphrase] aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @property {Uint8Array|null} [seedEntropy] seed_entropy is an optional 16-bytes generated via CSPRNG. If not
         * specified, then a fresh set of randomness will be used to create the seed.
         */

        /**
         * Constructs a new GenSeedRequest.
         * @memberof lnrpc
         * @classdesc Represents a GenSeedRequest.
         * @implements IGenSeedRequest
         * @constructor
         * @param {lnrpc.IGenSeedRequest=} [properties] Properties to set
         */
        function GenSeedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @member {Uint8Array} aezeedPassphrase
         * @memberof lnrpc.GenSeedRequest
         * @instance
         */
        GenSeedRequest.prototype.aezeedPassphrase = $util.newBuffer([]);

        /**
         * seed_entropy is an optional 16-bytes generated via CSPRNG. If not
         * specified, then a fresh set of randomness will be used to create the seed.
         * @member {Uint8Array} seedEntropy
         * @memberof lnrpc.GenSeedRequest
         * @instance
         */
        GenSeedRequest.prototype.seedEntropy = $util.newBuffer([]);

        /**
         * Creates a new GenSeedRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.IGenSeedRequest=} [properties] Properties to set
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest instance
         */
        GenSeedRequest.create = function create(properties) {
            return new GenSeedRequest(properties);
        };

        /**
         * Encodes the specified GenSeedRequest message. Does not implicitly {@link lnrpc.GenSeedRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.IGenSeedRequest} message GenSeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.aezeedPassphrase);
            if (message.seedEntropy != null && message.hasOwnProperty("seedEntropy"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seedEntropy);
            return writer;
        };

        /**
         * Encodes the specified GenSeedRequest message, length delimited. Does not implicitly {@link lnrpc.GenSeedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.IGenSeedRequest} message GenSeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenSeedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GenSeedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.aezeedPassphrase = reader.bytes();
                    break;
                case 2:
                    message.seedEntropy = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenSeedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenSeedRequest message.
         * @function verify
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenSeedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                if (!(message.aezeedPassphrase && typeof message.aezeedPassphrase.length === "number" || $util.isString(message.aezeedPassphrase)))
                    return "aezeedPassphrase: buffer expected";
            if (message.seedEntropy != null && message.hasOwnProperty("seedEntropy"))
                if (!(message.seedEntropy && typeof message.seedEntropy.length === "number" || $util.isString(message.seedEntropy)))
                    return "seedEntropy: buffer expected";
            return null;
        };

        /**
         * Creates a GenSeedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest
         */
        GenSeedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GenSeedRequest)
                return object;
            var message = new $root.lnrpc.GenSeedRequest();
            if (object.aezeedPassphrase != null)
                if (typeof object.aezeedPassphrase === "string")
                    $util.base64.decode(object.aezeedPassphrase, message.aezeedPassphrase = $util.newBuffer($util.base64.length(object.aezeedPassphrase)), 0);
                else if (object.aezeedPassphrase.length)
                    message.aezeedPassphrase = object.aezeedPassphrase;
            if (object.seedEntropy != null)
                if (typeof object.seedEntropy === "string")
                    $util.base64.decode(object.seedEntropy, message.seedEntropy = $util.newBuffer($util.base64.length(object.seedEntropy)), 0);
                else if (object.seedEntropy.length)
                    message.seedEntropy = object.seedEntropy;
            return message;
        };

        /**
         * Creates a plain object from a GenSeedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.GenSeedRequest} message GenSeedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenSeedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.aezeedPassphrase = "";
                else {
                    object.aezeedPassphrase = [];
                    if (options.bytes !== Array)
                        object.aezeedPassphrase = $util.newBuffer(object.aezeedPassphrase);
                }
                if (options.bytes === String)
                    object.seedEntropy = "";
                else {
                    object.seedEntropy = [];
                    if (options.bytes !== Array)
                        object.seedEntropy = $util.newBuffer(object.seedEntropy);
                }
            }
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                object.aezeedPassphrase = options.bytes === String ? $util.base64.encode(message.aezeedPassphrase, 0, message.aezeedPassphrase.length) : options.bytes === Array ? Array.prototype.slice.call(message.aezeedPassphrase) : message.aezeedPassphrase;
            if (message.seedEntropy != null && message.hasOwnProperty("seedEntropy"))
                object.seedEntropy = options.bytes === String ? $util.base64.encode(message.seedEntropy, 0, message.seedEntropy.length) : options.bytes === Array ? Array.prototype.slice.call(message.seedEntropy) : message.seedEntropy;
            return object;
        };

        /**
         * Converts this GenSeedRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GenSeedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenSeedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenSeedRequest;
    })();

    lnrpc.GenSeedResponse = (function() {

        /**
         * Properties of a GenSeedResponse.
         * @memberof lnrpc
         * @interface IGenSeedResponse
         * @property {Array.<string>|null} [cipherSeedMnemonic] cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This field is optional, as if not
         * provided, then the daemon will generate a new cipher seed for the user.
         * Otherwise, then the daemon will attempt to recover the wallet state linked
         * to this cipher seed.
         * @property {Uint8Array|null} [encipheredSeed] enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
         * cipher text before run through our mnemonic encoding scheme.
         */

        /**
         * Constructs a new GenSeedResponse.
         * @memberof lnrpc
         * @classdesc Represents a GenSeedResponse.
         * @implements IGenSeedResponse
         * @constructor
         * @param {lnrpc.IGenSeedResponse=} [properties] Properties to set
         */
        function GenSeedResponse(properties) {
            this.cipherSeedMnemonic = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This field is optional, as if not
         * provided, then the daemon will generate a new cipher seed for the user.
         * Otherwise, then the daemon will attempt to recover the wallet state linked
         * to this cipher seed.
         * @member {Array.<string>} cipherSeedMnemonic
         * @memberof lnrpc.GenSeedResponse
         * @instance
         */
        GenSeedResponse.prototype.cipherSeedMnemonic = $util.emptyArray;

        /**
         * enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
         * cipher text before run through our mnemonic encoding scheme.
         * @member {Uint8Array} encipheredSeed
         * @memberof lnrpc.GenSeedResponse
         * @instance
         */
        GenSeedResponse.prototype.encipheredSeed = $util.newBuffer([]);

        /**
         * Creates a new GenSeedResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.IGenSeedResponse=} [properties] Properties to set
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse instance
         */
        GenSeedResponse.create = function create(properties) {
            return new GenSeedResponse(properties);
        };

        /**
         * Encodes the specified GenSeedResponse message. Does not implicitly {@link lnrpc.GenSeedResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.IGenSeedResponse} message GenSeedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cipherSeedMnemonic != null && message.cipherSeedMnemonic.length)
                for (var i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cipherSeedMnemonic[i]);
            if (message.encipheredSeed != null && message.hasOwnProperty("encipheredSeed"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encipheredSeed);
            return writer;
        };

        /**
         * Encodes the specified GenSeedResponse message, length delimited. Does not implicitly {@link lnrpc.GenSeedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.IGenSeedResponse} message GenSeedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenSeedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GenSeedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cipherSeedMnemonic && message.cipherSeedMnemonic.length))
                        message.cipherSeedMnemonic = [];
                    message.cipherSeedMnemonic.push(reader.string());
                    break;
                case 2:
                    message.encipheredSeed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenSeedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenSeedResponse message.
         * @function verify
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenSeedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cipherSeedMnemonic != null && message.hasOwnProperty("cipherSeedMnemonic")) {
                if (!Array.isArray(message.cipherSeedMnemonic))
                    return "cipherSeedMnemonic: array expected";
                for (var i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    if (!$util.isString(message.cipherSeedMnemonic[i]))
                        return "cipherSeedMnemonic: string[] expected";
            }
            if (message.encipheredSeed != null && message.hasOwnProperty("encipheredSeed"))
                if (!(message.encipheredSeed && typeof message.encipheredSeed.length === "number" || $util.isString(message.encipheredSeed)))
                    return "encipheredSeed: buffer expected";
            return null;
        };

        /**
         * Creates a GenSeedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse
         */
        GenSeedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GenSeedResponse)
                return object;
            var message = new $root.lnrpc.GenSeedResponse();
            if (object.cipherSeedMnemonic) {
                if (!Array.isArray(object.cipherSeedMnemonic))
                    throw TypeError(".lnrpc.GenSeedResponse.cipherSeedMnemonic: array expected");
                message.cipherSeedMnemonic = [];
                for (var i = 0; i < object.cipherSeedMnemonic.length; ++i)
                    message.cipherSeedMnemonic[i] = String(object.cipherSeedMnemonic[i]);
            }
            if (object.encipheredSeed != null)
                if (typeof object.encipheredSeed === "string")
                    $util.base64.decode(object.encipheredSeed, message.encipheredSeed = $util.newBuffer($util.base64.length(object.encipheredSeed)), 0);
                else if (object.encipheredSeed.length)
                    message.encipheredSeed = object.encipheredSeed;
            return message;
        };

        /**
         * Creates a plain object from a GenSeedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.GenSeedResponse} message GenSeedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenSeedResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cipherSeedMnemonic = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.encipheredSeed = "";
                else {
                    object.encipheredSeed = [];
                    if (options.bytes !== Array)
                        object.encipheredSeed = $util.newBuffer(object.encipheredSeed);
                }
            if (message.cipherSeedMnemonic && message.cipherSeedMnemonic.length) {
                object.cipherSeedMnemonic = [];
                for (var j = 0; j < message.cipherSeedMnemonic.length; ++j)
                    object.cipherSeedMnemonic[j] = message.cipherSeedMnemonic[j];
            }
            if (message.encipheredSeed != null && message.hasOwnProperty("encipheredSeed"))
                object.encipheredSeed = options.bytes === String ? $util.base64.encode(message.encipheredSeed, 0, message.encipheredSeed.length) : options.bytes === Array ? Array.prototype.slice.call(message.encipheredSeed) : message.encipheredSeed;
            return object;
        };

        /**
         * Converts this GenSeedResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.GenSeedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenSeedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenSeedResponse;
    })();

    lnrpc.InitWalletRequest = (function() {

        /**
         * Properties of an InitWalletRequest.
         * @memberof lnrpc
         * @interface IInitWalletRequest
         * @property {Uint8Array|null} [walletPassword] wallet_password is the passphrase that should be used to encrypt the
         * wallet. This MUST be at least 8 chars in length. After creation, this
         * password is required to unlock the daemon.
         * @property {Array.<string>|null} [cipherSeedMnemonic] cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This may have been generated by the
         * GenSeed method, or be an existing seed.
         * @property {Uint8Array|null} [aezeedPassphrase] aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @property {number|null} [recoveryWindow] recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * invdividual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         */

        /**
         * Constructs a new InitWalletRequest.
         * @memberof lnrpc
         * @classdesc Represents an InitWalletRequest.
         * @implements IInitWalletRequest
         * @constructor
         * @param {lnrpc.IInitWalletRequest=} [properties] Properties to set
         */
        function InitWalletRequest(properties) {
            this.cipherSeedMnemonic = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * wallet_password is the passphrase that should be used to encrypt the
         * wallet. This MUST be at least 8 chars in length. After creation, this
         * password is required to unlock the daemon.
         * @member {Uint8Array} walletPassword
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.walletPassword = $util.newBuffer([]);

        /**
         * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This may have been generated by the
         * GenSeed method, or be an existing seed.
         * @member {Array.<string>} cipherSeedMnemonic
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.cipherSeedMnemonic = $util.emptyArray;

        /**
         * aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @member {Uint8Array} aezeedPassphrase
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.aezeedPassphrase = $util.newBuffer([]);

        /**
         * recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * invdividual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         * @member {number} recoveryWindow
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.recoveryWindow = 0;

        /**
         * Creates a new InitWalletRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.IInitWalletRequest=} [properties] Properties to set
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest instance
         */
        InitWalletRequest.create = function create(properties) {
            return new InitWalletRequest(properties);
        };

        /**
         * Encodes the specified InitWalletRequest message. Does not implicitly {@link lnrpc.InitWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.IInitWalletRequest} message InitWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.walletPassword);
            if (message.cipherSeedMnemonic != null && message.cipherSeedMnemonic.length)
                for (var i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cipherSeedMnemonic[i]);
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.aezeedPassphrase);
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.recoveryWindow);
            return writer;
        };

        /**
         * Encodes the specified InitWalletRequest message, length delimited. Does not implicitly {@link lnrpc.InitWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.IInitWalletRequest} message InitWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InitWalletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.walletPassword = reader.bytes();
                    break;
                case 2:
                    if (!(message.cipherSeedMnemonic && message.cipherSeedMnemonic.length))
                        message.cipherSeedMnemonic = [];
                    message.cipherSeedMnemonic.push(reader.string());
                    break;
                case 3:
                    message.aezeedPassphrase = reader.bytes();
                    break;
                case 4:
                    message.recoveryWindow = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitWalletRequest message.
         * @function verify
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                if (!(message.walletPassword && typeof message.walletPassword.length === "number" || $util.isString(message.walletPassword)))
                    return "walletPassword: buffer expected";
            if (message.cipherSeedMnemonic != null && message.hasOwnProperty("cipherSeedMnemonic")) {
                if (!Array.isArray(message.cipherSeedMnemonic))
                    return "cipherSeedMnemonic: array expected";
                for (var i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    if (!$util.isString(message.cipherSeedMnemonic[i]))
                        return "cipherSeedMnemonic: string[] expected";
            }
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                if (!(message.aezeedPassphrase && typeof message.aezeedPassphrase.length === "number" || $util.isString(message.aezeedPassphrase)))
                    return "aezeedPassphrase: buffer expected";
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                if (!$util.isInteger(message.recoveryWindow))
                    return "recoveryWindow: integer expected";
            return null;
        };

        /**
         * Creates an InitWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest
         */
        InitWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InitWalletRequest)
                return object;
            var message = new $root.lnrpc.InitWalletRequest();
            if (object.walletPassword != null)
                if (typeof object.walletPassword === "string")
                    $util.base64.decode(object.walletPassword, message.walletPassword = $util.newBuffer($util.base64.length(object.walletPassword)), 0);
                else if (object.walletPassword.length)
                    message.walletPassword = object.walletPassword;
            if (object.cipherSeedMnemonic) {
                if (!Array.isArray(object.cipherSeedMnemonic))
                    throw TypeError(".lnrpc.InitWalletRequest.cipherSeedMnemonic: array expected");
                message.cipherSeedMnemonic = [];
                for (var i = 0; i < object.cipherSeedMnemonic.length; ++i)
                    message.cipherSeedMnemonic[i] = String(object.cipherSeedMnemonic[i]);
            }
            if (object.aezeedPassphrase != null)
                if (typeof object.aezeedPassphrase === "string")
                    $util.base64.decode(object.aezeedPassphrase, message.aezeedPassphrase = $util.newBuffer($util.base64.length(object.aezeedPassphrase)), 0);
                else if (object.aezeedPassphrase.length)
                    message.aezeedPassphrase = object.aezeedPassphrase;
            if (object.recoveryWindow != null)
                message.recoveryWindow = object.recoveryWindow | 0;
            return message;
        };

        /**
         * Creates a plain object from an InitWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.InitWalletRequest} message InitWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cipherSeedMnemonic = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.walletPassword = "";
                else {
                    object.walletPassword = [];
                    if (options.bytes !== Array)
                        object.walletPassword = $util.newBuffer(object.walletPassword);
                }
                if (options.bytes === String)
                    object.aezeedPassphrase = "";
                else {
                    object.aezeedPassphrase = [];
                    if (options.bytes !== Array)
                        object.aezeedPassphrase = $util.newBuffer(object.aezeedPassphrase);
                }
                object.recoveryWindow = 0;
            }
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                object.walletPassword = options.bytes === String ? $util.base64.encode(message.walletPassword, 0, message.walletPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.walletPassword) : message.walletPassword;
            if (message.cipherSeedMnemonic && message.cipherSeedMnemonic.length) {
                object.cipherSeedMnemonic = [];
                for (var j = 0; j < message.cipherSeedMnemonic.length; ++j)
                    object.cipherSeedMnemonic[j] = message.cipherSeedMnemonic[j];
            }
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                object.aezeedPassphrase = options.bytes === String ? $util.base64.encode(message.aezeedPassphrase, 0, message.aezeedPassphrase.length) : options.bytes === Array ? Array.prototype.slice.call(message.aezeedPassphrase) : message.aezeedPassphrase;
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                object.recoveryWindow = message.recoveryWindow;
            return object;
        };

        /**
         * Converts this InitWalletRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.InitWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitWalletRequest;
    })();

    lnrpc.InitWalletResponse = (function() {

        /**
         * Properties of an InitWalletResponse.
         * @memberof lnrpc
         * @interface IInitWalletResponse
         */

        /**
         * Constructs a new InitWalletResponse.
         * @memberof lnrpc
         * @classdesc Represents an InitWalletResponse.
         * @implements IInitWalletResponse
         * @constructor
         * @param {lnrpc.IInitWalletResponse=} [properties] Properties to set
         */
        function InitWalletResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InitWalletResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.IInitWalletResponse=} [properties] Properties to set
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse instance
         */
        InitWalletResponse.create = function create(properties) {
            return new InitWalletResponse(properties);
        };

        /**
         * Encodes the specified InitWalletResponse message. Does not implicitly {@link lnrpc.InitWalletResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.IInitWalletResponse} message InitWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InitWalletResponse message, length delimited. Does not implicitly {@link lnrpc.InitWalletResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.IInitWalletResponse} message InitWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitWalletResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InitWalletResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitWalletResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitWalletResponse message.
         * @function verify
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitWalletResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InitWalletResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse
         */
        InitWalletResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InitWalletResponse)
                return object;
            return new $root.lnrpc.InitWalletResponse();
        };

        /**
         * Creates a plain object from an InitWalletResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.InitWalletResponse} message InitWalletResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitWalletResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InitWalletResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.InitWalletResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitWalletResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitWalletResponse;
    })();

    lnrpc.UnlockWalletRequest = (function() {

        /**
         * Properties of an UnlockWalletRequest.
         * @memberof lnrpc
         * @interface IUnlockWalletRequest
         * @property {Uint8Array|null} [walletPassword] wallet_password should be the current valid passphrase for the daemon. This
         * will be required to decrypt on-disk material that the daemon requires to
         * function properly.
         * @property {number|null} [recoveryWindow] recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * invdividual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         */

        /**
         * Constructs a new UnlockWalletRequest.
         * @memberof lnrpc
         * @classdesc Represents an UnlockWalletRequest.
         * @implements IUnlockWalletRequest
         * @constructor
         * @param {lnrpc.IUnlockWalletRequest=} [properties] Properties to set
         */
        function UnlockWalletRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * wallet_password should be the current valid passphrase for the daemon. This
         * will be required to decrypt on-disk material that the daemon requires to
         * function properly.
         * @member {Uint8Array} walletPassword
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         */
        UnlockWalletRequest.prototype.walletPassword = $util.newBuffer([]);

        /**
         * recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * invdividual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         * @member {number} recoveryWindow
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         */
        UnlockWalletRequest.prototype.recoveryWindow = 0;

        /**
         * Creates a new UnlockWalletRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.IUnlockWalletRequest=} [properties] Properties to set
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest instance
         */
        UnlockWalletRequest.create = function create(properties) {
            return new UnlockWalletRequest(properties);
        };

        /**
         * Encodes the specified UnlockWalletRequest message. Does not implicitly {@link lnrpc.UnlockWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.IUnlockWalletRequest} message UnlockWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.walletPassword);
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.recoveryWindow);
            return writer;
        };

        /**
         * Encodes the specified UnlockWalletRequest message, length delimited. Does not implicitly {@link lnrpc.UnlockWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.IUnlockWalletRequest} message UnlockWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.UnlockWalletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.walletPassword = reader.bytes();
                    break;
                case 2:
                    message.recoveryWindow = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockWalletRequest message.
         * @function verify
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                if (!(message.walletPassword && typeof message.walletPassword.length === "number" || $util.isString(message.walletPassword)))
                    return "walletPassword: buffer expected";
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                if (!$util.isInteger(message.recoveryWindow))
                    return "recoveryWindow: integer expected";
            return null;
        };

        /**
         * Creates an UnlockWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest
         */
        UnlockWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.UnlockWalletRequest)
                return object;
            var message = new $root.lnrpc.UnlockWalletRequest();
            if (object.walletPassword != null)
                if (typeof object.walletPassword === "string")
                    $util.base64.decode(object.walletPassword, message.walletPassword = $util.newBuffer($util.base64.length(object.walletPassword)), 0);
                else if (object.walletPassword.length)
                    message.walletPassword = object.walletPassword;
            if (object.recoveryWindow != null)
                message.recoveryWindow = object.recoveryWindow | 0;
            return message;
        };

        /**
         * Creates a plain object from an UnlockWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.UnlockWalletRequest} message UnlockWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.walletPassword = "";
                else {
                    object.walletPassword = [];
                    if (options.bytes !== Array)
                        object.walletPassword = $util.newBuffer(object.walletPassword);
                }
                object.recoveryWindow = 0;
            }
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                object.walletPassword = options.bytes === String ? $util.base64.encode(message.walletPassword, 0, message.walletPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.walletPassword) : message.walletPassword;
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                object.recoveryWindow = message.recoveryWindow;
            return object;
        };

        /**
         * Converts this UnlockWalletRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlockWalletRequest;
    })();

    lnrpc.UnlockWalletResponse = (function() {

        /**
         * Properties of an UnlockWalletResponse.
         * @memberof lnrpc
         * @interface IUnlockWalletResponse
         */

        /**
         * Constructs a new UnlockWalletResponse.
         * @memberof lnrpc
         * @classdesc Represents an UnlockWalletResponse.
         * @implements IUnlockWalletResponse
         * @constructor
         * @param {lnrpc.IUnlockWalletResponse=} [properties] Properties to set
         */
        function UnlockWalletResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UnlockWalletResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.IUnlockWalletResponse=} [properties] Properties to set
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse instance
         */
        UnlockWalletResponse.create = function create(properties) {
            return new UnlockWalletResponse(properties);
        };

        /**
         * Encodes the specified UnlockWalletResponse message. Does not implicitly {@link lnrpc.UnlockWalletResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.IUnlockWalletResponse} message UnlockWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UnlockWalletResponse message, length delimited. Does not implicitly {@link lnrpc.UnlockWalletResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.IUnlockWalletResponse} message UnlockWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockWalletResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.UnlockWalletResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockWalletResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockWalletResponse message.
         * @function verify
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockWalletResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UnlockWalletResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse
         */
        UnlockWalletResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.UnlockWalletResponse)
                return object;
            return new $root.lnrpc.UnlockWalletResponse();
        };

        /**
         * Creates a plain object from an UnlockWalletResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.UnlockWalletResponse} message UnlockWalletResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockWalletResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UnlockWalletResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.UnlockWalletResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockWalletResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlockWalletResponse;
    })();

    lnrpc.ChangePasswordRequest = (function() {

        /**
         * Properties of a ChangePasswordRequest.
         * @memberof lnrpc
         * @interface IChangePasswordRequest
         * @property {Uint8Array|null} [currentPassword] current_password should be the current valid passphrase used to unlock the
         * daemon.
         * @property {Uint8Array|null} [newPassword] new_password should be the new passphrase that will be needed to unlock the
         * daemon.
         */

        /**
         * Constructs a new ChangePasswordRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChangePasswordRequest.
         * @implements IChangePasswordRequest
         * @constructor
         * @param {lnrpc.IChangePasswordRequest=} [properties] Properties to set
         */
        function ChangePasswordRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * current_password should be the current valid passphrase used to unlock the
         * daemon.
         * @member {Uint8Array} currentPassword
         * @memberof lnrpc.ChangePasswordRequest
         * @instance
         */
        ChangePasswordRequest.prototype.currentPassword = $util.newBuffer([]);

        /**
         * new_password should be the new passphrase that will be needed to unlock the
         * daemon.
         * @member {Uint8Array} newPassword
         * @memberof lnrpc.ChangePasswordRequest
         * @instance
         */
        ChangePasswordRequest.prototype.newPassword = $util.newBuffer([]);

        /**
         * Creates a new ChangePasswordRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.IChangePasswordRequest=} [properties] Properties to set
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest instance
         */
        ChangePasswordRequest.create = function create(properties) {
            return new ChangePasswordRequest(properties);
        };

        /**
         * Encodes the specified ChangePasswordRequest message. Does not implicitly {@link lnrpc.ChangePasswordRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.IChangePasswordRequest} message ChangePasswordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentPassword != null && message.hasOwnProperty("currentPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.currentPassword);
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.newPassword);
            return writer;
        };

        /**
         * Encodes the specified ChangePasswordRequest message, length delimited. Does not implicitly {@link lnrpc.ChangePasswordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.IChangePasswordRequest} message ChangePasswordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangePasswordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChangePasswordRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentPassword = reader.bytes();
                    break;
                case 2:
                    message.newPassword = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangePasswordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangePasswordRequest message.
         * @function verify
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangePasswordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentPassword != null && message.hasOwnProperty("currentPassword"))
                if (!(message.currentPassword && typeof message.currentPassword.length === "number" || $util.isString(message.currentPassword)))
                    return "currentPassword: buffer expected";
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                if (!(message.newPassword && typeof message.newPassword.length === "number" || $util.isString(message.newPassword)))
                    return "newPassword: buffer expected";
            return null;
        };

        /**
         * Creates a ChangePasswordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest
         */
        ChangePasswordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChangePasswordRequest)
                return object;
            var message = new $root.lnrpc.ChangePasswordRequest();
            if (object.currentPassword != null)
                if (typeof object.currentPassword === "string")
                    $util.base64.decode(object.currentPassword, message.currentPassword = $util.newBuffer($util.base64.length(object.currentPassword)), 0);
                else if (object.currentPassword.length)
                    message.currentPassword = object.currentPassword;
            if (object.newPassword != null)
                if (typeof object.newPassword === "string")
                    $util.base64.decode(object.newPassword, message.newPassword = $util.newBuffer($util.base64.length(object.newPassword)), 0);
                else if (object.newPassword.length)
                    message.newPassword = object.newPassword;
            return message;
        };

        /**
         * Creates a plain object from a ChangePasswordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.ChangePasswordRequest} message ChangePasswordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangePasswordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.currentPassword = "";
                else {
                    object.currentPassword = [];
                    if (options.bytes !== Array)
                        object.currentPassword = $util.newBuffer(object.currentPassword);
                }
                if (options.bytes === String)
                    object.newPassword = "";
                else {
                    object.newPassword = [];
                    if (options.bytes !== Array)
                        object.newPassword = $util.newBuffer(object.newPassword);
                }
            }
            if (message.currentPassword != null && message.hasOwnProperty("currentPassword"))
                object.currentPassword = options.bytes === String ? $util.base64.encode(message.currentPassword, 0, message.currentPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.currentPassword) : message.currentPassword;
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                object.newPassword = options.bytes === String ? $util.base64.encode(message.newPassword, 0, message.newPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.newPassword) : message.newPassword;
            return object;
        };

        /**
         * Converts this ChangePasswordRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChangePasswordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangePasswordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangePasswordRequest;
    })();

    lnrpc.ChangePasswordResponse = (function() {

        /**
         * Properties of a ChangePasswordResponse.
         * @memberof lnrpc
         * @interface IChangePasswordResponse
         */

        /**
         * Constructs a new ChangePasswordResponse.
         * @memberof lnrpc
         * @classdesc Represents a ChangePasswordResponse.
         * @implements IChangePasswordResponse
         * @constructor
         * @param {lnrpc.IChangePasswordResponse=} [properties] Properties to set
         */
        function ChangePasswordResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChangePasswordResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.IChangePasswordResponse=} [properties] Properties to set
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse instance
         */
        ChangePasswordResponse.create = function create(properties) {
            return new ChangePasswordResponse(properties);
        };

        /**
         * Encodes the specified ChangePasswordResponse message. Does not implicitly {@link lnrpc.ChangePasswordResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.IChangePasswordResponse} message ChangePasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChangePasswordResponse message, length delimited. Does not implicitly {@link lnrpc.ChangePasswordResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.IChangePasswordResponse} message ChangePasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangePasswordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChangePasswordResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangePasswordResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangePasswordResponse message.
         * @function verify
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangePasswordResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChangePasswordResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse
         */
        ChangePasswordResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChangePasswordResponse)
                return object;
            return new $root.lnrpc.ChangePasswordResponse();
        };

        /**
         * Creates a plain object from a ChangePasswordResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.ChangePasswordResponse} message ChangePasswordResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangePasswordResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChangePasswordResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ChangePasswordResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangePasswordResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangePasswordResponse;
    })();

    lnrpc.Lightning = (function() {

        /**
         * Constructs a new Lightning service.
         * @memberof lnrpc
         * @classdesc Represents a Lightning
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Lightning(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Lightning.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Lightning;

        /**
         * Creates new Lightning service using the specified rpc implementation.
         * @function create
         * @memberof lnrpc.Lightning
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Lightning} RPC service. Useful where requests and/or responses are streamed.
         */
        Lightning.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link lnrpc.Lightning#walletBalance}.
         * @memberof lnrpc.Lightning
         * @typedef WalletBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.WalletBalanceResponse} [response] WalletBalanceResponse
         */

        /**
         * lncli: `walletbalance`
         * WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
         * confirmed unspent outputs and all unconfirmed unspent outputs under control
         * of the wallet.
         * @function walletBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IWalletBalanceRequest} request WalletBalanceRequest message or plain object
         * @param {lnrpc.Lightning.WalletBalanceCallback} callback Node-style callback called with the error, if any, and WalletBalanceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.walletBalance = function walletBalance(request, callback) {
            return this.rpcCall(walletBalance, $root.lnrpc.WalletBalanceRequest, $root.lnrpc.WalletBalanceResponse, request, callback);
        }, "name", { value: "WalletBalance" });

        /**
         * lncli: `walletbalance`
         * WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
         * confirmed unspent outputs and all unconfirmed unspent outputs under control
         * of the wallet.
         * @function walletBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IWalletBalanceRequest} request WalletBalanceRequest message or plain object
         * @returns {Promise<lnrpc.WalletBalanceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#channelBalance}.
         * @memberof lnrpc.Lightning
         * @typedef ChannelBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelBalanceResponse} [response] ChannelBalanceResponse
         */

        /**
         * lncli: `channelbalance`
         * ChannelBalance returns the total funds available across all open channels
         * in satoshis.
         * @function channelBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBalanceRequest} request ChannelBalanceRequest message or plain object
         * @param {lnrpc.Lightning.ChannelBalanceCallback} callback Node-style callback called with the error, if any, and ChannelBalanceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.channelBalance = function channelBalance(request, callback) {
            return this.rpcCall(channelBalance, $root.lnrpc.ChannelBalanceRequest, $root.lnrpc.ChannelBalanceResponse, request, callback);
        }, "name", { value: "ChannelBalance" });

        /**
         * lncli: `channelbalance`
         * ChannelBalance returns the total funds available across all open channels
         * in satoshis.
         * @function channelBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBalanceRequest} request ChannelBalanceRequest message or plain object
         * @returns {Promise<lnrpc.ChannelBalanceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getTransactions}.
         * @memberof lnrpc.Lightning
         * @typedef GetTransactionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.TransactionDetails} [response] TransactionDetails
         */

        /**
         * lncli: `listchaintxns`
         * GetTransactions returns a list describing all the known transactions
         * relevant to the wallet.
         * @function getTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @param {lnrpc.Lightning.GetTransactionsCallback} callback Node-style callback called with the error, if any, and TransactionDetails
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getTransactions = function getTransactions(request, callback) {
            return this.rpcCall(getTransactions, $root.lnrpc.GetTransactionsRequest, $root.lnrpc.TransactionDetails, request, callback);
        }, "name", { value: "GetTransactions" });

        /**
         * lncli: `listchaintxns`
         * GetTransactions returns a list describing all the known transactions
         * relevant to the wallet.
         * @function getTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @returns {Promise<lnrpc.TransactionDetails>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendCoins}.
         * @memberof lnrpc.Lightning
         * @typedef SendCoinsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendCoinsResponse} [response] SendCoinsResponse
         */

        /**
         * lncli: `sendcoins`
         * SendCoins executes a request to send coins to a particular address. Unlike
         * SendMany, this RPC call only allows creating a single output at a time. If
         * neither target_conf, or sat_per_byte are set, then the internal wallet will
         * consult its fee model to determine a fee for the default confirmation
         * target.
         * @function sendCoins
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendCoinsRequest} request SendCoinsRequest message or plain object
         * @param {lnrpc.Lightning.SendCoinsCallback} callback Node-style callback called with the error, if any, and SendCoinsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendCoins = function sendCoins(request, callback) {
            return this.rpcCall(sendCoins, $root.lnrpc.SendCoinsRequest, $root.lnrpc.SendCoinsResponse, request, callback);
        }, "name", { value: "SendCoins" });

        /**
         * lncli: `sendcoins`
         * SendCoins executes a request to send coins to a particular address. Unlike
         * SendMany, this RPC call only allows creating a single output at a time. If
         * neither target_conf, or sat_per_byte are set, then the internal wallet will
         * consult its fee model to determine a fee for the default confirmation
         * target.
         * @function sendCoins
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendCoinsRequest} request SendCoinsRequest message or plain object
         * @returns {Promise<lnrpc.SendCoinsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeTransactions}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeTransactionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Transaction} [response] Transaction
         */

        /**
         * SubscribeTransactions creates a uni-directional stream from the server to
         * the client in which any newly discovered transactions relevant to the
         * wallet are sent over.
         * @function subscribeTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @param {lnrpc.Lightning.SubscribeTransactionsCallback} callback Node-style callback called with the error, if any, and Transaction
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeTransactions = function subscribeTransactions(request, callback) {
            return this.rpcCall(subscribeTransactions, $root.lnrpc.GetTransactionsRequest, $root.lnrpc.Transaction, request, callback);
        }, "name", { value: "SubscribeTransactions" });

        /**
         * SubscribeTransactions creates a uni-directional stream from the server to
         * the client in which any newly discovered transactions relevant to the
         * wallet are sent over.
         * @function subscribeTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @returns {Promise<lnrpc.Transaction>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendMany}.
         * @memberof lnrpc.Lightning
         * @typedef SendManyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendManyResponse} [response] SendManyResponse
         */

        /**
         * lncli: `sendmany`
         * SendMany handles a request for a transaction that creates multiple specified
         * outputs in parallel. If neither target_conf, or sat_per_byte are set, then
         * the internal wallet will consult its fee model to determine a fee for the
         * default confirmation target.
         * @function sendMany
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendManyRequest} request SendManyRequest message or plain object
         * @param {lnrpc.Lightning.SendManyCallback} callback Node-style callback called with the error, if any, and SendManyResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendMany = function sendMany(request, callback) {
            return this.rpcCall(sendMany, $root.lnrpc.SendManyRequest, $root.lnrpc.SendManyResponse, request, callback);
        }, "name", { value: "SendMany" });

        /**
         * lncli: `sendmany`
         * SendMany handles a request for a transaction that creates multiple specified
         * outputs in parallel. If neither target_conf, or sat_per_byte are set, then
         * the internal wallet will consult its fee model to determine a fee for the
         * default confirmation target.
         * @function sendMany
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendManyRequest} request SendManyRequest message or plain object
         * @returns {Promise<lnrpc.SendManyResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#newAddress}.
         * @memberof lnrpc.Lightning
         * @typedef NewAddressCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NewAddressResponse} [response] NewAddressResponse
         */

        /**
         * lncli: `newaddress`
         * NewAddress creates a new address under control of the local wallet.
         * @function newAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewAddressRequest} request NewAddressRequest message or plain object
         * @param {lnrpc.Lightning.NewAddressCallback} callback Node-style callback called with the error, if any, and NewAddressResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.newAddress = function newAddress(request, callback) {
            return this.rpcCall(newAddress, $root.lnrpc.NewAddressRequest, $root.lnrpc.NewAddressResponse, request, callback);
        }, "name", { value: "NewAddress" });

        /**
         * lncli: `newaddress`
         * NewAddress creates a new address under control of the local wallet.
         * @function newAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewAddressRequest} request NewAddressRequest message or plain object
         * @returns {Promise<lnrpc.NewAddressResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#newWitnessAddress}.
         * @memberof lnrpc.Lightning
         * @typedef NewWitnessAddressCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NewAddressResponse} [response] NewAddressResponse
         */

        /**
         * NewWitnessAddress creates a new witness address under control of the local wallet.
         * @function newWitnessAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewWitnessAddressRequest} request NewWitnessAddressRequest message or plain object
         * @param {lnrpc.Lightning.NewWitnessAddressCallback} callback Node-style callback called with the error, if any, and NewAddressResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.newWitnessAddress = function newWitnessAddress(request, callback) {
            return this.rpcCall(newWitnessAddress, $root.lnrpc.NewWitnessAddressRequest, $root.lnrpc.NewAddressResponse, request, callback);
        }, "name", { value: "NewWitnessAddress" });

        /**
         * NewWitnessAddress creates a new witness address under control of the local wallet.
         * @function newWitnessAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewWitnessAddressRequest} request NewWitnessAddressRequest message or plain object
         * @returns {Promise<lnrpc.NewAddressResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#signMessage}.
         * @memberof lnrpc.Lightning
         * @typedef SignMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SignMessageResponse} [response] SignMessageResponse
         */

        /**
         * lncli: `signmessage`
         * SignMessage signs a message with this node's private key. The returned
         * signature string is `zbase32` encoded and pubkey recoverable, meaning that
         * only the message digest and signature are needed for verification.
         * @function signMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISignMessageRequest} request SignMessageRequest message or plain object
         * @param {lnrpc.Lightning.SignMessageCallback} callback Node-style callback called with the error, if any, and SignMessageResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.signMessage = function signMessage(request, callback) {
            return this.rpcCall(signMessage, $root.lnrpc.SignMessageRequest, $root.lnrpc.SignMessageResponse, request, callback);
        }, "name", { value: "SignMessage" });

        /**
         * lncli: `signmessage`
         * SignMessage signs a message with this node's private key. The returned
         * signature string is `zbase32` encoded and pubkey recoverable, meaning that
         * only the message digest and signature are needed for verification.
         * @function signMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISignMessageRequest} request SignMessageRequest message or plain object
         * @returns {Promise<lnrpc.SignMessageResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#verifyMessage}.
         * @memberof lnrpc.Lightning
         * @typedef VerifyMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.VerifyMessageResponse} [response] VerifyMessageResponse
         */

        /**
         * lncli: `verifymessage`
         * VerifyMessage verifies a signature over a msg. The signature must be
         * zbase32 encoded and signed by an active node in the resident node's
         * channel database. In addition to returning the validity of the signature,
         * VerifyMessage also returns the recovered pubkey from the signature.
         * @function verifyMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IVerifyMessageRequest} request VerifyMessageRequest message or plain object
         * @param {lnrpc.Lightning.VerifyMessageCallback} callback Node-style callback called with the error, if any, and VerifyMessageResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.verifyMessage = function verifyMessage(request, callback) {
            return this.rpcCall(verifyMessage, $root.lnrpc.VerifyMessageRequest, $root.lnrpc.VerifyMessageResponse, request, callback);
        }, "name", { value: "VerifyMessage" });

        /**
         * lncli: `verifymessage`
         * VerifyMessage verifies a signature over a msg. The signature must be
         * zbase32 encoded and signed by an active node in the resident node's
         * channel database. In addition to returning the validity of the signature,
         * VerifyMessage also returns the recovered pubkey from the signature.
         * @function verifyMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IVerifyMessageRequest} request VerifyMessageRequest message or plain object
         * @returns {Promise<lnrpc.VerifyMessageResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#connectPeer}.
         * @memberof lnrpc.Lightning
         * @typedef ConnectPeerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ConnectPeerResponse} [response] ConnectPeerResponse
         */

        /**
         * lncli: `connect`
         * ConnectPeer attempts to establish a connection to a remote peer. This is at
         * the networking level, and is used for communication between nodes. This is
         * distinct from establishing a channel with a peer.
         * @function connectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IConnectPeerRequest} request ConnectPeerRequest message or plain object
         * @param {lnrpc.Lightning.ConnectPeerCallback} callback Node-style callback called with the error, if any, and ConnectPeerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.connectPeer = function connectPeer(request, callback) {
            return this.rpcCall(connectPeer, $root.lnrpc.ConnectPeerRequest, $root.lnrpc.ConnectPeerResponse, request, callback);
        }, "name", { value: "ConnectPeer" });

        /**
         * lncli: `connect`
         * ConnectPeer attempts to establish a connection to a remote peer. This is at
         * the networking level, and is used for communication between nodes. This is
         * distinct from establishing a channel with a peer.
         * @function connectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IConnectPeerRequest} request ConnectPeerRequest message or plain object
         * @returns {Promise<lnrpc.ConnectPeerResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#disconnectPeer}.
         * @memberof lnrpc.Lightning
         * @typedef DisconnectPeerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DisconnectPeerResponse} [response] DisconnectPeerResponse
         */

        /**
         * lncli: `disconnect`
         * DisconnectPeer attempts to disconnect one peer from another identified by a
         * given pubKey. In the case that we currently have a pending or active channel
         * with the target peer, then this action will be not be allowed.
         * @function disconnectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDisconnectPeerRequest} request DisconnectPeerRequest message or plain object
         * @param {lnrpc.Lightning.DisconnectPeerCallback} callback Node-style callback called with the error, if any, and DisconnectPeerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.disconnectPeer = function disconnectPeer(request, callback) {
            return this.rpcCall(disconnectPeer, $root.lnrpc.DisconnectPeerRequest, $root.lnrpc.DisconnectPeerResponse, request, callback);
        }, "name", { value: "DisconnectPeer" });

        /**
         * lncli: `disconnect`
         * DisconnectPeer attempts to disconnect one peer from another identified by a
         * given pubKey. In the case that we currently have a pending or active channel
         * with the target peer, then this action will be not be allowed.
         * @function disconnectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDisconnectPeerRequest} request DisconnectPeerRequest message or plain object
         * @returns {Promise<lnrpc.DisconnectPeerResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPeers}.
         * @memberof lnrpc.Lightning
         * @typedef ListPeersCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPeersResponse} [response] ListPeersResponse
         */

        /**
         * lncli: `listpeers`
         * ListPeers returns a verbose listing of all currently active peers.
         * @function listPeers
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPeersRequest} request ListPeersRequest message or plain object
         * @param {lnrpc.Lightning.ListPeersCallback} callback Node-style callback called with the error, if any, and ListPeersResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPeers = function listPeers(request, callback) {
            return this.rpcCall(listPeers, $root.lnrpc.ListPeersRequest, $root.lnrpc.ListPeersResponse, request, callback);
        }, "name", { value: "ListPeers" });

        /**
         * lncli: `listpeers`
         * ListPeers returns a verbose listing of all currently active peers.
         * @function listPeers
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPeersRequest} request ListPeersRequest message or plain object
         * @returns {Promise<lnrpc.ListPeersResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GetInfoResponse} [response] GetInfoResponse
         */

        /**
         * lncli: `getinfo`
         * GetInfo returns general information concerning the lightning node including
         * it's identity pubkey, alias, the chains it is connected to, and information
         * concerning the number of open+pending channels.
         * @function getInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetInfoRequest} request GetInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetInfoCallback} callback Node-style callback called with the error, if any, and GetInfoResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getInfo = function getInfo(request, callback) {
            return this.rpcCall(getInfo, $root.lnrpc.GetInfoRequest, $root.lnrpc.GetInfoResponse, request, callback);
        }, "name", { value: "GetInfo" });

        /**
         * lncli: `getinfo`
         * GetInfo returns general information concerning the lightning node including
         * it's identity pubkey, alias, the chains it is connected to, and information
         * concerning the number of open+pending channels.
         * @function getInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetInfoRequest} request GetInfoRequest message or plain object
         * @returns {Promise<lnrpc.GetInfoResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#pendingChannels}.
         * @memberof lnrpc.Lightning
         * @typedef PendingChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PendingChannelsResponse} [response] PendingChannelsResponse
         */

        /**
         * lncli: `pendingchannels`
         * PendingChannels returns a list of all the channels that are currently
         * considered "pending". A channel is pending if it has finished the funding
         * workflow and is waiting for confirmations for the funding txn, or is in the
         * process of closure, either initiated cooperatively or non-cooperatively.
         * @function pendingChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPendingChannelsRequest} request PendingChannelsRequest message or plain object
         * @param {lnrpc.Lightning.PendingChannelsCallback} callback Node-style callback called with the error, if any, and PendingChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.pendingChannels = function pendingChannels(request, callback) {
            return this.rpcCall(pendingChannels, $root.lnrpc.PendingChannelsRequest, $root.lnrpc.PendingChannelsResponse, request, callback);
        }, "name", { value: "PendingChannels" });

        /**
         * lncli: `pendingchannels`
         * PendingChannels returns a list of all the channels that are currently
         * considered "pending". A channel is pending if it has finished the funding
         * workflow and is waiting for confirmations for the funding txn, or is in the
         * process of closure, either initiated cooperatively or non-cooperatively.
         * @function pendingChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPendingChannelsRequest} request PendingChannelsRequest message or plain object
         * @returns {Promise<lnrpc.PendingChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listChannels}.
         * @memberof lnrpc.Lightning
         * @typedef ListChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListChannelsResponse} [response] ListChannelsResponse
         */

        /**
         * lncli: `listchannels`
         * ListChannels returns a description of all the open channels that this node
         * is a participant in.
         * @function listChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListChannelsRequest} request ListChannelsRequest message or plain object
         * @param {lnrpc.Lightning.ListChannelsCallback} callback Node-style callback called with the error, if any, and ListChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listChannels = function listChannels(request, callback) {
            return this.rpcCall(listChannels, $root.lnrpc.ListChannelsRequest, $root.lnrpc.ListChannelsResponse, request, callback);
        }, "name", { value: "ListChannels" });

        /**
         * lncli: `listchannels`
         * ListChannels returns a description of all the open channels that this node
         * is a participant in.
         * @function listChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListChannelsRequest} request ListChannelsRequest message or plain object
         * @returns {Promise<lnrpc.ListChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#closedChannels}.
         * @memberof lnrpc.Lightning
         * @typedef ClosedChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ClosedChannelsResponse} [response] ClosedChannelsResponse
         */

        /**
         * lncli: `closedchannels`
         * ClosedChannels returns a description of all the closed channels that
         * this node was a participant in.
         * @function closedChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IClosedChannelsRequest} request ClosedChannelsRequest message or plain object
         * @param {lnrpc.Lightning.ClosedChannelsCallback} callback Node-style callback called with the error, if any, and ClosedChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.closedChannels = function closedChannels(request, callback) {
            return this.rpcCall(closedChannels, $root.lnrpc.ClosedChannelsRequest, $root.lnrpc.ClosedChannelsResponse, request, callback);
        }, "name", { value: "ClosedChannels" });

        /**
         * lncli: `closedchannels`
         * ClosedChannels returns a description of all the closed channels that
         * this node was a participant in.
         * @function closedChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IClosedChannelsRequest} request ClosedChannelsRequest message or plain object
         * @returns {Promise<lnrpc.ClosedChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#openChannelSync}.
         * @memberof lnrpc.Lightning
         * @typedef OpenChannelSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelPoint} [response] ChannelPoint
         */

        /**
         * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
         * call is meant to be consumed by clients to the REST proxy. As with all
         * other sync calls, all byte slices are intended to be populated as hex
         * encoded strings.
         * @function openChannelSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @param {lnrpc.Lightning.OpenChannelSyncCallback} callback Node-style callback called with the error, if any, and ChannelPoint
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.openChannelSync = function openChannelSync(request, callback) {
            return this.rpcCall(openChannelSync, $root.lnrpc.OpenChannelRequest, $root.lnrpc.ChannelPoint, request, callback);
        }, "name", { value: "OpenChannelSync" });

        /**
         * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
         * call is meant to be consumed by clients to the REST proxy. As with all
         * other sync calls, all byte slices are intended to be populated as hex
         * encoded strings.
         * @function openChannelSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @returns {Promise<lnrpc.ChannelPoint>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#openChannel}.
         * @memberof lnrpc.Lightning
         * @typedef OpenChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.OpenStatusUpdate} [response] OpenStatusUpdate
         */

        /**
         * lncli: `openchannel`
         * OpenChannel attempts to open a singly funded channel specified in the
         * request to a remote peer. Users are able to specify a target number of
         * blocks that the funding transaction should be confirmed in, or a manual fee
         * rate to us for the funding transaction. If neither are specified, then a
         * lax block confirmation target is used.
         * @function openChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @param {lnrpc.Lightning.OpenChannelCallback} callback Node-style callback called with the error, if any, and OpenStatusUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.openChannel = function openChannel(request, callback) {
            return this.rpcCall(openChannel, $root.lnrpc.OpenChannelRequest, $root.lnrpc.OpenStatusUpdate, request, callback);
        }, "name", { value: "OpenChannel" });

        /**
         * lncli: `openchannel`
         * OpenChannel attempts to open a singly funded channel specified in the
         * request to a remote peer. Users are able to specify a target number of
         * blocks that the funding transaction should be confirmed in, or a manual fee
         * rate to us for the funding transaction. If neither are specified, then a
         * lax block confirmation target is used.
         * @function openChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @returns {Promise<lnrpc.OpenStatusUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#closeChannel}.
         * @memberof lnrpc.Lightning
         * @typedef CloseChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.CloseStatusUpdate} [response] CloseStatusUpdate
         */

        /**
         * lncli: `closechannel`
         * CloseChannel attempts to close an active channel identified by its channel
         * outpoint (ChannelPoint). The actions of this method can additionally be
         * augmented to attempt a force close after a timeout period in the case of an
         * inactive peer. If a non-force close (cooperative closure) is requested,
         * then the user can specify either a target number of blocks until the
         * closure transaction is confirmed, or a manual fee rate. If neither are
         * specified, then a default lax, block confirmation target is used.
         * @function closeChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ICloseChannelRequest} request CloseChannelRequest message or plain object
         * @param {lnrpc.Lightning.CloseChannelCallback} callback Node-style callback called with the error, if any, and CloseStatusUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.closeChannel = function closeChannel(request, callback) {
            return this.rpcCall(closeChannel, $root.lnrpc.CloseChannelRequest, $root.lnrpc.CloseStatusUpdate, request, callback);
        }, "name", { value: "CloseChannel" });

        /**
         * lncli: `closechannel`
         * CloseChannel attempts to close an active channel identified by its channel
         * outpoint (ChannelPoint). The actions of this method can additionally be
         * augmented to attempt a force close after a timeout period in the case of an
         * inactive peer. If a non-force close (cooperative closure) is requested,
         * then the user can specify either a target number of blocks until the
         * closure transaction is confirmed, or a manual fee rate. If neither are
         * specified, then a default lax, block confirmation target is used.
         * @function closeChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ICloseChannelRequest} request CloseChannelRequest message or plain object
         * @returns {Promise<lnrpc.CloseStatusUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendPayment}.
         * @memberof lnrpc.Lightning
         * @typedef SendPaymentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * lncli: `sendpayment`
         * SendPayment dispatches a bi-directional streaming RPC for sending payments
         * through the Lightning Network. A single RPC invocation creates a persistent
         * bi-directional stream allowing clients to rapidly send payments through the
         * Lightning Network with a single persistent connection.
         * @function sendPayment
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @param {lnrpc.Lightning.SendPaymentCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendPayment = function sendPayment(request, callback) {
            return this.rpcCall(sendPayment, $root.lnrpc.SendRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendPayment" });

        /**
         * lncli: `sendpayment`
         * SendPayment dispatches a bi-directional streaming RPC for sending payments
         * through the Lightning Network. A single RPC invocation creates a persistent
         * bi-directional stream allowing clients to rapidly send payments through the
         * Lightning Network with a single persistent connection.
         * @function sendPayment
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendPaymentSync}.
         * @memberof lnrpc.Lightning
         * @typedef SendPaymentSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * SendPaymentSync is the synchronous non-streaming version of SendPayment.
         * This RPC is intended to be consumed by clients of the REST proxy.
         * Additionally, this RPC expects the destination's public key and the payment
         * hash (if any) to be encoded as hex strings.
         * @function sendPaymentSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @param {lnrpc.Lightning.SendPaymentSyncCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendPaymentSync = function sendPaymentSync(request, callback) {
            return this.rpcCall(sendPaymentSync, $root.lnrpc.SendRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendPaymentSync" });

        /**
         * SendPaymentSync is the synchronous non-streaming version of SendPayment.
         * This RPC is intended to be consumed by clients of the REST proxy.
         * Additionally, this RPC expects the destination's public key and the payment
         * hash (if any) to be encoded as hex strings.
         * @function sendPaymentSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendToRoute}.
         * @memberof lnrpc.Lightning
         * @typedef SendToRouteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * lncli: `sendtoroute`
         * SendToRoute is a bi-directional streaming RPC for sending payment through
         * the Lightning Network. This method differs from SendPayment in that it
         * allows users to specify a full route manually. This can be used for things
         * like rebalancing, and atomic swaps.
         * @function sendToRoute
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @param {lnrpc.Lightning.SendToRouteCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendToRoute = function sendToRoute(request, callback) {
            return this.rpcCall(sendToRoute, $root.lnrpc.SendToRouteRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendToRoute" });

        /**
         * lncli: `sendtoroute`
         * SendToRoute is a bi-directional streaming RPC for sending payment through
         * the Lightning Network. This method differs from SendPayment in that it
         * allows users to specify a full route manually. This can be used for things
         * like rebalancing, and atomic swaps.
         * @function sendToRoute
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendToRouteSync}.
         * @memberof lnrpc.Lightning
         * @typedef SendToRouteSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * SendToRouteSync is a synchronous version of SendToRoute. It Will block
         * until the payment either fails or succeeds.
         * @function sendToRouteSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @param {lnrpc.Lightning.SendToRouteSyncCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendToRouteSync = function sendToRouteSync(request, callback) {
            return this.rpcCall(sendToRouteSync, $root.lnrpc.SendToRouteRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendToRouteSync" });

        /**
         * SendToRouteSync is a synchronous version of SendToRoute. It Will block
         * until the payment either fails or succeeds.
         * @function sendToRouteSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#addInvoice}.
         * @memberof lnrpc.Lightning
         * @typedef AddInvoiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.AddInvoiceResponse} [response] AddInvoiceResponse
         */

        /**
         * lncli: `addinvoice`
         * AddInvoice attempts to add a new invoice to the invoice database. Any
         * duplicated invoices are rejected, therefore all invoices *must* have a
         * unique payment preimage.
         * @function addInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoice} request Invoice message or plain object
         * @param {lnrpc.Lightning.AddInvoiceCallback} callback Node-style callback called with the error, if any, and AddInvoiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.addInvoice = function addInvoice(request, callback) {
            return this.rpcCall(addInvoice, $root.lnrpc.Invoice, $root.lnrpc.AddInvoiceResponse, request, callback);
        }, "name", { value: "AddInvoice" });

        /**
         * lncli: `addinvoice`
         * AddInvoice attempts to add a new invoice to the invoice database. Any
         * duplicated invoices are rejected, therefore all invoices *must* have a
         * unique payment preimage.
         * @function addInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoice} request Invoice message or plain object
         * @returns {Promise<lnrpc.AddInvoiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listInvoices}.
         * @memberof lnrpc.Lightning
         * @typedef ListInvoicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListInvoiceResponse} [response] ListInvoiceResponse
         */

        /**
         * lncli: `listinvoices`
         * ListInvoices returns a list of all the invoices currently stored within the
         * database. Any active debug invoices are ignored.
         * @function listInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListInvoiceRequest} request ListInvoiceRequest message or plain object
         * @param {lnrpc.Lightning.ListInvoicesCallback} callback Node-style callback called with the error, if any, and ListInvoiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listInvoices = function listInvoices(request, callback) {
            return this.rpcCall(listInvoices, $root.lnrpc.ListInvoiceRequest, $root.lnrpc.ListInvoiceResponse, request, callback);
        }, "name", { value: "ListInvoices" });

        /**
         * lncli: `listinvoices`
         * ListInvoices returns a list of all the invoices currently stored within the
         * database. Any active debug invoices are ignored.
         * @function listInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListInvoiceRequest} request ListInvoiceRequest message or plain object
         * @returns {Promise<lnrpc.ListInvoiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#lookupInvoice}.
         * @memberof lnrpc.Lightning
         * @typedef LookupInvoiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Invoice} [response] Invoice
         */

        /**
         * lncli: `lookupinvoice`
         * LookupInvoice attempts to look up an invoice according to its payment hash.
         * The passed payment hash *must* be exactly 32 bytes, if not, an error is
         * returned.
         * @function lookupInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPaymentHash} request PaymentHash message or plain object
         * @param {lnrpc.Lightning.LookupInvoiceCallback} callback Node-style callback called with the error, if any, and Invoice
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.lookupInvoice = function lookupInvoice(request, callback) {
            return this.rpcCall(lookupInvoice, $root.lnrpc.PaymentHash, $root.lnrpc.Invoice, request, callback);
        }, "name", { value: "LookupInvoice" });

        /**
         * lncli: `lookupinvoice`
         * LookupInvoice attempts to look up an invoice according to its payment hash.
         * The passed payment hash *must* be exactly 32 bytes, if not, an error is
         * returned.
         * @function lookupInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPaymentHash} request PaymentHash message or plain object
         * @returns {Promise<lnrpc.Invoice>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeInvoices}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeInvoicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Invoice} [response] Invoice
         */

        /**
         * SubscribeInvoices returns a uni-directional stream (sever -> client) for
         * notifying the client of newly added/settled invoices. The caller can
         * optionally specify the add_index and/or the settle_index. If the add_index
         * is specified, then we'll first start by sending add invoice events for all
         * invoices with an add_index greater than the specified value.  If the
         * settle_index is specified, the next, we'll send out all settle events for
         * invoices with a settle_index greater than the specified value.  One or both
         * of these fields can be set. If no fields are set, then we'll only send out
         * the latest add/settle events.
         * @function subscribeInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoiceSubscription} request InvoiceSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeInvoicesCallback} callback Node-style callback called with the error, if any, and Invoice
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeInvoices = function subscribeInvoices(request, callback) {
            return this.rpcCall(subscribeInvoices, $root.lnrpc.InvoiceSubscription, $root.lnrpc.Invoice, request, callback);
        }, "name", { value: "SubscribeInvoices" });

        /**
         * SubscribeInvoices returns a uni-directional stream (sever -> client) for
         * notifying the client of newly added/settled invoices. The caller can
         * optionally specify the add_index and/or the settle_index. If the add_index
         * is specified, then we'll first start by sending add invoice events for all
         * invoices with an add_index greater than the specified value.  If the
         * settle_index is specified, the next, we'll send out all settle events for
         * invoices with a settle_index greater than the specified value.  One or both
         * of these fields can be set. If no fields are set, then we'll only send out
         * the latest add/settle events.
         * @function subscribeInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoiceSubscription} request InvoiceSubscription message or plain object
         * @returns {Promise<lnrpc.Invoice>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#decodePayReq}.
         * @memberof lnrpc.Lightning
         * @typedef DecodePayReqCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PayReq} [response] PayReq
         */

        /**
         * lncli: `decodepayreq`
         * DecodePayReq takes an encoded payment request string and attempts to decode
         * it, returning a full description of the conditions encoded within the
         * payment request.
         * @function decodePayReq
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPayReqString} request PayReqString message or plain object
         * @param {lnrpc.Lightning.DecodePayReqCallback} callback Node-style callback called with the error, if any, and PayReq
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.decodePayReq = function decodePayReq(request, callback) {
            return this.rpcCall(decodePayReq, $root.lnrpc.PayReqString, $root.lnrpc.PayReq, request, callback);
        }, "name", { value: "DecodePayReq" });

        /**
         * lncli: `decodepayreq`
         * DecodePayReq takes an encoded payment request string and attempts to decode
         * it, returning a full description of the conditions encoded within the
         * payment request.
         * @function decodePayReq
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPayReqString} request PayReqString message or plain object
         * @returns {Promise<lnrpc.PayReq>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPayments}.
         * @memberof lnrpc.Lightning
         * @typedef ListPaymentsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPaymentsResponse} [response] ListPaymentsResponse
         */

        /**
         * lncli: `listpayments`
         * ListPayments returns a list of all outgoing payments.
         * @function listPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPaymentsRequest} request ListPaymentsRequest message or plain object
         * @param {lnrpc.Lightning.ListPaymentsCallback} callback Node-style callback called with the error, if any, and ListPaymentsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPayments = function listPayments(request, callback) {
            return this.rpcCall(listPayments, $root.lnrpc.ListPaymentsRequest, $root.lnrpc.ListPaymentsResponse, request, callback);
        }, "name", { value: "ListPayments" });

        /**
         * lncli: `listpayments`
         * ListPayments returns a list of all outgoing payments.
         * @function listPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPaymentsRequest} request ListPaymentsRequest message or plain object
         * @returns {Promise<lnrpc.ListPaymentsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#deleteAllPayments}.
         * @memberof lnrpc.Lightning
         * @typedef DeleteAllPaymentsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DeleteAllPaymentsResponse} [response] DeleteAllPaymentsResponse
         */

        /**
         * DeleteAllPayments deletes all outgoing payments from DB.
         * @function deleteAllPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteAllPaymentsRequest} request DeleteAllPaymentsRequest message or plain object
         * @param {lnrpc.Lightning.DeleteAllPaymentsCallback} callback Node-style callback called with the error, if any, and DeleteAllPaymentsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.deleteAllPayments = function deleteAllPayments(request, callback) {
            return this.rpcCall(deleteAllPayments, $root.lnrpc.DeleteAllPaymentsRequest, $root.lnrpc.DeleteAllPaymentsResponse, request, callback);
        }, "name", { value: "DeleteAllPayments" });

        /**
         * DeleteAllPayments deletes all outgoing payments from DB.
         * @function deleteAllPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteAllPaymentsRequest} request DeleteAllPaymentsRequest message or plain object
         * @returns {Promise<lnrpc.DeleteAllPaymentsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#describeGraph}.
         * @memberof lnrpc.Lightning
         * @typedef DescribeGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelGraph} [response] ChannelGraph
         */

        /**
         * lncli: `describegraph`
         * DescribeGraph returns a description of the latest graph state from the
         * point of view of the node. The graph information is partitioned into two
         * components: all the nodes/vertexes, and all the edges that connect the
         * vertexes themselves.  As this is a directed graph, the edges also contain
         * the node directional specific routing policy which includes: the time lock
         * delta, fee information, etc.
         * @function describeGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelGraphRequest} request ChannelGraphRequest message or plain object
         * @param {lnrpc.Lightning.DescribeGraphCallback} callback Node-style callback called with the error, if any, and ChannelGraph
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.describeGraph = function describeGraph(request, callback) {
            return this.rpcCall(describeGraph, $root.lnrpc.ChannelGraphRequest, $root.lnrpc.ChannelGraph, request, callback);
        }, "name", { value: "DescribeGraph" });

        /**
         * lncli: `describegraph`
         * DescribeGraph returns a description of the latest graph state from the
         * point of view of the node. The graph information is partitioned into two
         * components: all the nodes/vertexes, and all the edges that connect the
         * vertexes themselves.  As this is a directed graph, the edges also contain
         * the node directional specific routing policy which includes: the time lock
         * delta, fee information, etc.
         * @function describeGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelGraphRequest} request ChannelGraphRequest message or plain object
         * @returns {Promise<lnrpc.ChannelGraph>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getChanInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetChanInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelEdge} [response] ChannelEdge
         */

        /**
         * lncli: `getchaninfo`
         * GetChanInfo returns the latest authenticated network announcement for the
         * given channel identified by its channel ID: an 8-byte integer which
         * uniquely identifies the location of transaction's funding output within the
         * blockchain.
         * @function getChanInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanInfoRequest} request ChanInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetChanInfoCallback} callback Node-style callback called with the error, if any, and ChannelEdge
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getChanInfo = function getChanInfo(request, callback) {
            return this.rpcCall(getChanInfo, $root.lnrpc.ChanInfoRequest, $root.lnrpc.ChannelEdge, request, callback);
        }, "name", { value: "GetChanInfo" });

        /**
         * lncli: `getchaninfo`
         * GetChanInfo returns the latest authenticated network announcement for the
         * given channel identified by its channel ID: an 8-byte integer which
         * uniquely identifies the location of transaction's funding output within the
         * blockchain.
         * @function getChanInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanInfoRequest} request ChanInfoRequest message or plain object
         * @returns {Promise<lnrpc.ChannelEdge>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNodeInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetNodeInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NodeInfo} [response] NodeInfo
         */

        /**
         * lncli: `getnodeinfo`
         * GetNodeInfo returns the latest advertised, aggregated, and authenticated
         * channel information for the specified node identified by its public key.
         * @function getNodeInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeInfoRequest} request NodeInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetNodeInfoCallback} callback Node-style callback called with the error, if any, and NodeInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNodeInfo = function getNodeInfo(request, callback) {
            return this.rpcCall(getNodeInfo, $root.lnrpc.NodeInfoRequest, $root.lnrpc.NodeInfo, request, callback);
        }, "name", { value: "GetNodeInfo" });

        /**
         * lncli: `getnodeinfo`
         * GetNodeInfo returns the latest advertised, aggregated, and authenticated
         * channel information for the specified node identified by its public key.
         * @function getNodeInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeInfoRequest} request NodeInfoRequest message or plain object
         * @returns {Promise<lnrpc.NodeInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#queryRoutes}.
         * @memberof lnrpc.Lightning
         * @typedef QueryRoutesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.QueryRoutesResponse} [response] QueryRoutesResponse
         */

        /**
         * lncli: `queryroutes`
         * QueryRoutes attempts to query the daemon's Channel Router for a possible
         * route to a target destination capable of carrying a specific amount of
         * satoshis. The retuned route contains the full details required to craft and
         * send an HTLC, also including the necessary information that should be
         * present within the Sphinx packet encapsulated within the HTLC.
         * @function queryRoutes
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IQueryRoutesRequest} request QueryRoutesRequest message or plain object
         * @param {lnrpc.Lightning.QueryRoutesCallback} callback Node-style callback called with the error, if any, and QueryRoutesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.queryRoutes = function queryRoutes(request, callback) {
            return this.rpcCall(queryRoutes, $root.lnrpc.QueryRoutesRequest, $root.lnrpc.QueryRoutesResponse, request, callback);
        }, "name", { value: "QueryRoutes" });

        /**
         * lncli: `queryroutes`
         * QueryRoutes attempts to query the daemon's Channel Router for a possible
         * route to a target destination capable of carrying a specific amount of
         * satoshis. The retuned route contains the full details required to craft and
         * send an HTLC, also including the necessary information that should be
         * present within the Sphinx packet encapsulated within the HTLC.
         * @function queryRoutes
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IQueryRoutesRequest} request QueryRoutesRequest message or plain object
         * @returns {Promise<lnrpc.QueryRoutesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNetworkInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetNetworkInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NetworkInfo} [response] NetworkInfo
         */

        /**
         * lncli: `getnetworkinfo`
         * GetNetworkInfo returns some basic stats about the known channel graph from
         * the point of view of the node.
         * @function getNetworkInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INetworkInfoRequest} request NetworkInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetNetworkInfoCallback} callback Node-style callback called with the error, if any, and NetworkInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNetworkInfo = function getNetworkInfo(request, callback) {
            return this.rpcCall(getNetworkInfo, $root.lnrpc.NetworkInfoRequest, $root.lnrpc.NetworkInfo, request, callback);
        }, "name", { value: "GetNetworkInfo" });

        /**
         * lncli: `getnetworkinfo`
         * GetNetworkInfo returns some basic stats about the known channel graph from
         * the point of view of the node.
         * @function getNetworkInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INetworkInfoRequest} request NetworkInfoRequest message or plain object
         * @returns {Promise<lnrpc.NetworkInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#stopDaemon}.
         * @memberof lnrpc.Lightning
         * @typedef StopDaemonCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.StopResponse} [response] StopResponse
         */

        /**
         * lncli: `stop`
         * StopDaemon will send a shutdown request to the interrupt handler, triggering
         * a graceful shutdown of the daemon.
         * @function stopDaemon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IStopRequest} request StopRequest message or plain object
         * @param {lnrpc.Lightning.StopDaemonCallback} callback Node-style callback called with the error, if any, and StopResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.stopDaemon = function stopDaemon(request, callback) {
            return this.rpcCall(stopDaemon, $root.lnrpc.StopRequest, $root.lnrpc.StopResponse, request, callback);
        }, "name", { value: "StopDaemon" });

        /**
         * lncli: `stop`
         * StopDaemon will send a shutdown request to the interrupt handler, triggering
         * a graceful shutdown of the daemon.
         * @function stopDaemon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IStopRequest} request StopRequest message or plain object
         * @returns {Promise<lnrpc.StopResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelGraph}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GraphTopologyUpdate} [response] GraphTopologyUpdate
         */

        /**
         * SubscribeChannelGraph launches a streaming RPC that allows the caller to
         * receive notifications upon any changes to the channel graph topology from
         * the point of view of the responding node. Events notified include: new
         * nodes coming online, nodes updating their authenticated attributes, new
         * channels being advertised, updates in the routing policy for a directional
         * channel edge, and when channels are closed on-chain.
         * @function subscribeChannelGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGraphTopologySubscription} request GraphTopologySubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelGraphCallback} callback Node-style callback called with the error, if any, and GraphTopologyUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelGraph = function subscribeChannelGraph(request, callback) {
            return this.rpcCall(subscribeChannelGraph, $root.lnrpc.GraphTopologySubscription, $root.lnrpc.GraphTopologyUpdate, request, callback);
        }, "name", { value: "SubscribeChannelGraph" });

        /**
         * SubscribeChannelGraph launches a streaming RPC that allows the caller to
         * receive notifications upon any changes to the channel graph topology from
         * the point of view of the responding node. Events notified include: new
         * nodes coming online, nodes updating their authenticated attributes, new
         * channels being advertised, updates in the routing policy for a directional
         * channel edge, and when channels are closed on-chain.
         * @function subscribeChannelGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGraphTopologySubscription} request GraphTopologySubscription message or plain object
         * @returns {Promise<lnrpc.GraphTopologyUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#debugLevel}.
         * @memberof lnrpc.Lightning
         * @typedef DebugLevelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DebugLevelResponse} [response] DebugLevelResponse
         */

        /**
         * lncli: `debuglevel`
         * DebugLevel allows a caller to programmatically set the logging verbosity of
         * lnd. The logging can be targeted according to a coarse daemon-wide logging
         * level, or in a granular fashion to specify the logging for a target
         * sub-system.
         * @function debugLevel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDebugLevelRequest} request DebugLevelRequest message or plain object
         * @param {lnrpc.Lightning.DebugLevelCallback} callback Node-style callback called with the error, if any, and DebugLevelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.debugLevel = function debugLevel(request, callback) {
            return this.rpcCall(debugLevel, $root.lnrpc.DebugLevelRequest, $root.lnrpc.DebugLevelResponse, request, callback);
        }, "name", { value: "DebugLevel" });

        /**
         * lncli: `debuglevel`
         * DebugLevel allows a caller to programmatically set the logging verbosity of
         * lnd. The logging can be targeted according to a coarse daemon-wide logging
         * level, or in a granular fashion to specify the logging for a target
         * sub-system.
         * @function debugLevel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDebugLevelRequest} request DebugLevelRequest message or plain object
         * @returns {Promise<lnrpc.DebugLevelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#feeReport}.
         * @memberof lnrpc.Lightning
         * @typedef FeeReportCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.FeeReportResponse} [response] FeeReportResponse
         */

        /**
         * lncli: `feereport`
         * FeeReport allows the caller to obtain a report detailing the current fee
         * schedule enforced by the node globally for each channel.
         * @function feeReport
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFeeReportRequest} request FeeReportRequest message or plain object
         * @param {lnrpc.Lightning.FeeReportCallback} callback Node-style callback called with the error, if any, and FeeReportResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.feeReport = function feeReport(request, callback) {
            return this.rpcCall(feeReport, $root.lnrpc.FeeReportRequest, $root.lnrpc.FeeReportResponse, request, callback);
        }, "name", { value: "FeeReport" });

        /**
         * lncli: `feereport`
         * FeeReport allows the caller to obtain a report detailing the current fee
         * schedule enforced by the node globally for each channel.
         * @function feeReport
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFeeReportRequest} request FeeReportRequest message or plain object
         * @returns {Promise<lnrpc.FeeReportResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#updateChannelPolicy}.
         * @memberof lnrpc.Lightning
         * @typedef UpdateChannelPolicyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PolicyUpdateResponse} [response] PolicyUpdateResponse
         */

        /**
         * lncli: `updatechanpolicy`
         * UpdateChannelPolicy allows the caller to update the fee schedule and
         * channel policies for all channels globally, or a particular channel.
         * @function updateChannelPolicy
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPolicyUpdateRequest} request PolicyUpdateRequest message or plain object
         * @param {lnrpc.Lightning.UpdateChannelPolicyCallback} callback Node-style callback called with the error, if any, and PolicyUpdateResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.updateChannelPolicy = function updateChannelPolicy(request, callback) {
            return this.rpcCall(updateChannelPolicy, $root.lnrpc.PolicyUpdateRequest, $root.lnrpc.PolicyUpdateResponse, request, callback);
        }, "name", { value: "UpdateChannelPolicy" });

        /**
         * lncli: `updatechanpolicy`
         * UpdateChannelPolicy allows the caller to update the fee schedule and
         * channel policies for all channels globally, or a particular channel.
         * @function updateChannelPolicy
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPolicyUpdateRequest} request PolicyUpdateRequest message or plain object
         * @returns {Promise<lnrpc.PolicyUpdateResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#forwardingHistory}.
         * @memberof lnrpc.Lightning
         * @typedef ForwardingHistoryCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ForwardingHistoryResponse} [response] ForwardingHistoryResponse
         */

        /**
         * lncli: `fwdinghistory`
         * ForwardingHistory allows the caller to query the htlcswitch for a record of
         * all HTLC's forwarded within the target time range, and integer offset
         * within that time range. If no time-range is specified, then the first chunk
         * of the past 24 hrs of forwarding history are returned.
         * 
         * A list of forwarding events are returned. The size of each forwarding event
         * is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
         * As a result each message can only contain 50k entries.  Each response has
         * the index offset of the last entry. The index offset can be provided to the
         * request to allow the caller to skip a series of records.
         * @function forwardingHistory
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IForwardingHistoryRequest} request ForwardingHistoryRequest message or plain object
         * @param {lnrpc.Lightning.ForwardingHistoryCallback} callback Node-style callback called with the error, if any, and ForwardingHistoryResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.forwardingHistory = function forwardingHistory(request, callback) {
            return this.rpcCall(forwardingHistory, $root.lnrpc.ForwardingHistoryRequest, $root.lnrpc.ForwardingHistoryResponse, request, callback);
        }, "name", { value: "ForwardingHistory" });

        /**
         * lncli: `fwdinghistory`
         * ForwardingHistory allows the caller to query the htlcswitch for a record of
         * all HTLC's forwarded within the target time range, and integer offset
         * within that time range. If no time-range is specified, then the first chunk
         * of the past 24 hrs of forwarding history are returned.
         * 
         * A list of forwarding events are returned. The size of each forwarding event
         * is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
         * As a result each message can only contain 50k entries.  Each response has
         * the index offset of the last entry. The index offset can be provided to the
         * request to allow the caller to skip a series of records.
         * @function forwardingHistory
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IForwardingHistoryRequest} request ForwardingHistoryRequest message or plain object
         * @returns {Promise<lnrpc.ForwardingHistoryResponse>} Promise
         * @variation 2
         */

        return Lightning;
    })();

    lnrpc.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof lnrpc
         * @interface ITransaction
         * @property {string|null} [txHash] The transaction hash
         * @property {number|Long|null} [amount] The transaction ammount, denominated in satoshis
         * @property {number|null} [numConfirmations] The number of confirmations
         * @property {string|null} [blockHash] The hash of the block this transaction was included in
         * @property {number|null} [blockHeight] The height of the block this transaction was included in
         * @property {number|Long|null} [timeStamp] Timestamp of this transaction
         * @property {number|Long|null} [totalFees] Fees paid for this transaction
         * @property {Array.<string>|null} [destAddresses] Addresses that received funds for this transaction
         */

        /**
         * Constructs a new Transaction.
         * @memberof lnrpc
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {lnrpc.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            this.destAddresses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The transaction hash
         * @member {string} txHash
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.txHash = "";

        /**
         * The transaction ammount, denominated in satoshis
         * @member {number|Long} amount
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The number of confirmations
         * @member {number} numConfirmations
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.numConfirmations = 0;

        /**
         * The hash of the block this transaction was included in
         * @member {string} blockHash
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.blockHash = "";

        /**
         * The height of the block this transaction was included in
         * @member {number} blockHeight
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.blockHeight = 0;

        /**
         * Timestamp of this transaction
         * @member {number|Long} timeStamp
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.timeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fees paid for this transaction
         * @member {number|Long} totalFees
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.totalFees = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Addresses that received funds for this transaction
         * @member {Array.<string>} destAddresses
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.destAddresses = $util.emptyArray;

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction=} [properties] Properties to set
         * @returns {lnrpc.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link lnrpc.Transaction.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txHash);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numConfirmations);
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.blockHash);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blockHeight);
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeStamp);
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.totalFees);
            if (message.destAddresses != null && message.destAddresses.length)
                for (var i = 0; i < message.destAddresses.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.destAddresses[i]);
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link lnrpc.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txHash = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.numConfirmations = reader.int32();
                    break;
                case 4:
                    message.blockHash = reader.string();
                    break;
                case 5:
                    message.blockHeight = reader.int32();
                    break;
                case 6:
                    message.timeStamp = reader.int64();
                    break;
                case 7:
                    message.totalFees = reader.int64();
                    break;
                case 8:
                    if (!(message.destAddresses && message.destAddresses.length))
                        message.destAddresses = [];
                    message.destAddresses.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof lnrpc.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                if (!$util.isString(message.txHash))
                    return "txHash: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                if (!$util.isInteger(message.numConfirmations))
                    return "numConfirmations: integer expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (!$util.isInteger(message.timeStamp) && !(message.timeStamp && $util.isInteger(message.timeStamp.low) && $util.isInteger(message.timeStamp.high)))
                    return "timeStamp: integer|Long expected";
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (!$util.isInteger(message.totalFees) && !(message.totalFees && $util.isInteger(message.totalFees.low) && $util.isInteger(message.totalFees.high)))
                    return "totalFees: integer|Long expected";
            if (message.destAddresses != null && message.hasOwnProperty("destAddresses")) {
                if (!Array.isArray(message.destAddresses))
                    return "destAddresses: array expected";
                for (var i = 0; i < message.destAddresses.length; ++i)
                    if (!$util.isString(message.destAddresses[i]))
                        return "destAddresses: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Transaction)
                return object;
            var message = new $root.lnrpc.Transaction();
            if (object.txHash != null)
                message.txHash = String(object.txHash);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.numConfirmations != null)
                message.numConfirmations = object.numConfirmations | 0;
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight | 0;
            if (object.timeStamp != null)
                if ($util.Long)
                    (message.timeStamp = $util.Long.fromValue(object.timeStamp)).unsigned = false;
                else if (typeof object.timeStamp === "string")
                    message.timeStamp = parseInt(object.timeStamp, 10);
                else if (typeof object.timeStamp === "number")
                    message.timeStamp = object.timeStamp;
                else if (typeof object.timeStamp === "object")
                    message.timeStamp = new $util.LongBits(object.timeStamp.low >>> 0, object.timeStamp.high >>> 0).toNumber();
            if (object.totalFees != null)
                if ($util.Long)
                    (message.totalFees = $util.Long.fromValue(object.totalFees)).unsigned = false;
                else if (typeof object.totalFees === "string")
                    message.totalFees = parseInt(object.totalFees, 10);
                else if (typeof object.totalFees === "number")
                    message.totalFees = object.totalFees;
                else if (typeof object.totalFees === "object")
                    message.totalFees = new $util.LongBits(object.totalFees.low >>> 0, object.totalFees.high >>> 0).toNumber();
            if (object.destAddresses) {
                if (!Array.isArray(object.destAddresses))
                    throw TypeError(".lnrpc.Transaction.destAddresses: array expected");
                message.destAddresses = [];
                for (var i = 0; i < object.destAddresses.length; ++i)
                    message.destAddresses[i] = String(object.destAddresses[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.destAddresses = [];
            if (options.defaults) {
                object.txHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.numConfirmations = 0;
                object.blockHash = "";
                object.blockHeight = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeStamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalFees = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFees = options.longs === String ? "0" : 0;
            }
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                object.txHash = message.txHash;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                object.numConfirmations = message.numConfirmations;
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (typeof message.timeStamp === "number")
                    object.timeStamp = options.longs === String ? String(message.timeStamp) : message.timeStamp;
                else
                    object.timeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.timeStamp) : options.longs === Number ? new $util.LongBits(message.timeStamp.low >>> 0, message.timeStamp.high >>> 0).toNumber() : message.timeStamp;
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (typeof message.totalFees === "number")
                    object.totalFees = options.longs === String ? String(message.totalFees) : message.totalFees;
                else
                    object.totalFees = options.longs === String ? $util.Long.prototype.toString.call(message.totalFees) : options.longs === Number ? new $util.LongBits(message.totalFees.low >>> 0, message.totalFees.high >>> 0).toNumber() : message.totalFees;
            if (message.destAddresses && message.destAddresses.length) {
                object.destAddresses = [];
                for (var j = 0; j < message.destAddresses.length; ++j)
                    object.destAddresses[j] = message.destAddresses[j];
            }
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof lnrpc.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transaction;
    })();

    lnrpc.GetTransactionsRequest = (function() {

        /**
         * Properties of a GetTransactionsRequest.
         * @memberof lnrpc
         * @interface IGetTransactionsRequest
         */

        /**
         * Constructs a new GetTransactionsRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetTransactionsRequest.
         * @implements IGetTransactionsRequest
         * @constructor
         * @param {lnrpc.IGetTransactionsRequest=} [properties] Properties to set
         */
        function GetTransactionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetTransactionsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest=} [properties] Properties to set
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest instance
         */
        GetTransactionsRequest.create = function create(properties) {
            return new GetTransactionsRequest(properties);
        };

        /**
         * Encodes the specified GetTransactionsRequest message. Does not implicitly {@link lnrpc.GetTransactionsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest} message GetTransactionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransactionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetTransactionsRequest message, length delimited. Does not implicitly {@link lnrpc.GetTransactionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest} message GetTransactionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransactionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTransactionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransactionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetTransactionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTransactionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransactionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTransactionsRequest message.
         * @function verify
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTransactionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetTransactionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         */
        GetTransactionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetTransactionsRequest)
                return object;
            return new $root.lnrpc.GetTransactionsRequest();
        };

        /**
         * Creates a plain object from a GetTransactionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.GetTransactionsRequest} message GetTransactionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTransactionsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetTransactionsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetTransactionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTransactionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTransactionsRequest;
    })();

    lnrpc.TransactionDetails = (function() {

        /**
         * Properties of a TransactionDetails.
         * @memberof lnrpc
         * @interface ITransactionDetails
         * @property {Array.<lnrpc.ITransaction>|null} [transactions] The list of transactions relevant to the wallet.
         */

        /**
         * Constructs a new TransactionDetails.
         * @memberof lnrpc
         * @classdesc Represents a TransactionDetails.
         * @implements ITransactionDetails
         * @constructor
         * @param {lnrpc.ITransactionDetails=} [properties] Properties to set
         */
        function TransactionDetails(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of transactions relevant to the wallet.
         * @member {Array.<lnrpc.ITransaction>} transactions
         * @memberof lnrpc.TransactionDetails
         * @instance
         */
        TransactionDetails.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new TransactionDetails instance using the specified properties.
         * @function create
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails=} [properties] Properties to set
         * @returns {lnrpc.TransactionDetails} TransactionDetails instance
         */
        TransactionDetails.create = function create(properties) {
            return new TransactionDetails(properties);
        };

        /**
         * Encodes the specified TransactionDetails message. Does not implicitly {@link lnrpc.TransactionDetails.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails} message TransactionDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.lnrpc.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionDetails message, length delimited. Does not implicitly {@link lnrpc.TransactionDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails} message TransactionDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionDetails message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.TransactionDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.lnrpc.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionDetails message.
         * @function verify
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.lnrpc.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         */
        TransactionDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.TransactionDetails)
                return object;
            var message = new $root.lnrpc.TransactionDetails();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".lnrpc.TransactionDetails.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".lnrpc.TransactionDetails.transactions: object expected");
                    message.transactions[i] = $root.lnrpc.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.TransactionDetails} message TransactionDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.lnrpc.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this TransactionDetails to JSON.
         * @function toJSON
         * @memberof lnrpc.TransactionDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionDetails;
    })();

    lnrpc.FeeLimit = (function() {

        /**
         * Properties of a FeeLimit.
         * @memberof lnrpc
         * @interface IFeeLimit
         * @property {number|Long|null} [fixed] The fee limit expressed as a fixed amount of satoshis.
         * @property {number|Long|null} [percent] The fee limit expressed as a percentage of the payment amount.
         */

        /**
         * Constructs a new FeeLimit.
         * @memberof lnrpc
         * @classdesc Represents a FeeLimit.
         * @implements IFeeLimit
         * @constructor
         * @param {lnrpc.IFeeLimit=} [properties] Properties to set
         */
        function FeeLimit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The fee limit expressed as a fixed amount of satoshis.
         * @member {number|Long} fixed
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.fixed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The fee limit expressed as a percentage of the payment amount.
         * @member {number|Long} percent
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.percent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * FeeLimit limit.
         * @member {"fixed"|"percent"|undefined} limit
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        Object.defineProperty(FeeLimit.prototype, "limit", {
            get: $util.oneOfGetter($oneOfFields = ["fixed", "percent"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FeeLimit instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit=} [properties] Properties to set
         * @returns {lnrpc.FeeLimit} FeeLimit instance
         */
        FeeLimit.create = function create(properties) {
            return new FeeLimit(properties);
        };

        /**
         * Encodes the specified FeeLimit message. Does not implicitly {@link lnrpc.FeeLimit.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit} message FeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeLimit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fixed != null && message.hasOwnProperty("fixed"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fixed);
            if (message.percent != null && message.hasOwnProperty("percent"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.percent);
            return writer;
        };

        /**
         * Encodes the specified FeeLimit message, length delimited. Does not implicitly {@link lnrpc.FeeLimit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit} message FeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeLimit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeLimit message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeLimit} FeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeLimit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeLimit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fixed = reader.int64();
                    break;
                case 2:
                    message.percent = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeLimit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeLimit} FeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeLimit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeLimit message.
         * @function verify
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeLimit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.fixed != null && message.hasOwnProperty("fixed")) {
                properties.limit = 1;
                if (!$util.isInteger(message.fixed) && !(message.fixed && $util.isInteger(message.fixed.low) && $util.isInteger(message.fixed.high)))
                    return "fixed: integer|Long expected";
            }
            if (message.percent != null && message.hasOwnProperty("percent")) {
                if (properties.limit === 1)
                    return "limit: multiple values";
                properties.limit = 1;
                if (!$util.isInteger(message.percent) && !(message.percent && $util.isInteger(message.percent.low) && $util.isInteger(message.percent.high)))
                    return "percent: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a FeeLimit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeLimit} FeeLimit
         */
        FeeLimit.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeLimit)
                return object;
            var message = new $root.lnrpc.FeeLimit();
            if (object.fixed != null)
                if ($util.Long)
                    (message.fixed = $util.Long.fromValue(object.fixed)).unsigned = false;
                else if (typeof object.fixed === "string")
                    message.fixed = parseInt(object.fixed, 10);
                else if (typeof object.fixed === "number")
                    message.fixed = object.fixed;
                else if (typeof object.fixed === "object")
                    message.fixed = new $util.LongBits(object.fixed.low >>> 0, object.fixed.high >>> 0).toNumber();
            if (object.percent != null)
                if ($util.Long)
                    (message.percent = $util.Long.fromValue(object.percent)).unsigned = false;
                else if (typeof object.percent === "string")
                    message.percent = parseInt(object.percent, 10);
                else if (typeof object.percent === "number")
                    message.percent = object.percent;
                else if (typeof object.percent === "object")
                    message.percent = new $util.LongBits(object.percent.low >>> 0, object.percent.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FeeLimit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.FeeLimit} message FeeLimit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeLimit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.fixed != null && message.hasOwnProperty("fixed")) {
                if (typeof message.fixed === "number")
                    object.fixed = options.longs === String ? String(message.fixed) : message.fixed;
                else
                    object.fixed = options.longs === String ? $util.Long.prototype.toString.call(message.fixed) : options.longs === Number ? new $util.LongBits(message.fixed.low >>> 0, message.fixed.high >>> 0).toNumber() : message.fixed;
                if (options.oneofs)
                    object.limit = "fixed";
            }
            if (message.percent != null && message.hasOwnProperty("percent")) {
                if (typeof message.percent === "number")
                    object.percent = options.longs === String ? String(message.percent) : message.percent;
                else
                    object.percent = options.longs === String ? $util.Long.prototype.toString.call(message.percent) : options.longs === Number ? new $util.LongBits(message.percent.low >>> 0, message.percent.high >>> 0).toNumber() : message.percent;
                if (options.oneofs)
                    object.limit = "percent";
            }
            return object;
        };

        /**
         * Converts this FeeLimit to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeLimit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeLimit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeLimit;
    })();

    lnrpc.SendRequest = (function() {

        /**
         * Properties of a SendRequest.
         * @memberof lnrpc
         * @interface ISendRequest
         * @property {Uint8Array|null} [dest] The identity pubkey of the payment recipient
         * @property {string|null} [destString] The hex-encoded identity pubkey of the payment recipient
         * @property {number|Long|null} [amt] Number of satoshis to send.
         * @property {Uint8Array|null} [paymentHash] The hash to use within the payment's HTLC
         * @property {string|null} [paymentHashString] The hex-encoded hash to use within the payment's HTLC
         * @property {string|null} [paymentRequest] A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @property {number|null} [finalCltvDelta] The CLTV delta from the current height that should be used to set the
         * timelock for the final hop.
         * @property {lnrpc.IFeeLimit|null} [feeLimit] The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         */

        /**
         * Constructs a new SendRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendRequest.
         * @implements ISendRequest
         * @constructor
         * @param {lnrpc.ISendRequest=} [properties] Properties to set
         */
        function SendRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the payment recipient
         * @member {Uint8Array} dest
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.dest = $util.newBuffer([]);

        /**
         * The hex-encoded identity pubkey of the payment recipient
         * @member {string} destString
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.destString = "";

        /**
         * Number of satoshis to send.
         * @member {number|Long} amt
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The hash to use within the payment's HTLC
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentHash = $util.newBuffer([]);

        /**
         * The hex-encoded hash to use within the payment's HTLC
         * @member {string} paymentHashString
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentHashString = "";

        /**
         * A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @member {string} paymentRequest
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentRequest = "";

        /**
         * The CLTV delta from the current height that should be used to set the
         * timelock for the final hop.
         * @member {number} finalCltvDelta
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.finalCltvDelta = 0;

        /**
         * The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         * @member {lnrpc.IFeeLimit|null|undefined} feeLimit
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.feeLimit = null;

        /**
         * Creates a new SendRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest=} [properties] Properties to set
         * @returns {lnrpc.SendRequest} SendRequest instance
         */
        SendRequest.create = function create(properties) {
            return new SendRequest(properties);
        };

        /**
         * Encodes the specified SendRequest message. Does not implicitly {@link lnrpc.SendRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest} message SendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && message.hasOwnProperty("dest"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.dest);
            if (message.destString != null && message.hasOwnProperty("destString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.destString);
            if (message.amt != null && message.hasOwnProperty("amt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amt);
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.paymentHash);
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.paymentHashString);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.paymentRequest);
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.finalCltvDelta);
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                $root.lnrpc.FeeLimit.encode(message.feeLimit, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendRequest message, length delimited. Does not implicitly {@link lnrpc.SendRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest} message SendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendRequest} SendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = reader.bytes();
                    break;
                case 2:
                    message.destString = reader.string();
                    break;
                case 3:
                    message.amt = reader.int64();
                    break;
                case 4:
                    message.paymentHash = reader.bytes();
                    break;
                case 5:
                    message.paymentHashString = reader.string();
                    break;
                case 6:
                    message.paymentRequest = reader.string();
                    break;
                case 7:
                    message.finalCltvDelta = reader.int32();
                    break;
                case 8:
                    message.feeLimit = $root.lnrpc.FeeLimit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendRequest} SendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendRequest message.
         * @function verify
         * @memberof lnrpc.SendRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!(message.dest && typeof message.dest.length === "number" || $util.isString(message.dest)))
                    return "dest: buffer expected";
            if (message.destString != null && message.hasOwnProperty("destString"))
                if (!$util.isString(message.destString))
                    return "destString: string expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                if (!$util.isString(message.paymentHashString))
                    return "paymentHashString: string expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                if (!$util.isInteger(message.finalCltvDelta))
                    return "finalCltvDelta: integer expected";
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit")) {
                var error = $root.lnrpc.FeeLimit.verify(message.feeLimit);
                if (error)
                    return "feeLimit." + error;
            }
            return null;
        };

        /**
         * Creates a SendRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendRequest} SendRequest
         */
        SendRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendRequest)
                return object;
            var message = new $root.lnrpc.SendRequest();
            if (object.dest != null)
                if (typeof object.dest === "string")
                    $util.base64.decode(object.dest, message.dest = $util.newBuffer($util.base64.length(object.dest)), 0);
                else if (object.dest.length)
                    message.dest = object.dest;
            if (object.destString != null)
                message.destString = String(object.destString);
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            if (object.paymentHashString != null)
                message.paymentHashString = String(object.paymentHashString);
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.finalCltvDelta != null)
                message.finalCltvDelta = object.finalCltvDelta | 0;
            if (object.feeLimit != null) {
                if (typeof object.feeLimit !== "object")
                    throw TypeError(".lnrpc.SendRequest.feeLimit: object expected");
                message.feeLimit = $root.lnrpc.FeeLimit.fromObject(object.feeLimit);
            }
            return message;
        };

        /**
         * Creates a plain object from a SendRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.SendRequest} message SendRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.dest = "";
                else {
                    object.dest = [];
                    if (options.bytes !== Array)
                        object.dest = $util.newBuffer(object.dest);
                }
                object.destString = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
                object.paymentHashString = "";
                object.paymentRequest = "";
                object.finalCltvDelta = 0;
                object.feeLimit = null;
            }
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = options.bytes === String ? $util.base64.encode(message.dest, 0, message.dest.length) : options.bytes === Array ? Array.prototype.slice.call(message.dest) : message.dest;
            if (message.destString != null && message.hasOwnProperty("destString"))
                object.destString = message.destString;
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                object.paymentHashString = message.paymentHashString;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                object.finalCltvDelta = message.finalCltvDelta;
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                object.feeLimit = $root.lnrpc.FeeLimit.toObject(message.feeLimit, options);
            return object;
        };

        /**
         * Converts this SendRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendRequest;
    })();

    lnrpc.SendResponse = (function() {

        /**
         * Properties of a SendResponse.
         * @memberof lnrpc
         * @interface ISendResponse
         * @property {string|null} [paymentError] SendResponse paymentError
         * @property {Uint8Array|null} [paymentPreimage] SendResponse paymentPreimage
         * @property {lnrpc.IRoute|null} [paymentRoute] SendResponse paymentRoute
         */

        /**
         * Constructs a new SendResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendResponse.
         * @implements ISendResponse
         * @constructor
         * @param {lnrpc.ISendResponse=} [properties] Properties to set
         */
        function SendResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendResponse paymentError.
         * @member {string} paymentError
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentError = "";

        /**
         * SendResponse paymentPreimage.
         * @member {Uint8Array} paymentPreimage
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentPreimage = $util.newBuffer([]);

        /**
         * SendResponse paymentRoute.
         * @member {lnrpc.IRoute|null|undefined} paymentRoute
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentRoute = null;

        /**
         * Creates a new SendResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse=} [properties] Properties to set
         * @returns {lnrpc.SendResponse} SendResponse instance
         */
        SendResponse.create = function create(properties) {
            return new SendResponse(properties);
        };

        /**
         * Encodes the specified SendResponse message. Does not implicitly {@link lnrpc.SendResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse} message SendResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.paymentError);
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.paymentPreimage);
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute"))
                $root.lnrpc.Route.encode(message.paymentRoute, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendResponse message, length delimited. Does not implicitly {@link lnrpc.SendResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse} message SendResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendResponse} SendResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentError = reader.string();
                    break;
                case 2:
                    message.paymentPreimage = reader.bytes();
                    break;
                case 3:
                    message.paymentRoute = $root.lnrpc.Route.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendResponse} SendResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendResponse message.
         * @function verify
         * @memberof lnrpc.SendResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                if (!$util.isString(message.paymentError))
                    return "paymentError: string expected";
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                if (!(message.paymentPreimage && typeof message.paymentPreimage.length === "number" || $util.isString(message.paymentPreimage)))
                    return "paymentPreimage: buffer expected";
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute")) {
                var error = $root.lnrpc.Route.verify(message.paymentRoute);
                if (error)
                    return "paymentRoute." + error;
            }
            return null;
        };

        /**
         * Creates a SendResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendResponse} SendResponse
         */
        SendResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendResponse)
                return object;
            var message = new $root.lnrpc.SendResponse();
            if (object.paymentError != null)
                message.paymentError = String(object.paymentError);
            if (object.paymentPreimage != null)
                if (typeof object.paymentPreimage === "string")
                    $util.base64.decode(object.paymentPreimage, message.paymentPreimage = $util.newBuffer($util.base64.length(object.paymentPreimage)), 0);
                else if (object.paymentPreimage.length)
                    message.paymentPreimage = object.paymentPreimage;
            if (object.paymentRoute != null) {
                if (typeof object.paymentRoute !== "object")
                    throw TypeError(".lnrpc.SendResponse.paymentRoute: object expected");
                message.paymentRoute = $root.lnrpc.Route.fromObject(object.paymentRoute);
            }
            return message;
        };

        /**
         * Creates a plain object from a SendResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.SendResponse} message SendResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.paymentError = "";
                if (options.bytes === String)
                    object.paymentPreimage = "";
                else {
                    object.paymentPreimage = [];
                    if (options.bytes !== Array)
                        object.paymentPreimage = $util.newBuffer(object.paymentPreimage);
                }
                object.paymentRoute = null;
            }
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                object.paymentError = message.paymentError;
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                object.paymentPreimage = options.bytes === String ? $util.base64.encode(message.paymentPreimage, 0, message.paymentPreimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentPreimage) : message.paymentPreimage;
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute"))
                object.paymentRoute = $root.lnrpc.Route.toObject(message.paymentRoute, options);
            return object;
        };

        /**
         * Converts this SendResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendResponse;
    })();

    lnrpc.SendToRouteRequest = (function() {

        /**
         * Properties of a SendToRouteRequest.
         * @memberof lnrpc
         * @interface ISendToRouteRequest
         * @property {Uint8Array|null} [paymentHash] The payment hash to use for the HTLC.
         * @property {string|null} [paymentHashString] An optional hex-encoded payment hash to be used for the HTLC.
         * @property {Array.<lnrpc.IRoute>|null} [routes] The set of routes that should be used to attempt to complete the payment.
         */

        /**
         * Constructs a new SendToRouteRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendToRouteRequest.
         * @implements ISendToRouteRequest
         * @constructor
         * @param {lnrpc.ISendToRouteRequest=} [properties] Properties to set
         */
        function SendToRouteRequest(properties) {
            this.routes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The payment hash to use for the HTLC.
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.paymentHash = $util.newBuffer([]);

        /**
         * An optional hex-encoded payment hash to be used for the HTLC.
         * @member {string} paymentHashString
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.paymentHashString = "";

        /**
         * The set of routes that should be used to attempt to complete the payment.
         * @member {Array.<lnrpc.IRoute>} routes
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.routes = $util.emptyArray;

        /**
         * Creates a new SendToRouteRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest=} [properties] Properties to set
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest instance
         */
        SendToRouteRequest.create = function create(properties) {
            return new SendToRouteRequest(properties);
        };

        /**
         * Encodes the specified SendToRouteRequest message. Does not implicitly {@link lnrpc.SendToRouteRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest} message SendToRouteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendToRouteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.paymentHash);
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentHashString);
            if (message.routes != null && message.routes.length)
                for (var i = 0; i < message.routes.length; ++i)
                    $root.lnrpc.Route.encode(message.routes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendToRouteRequest message, length delimited. Does not implicitly {@link lnrpc.SendToRouteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest} message SendToRouteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendToRouteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendToRouteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendToRouteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendToRouteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentHash = reader.bytes();
                    break;
                case 2:
                    message.paymentHashString = reader.string();
                    break;
                case 3:
                    if (!(message.routes && message.routes.length))
                        message.routes = [];
                    message.routes.push($root.lnrpc.Route.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendToRouteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendToRouteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendToRouteRequest message.
         * @function verify
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendToRouteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                if (!$util.isString(message.paymentHashString))
                    return "paymentHashString: string expected";
            if (message.routes != null && message.hasOwnProperty("routes")) {
                if (!Array.isArray(message.routes))
                    return "routes: array expected";
                for (var i = 0; i < message.routes.length; ++i) {
                    var error = $root.lnrpc.Route.verify(message.routes[i]);
                    if (error)
                        return "routes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SendToRouteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         */
        SendToRouteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendToRouteRequest)
                return object;
            var message = new $root.lnrpc.SendToRouteRequest();
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            if (object.paymentHashString != null)
                message.paymentHashString = String(object.paymentHashString);
            if (object.routes) {
                if (!Array.isArray(object.routes))
                    throw TypeError(".lnrpc.SendToRouteRequest.routes: array expected");
                message.routes = [];
                for (var i = 0; i < object.routes.length; ++i) {
                    if (typeof object.routes[i] !== "object")
                        throw TypeError(".lnrpc.SendToRouteRequest.routes: object expected");
                    message.routes[i] = $root.lnrpc.Route.fromObject(object.routes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SendToRouteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.SendToRouteRequest} message SendToRouteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendToRouteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.routes = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
                object.paymentHashString = "";
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                object.paymentHashString = message.paymentHashString;
            if (message.routes && message.routes.length) {
                object.routes = [];
                for (var j = 0; j < message.routes.length; ++j)
                    object.routes[j] = $root.lnrpc.Route.toObject(message.routes[j], options);
            }
            return object;
        };

        /**
         * Converts this SendToRouteRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendToRouteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendToRouteRequest;
    })();

    lnrpc.ChannelPoint = (function() {

        /**
         * Properties of a ChannelPoint.
         * @memberof lnrpc
         * @interface IChannelPoint
         * @property {Uint8Array|null} [fundingTxidBytes] Txid of the funding transaction
         * @property {string|null} [fundingTxidStr] Hex-encoded string representing the funding transaction
         * @property {number|null} [outputIndex] The index of the output of the funding transaction
         */

        /**
         * Constructs a new ChannelPoint.
         * @memberof lnrpc
         * @classdesc Represents a ChannelPoint.
         * @implements IChannelPoint
         * @constructor
         * @param {lnrpc.IChannelPoint=} [properties] Properties to set
         */
        function ChannelPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Txid of the funding transaction
         * @member {Uint8Array} fundingTxidBytes
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.fundingTxidBytes = $util.newBuffer([]);

        /**
         * Hex-encoded string representing the funding transaction
         * @member {string} fundingTxidStr
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.fundingTxidStr = "";

        /**
         * The index of the output of the funding transaction
         * @member {number} outputIndex
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.outputIndex = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ChannelPoint fundingTxid.
         * @member {"fundingTxidBytes"|"fundingTxidStr"|undefined} fundingTxid
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        Object.defineProperty(ChannelPoint.prototype, "fundingTxid", {
            get: $util.oneOfGetter($oneOfFields = ["fundingTxidBytes", "fundingTxidStr"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ChannelPoint instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint=} [properties] Properties to set
         * @returns {lnrpc.ChannelPoint} ChannelPoint instance
         */
        ChannelPoint.create = function create(properties) {
            return new ChannelPoint(properties);
        };

        /**
         * Encodes the specified ChannelPoint message. Does not implicitly {@link lnrpc.ChannelPoint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint} message ChannelPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fundingTxidBytes);
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fundingTxidStr);
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified ChannelPoint message, length delimited. Does not implicitly {@link lnrpc.ChannelPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint} message ChannelPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPoint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fundingTxidBytes = reader.bytes();
                    break;
                case 2:
                    message.fundingTxidStr = reader.string();
                    break;
                case 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPoint message.
         * @function verify
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes")) {
                properties.fundingTxid = 1;
                if (!(message.fundingTxidBytes && typeof message.fundingTxidBytes.length === "number" || $util.isString(message.fundingTxidBytes)))
                    return "fundingTxidBytes: buffer expected";
            }
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr")) {
                if (properties.fundingTxid === 1)
                    return "fundingTxid: multiple values";
                properties.fundingTxid = 1;
                if (!$util.isString(message.fundingTxidStr))
                    return "fundingTxidStr: string expected";
            }
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates a ChannelPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         */
        ChannelPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelPoint)
                return object;
            var message = new $root.lnrpc.ChannelPoint();
            if (object.fundingTxidBytes != null)
                if (typeof object.fundingTxidBytes === "string")
                    $util.base64.decode(object.fundingTxidBytes, message.fundingTxidBytes = $util.newBuffer($util.base64.length(object.fundingTxidBytes)), 0);
                else if (object.fundingTxidBytes.length)
                    message.fundingTxidBytes = object.fundingTxidBytes;
            if (object.fundingTxidStr != null)
                message.fundingTxidStr = String(object.fundingTxidStr);
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChannelPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.ChannelPoint} message ChannelPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.outputIndex = 0;
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes")) {
                object.fundingTxidBytes = options.bytes === String ? $util.base64.encode(message.fundingTxidBytes, 0, message.fundingTxidBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.fundingTxidBytes) : message.fundingTxidBytes;
                if (options.oneofs)
                    object.fundingTxid = "fundingTxidBytes";
            }
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr")) {
                object.fundingTxidStr = message.fundingTxidStr;
                if (options.oneofs)
                    object.fundingTxid = "fundingTxidStr";
            }
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this ChannelPoint to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPoint;
    })();

    lnrpc.LightningAddress = (function() {

        /**
         * Properties of a LightningAddress.
         * @memberof lnrpc
         * @interface ILightningAddress
         * @property {string|null} [pubkey] The identity pubkey of the Lightning node
         * @property {string|null} [host] The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
         */

        /**
         * Constructs a new LightningAddress.
         * @memberof lnrpc
         * @classdesc Represents a LightningAddress.
         * @implements ILightningAddress
         * @constructor
         * @param {lnrpc.ILightningAddress=} [properties] Properties to set
         */
        function LightningAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the Lightning node
         * @member {string} pubkey
         * @memberof lnrpc.LightningAddress
         * @instance
         */
        LightningAddress.prototype.pubkey = "";

        /**
         * The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
         * @member {string} host
         * @memberof lnrpc.LightningAddress
         * @instance
         */
        LightningAddress.prototype.host = "";

        /**
         * Creates a new LightningAddress instance using the specified properties.
         * @function create
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress=} [properties] Properties to set
         * @returns {lnrpc.LightningAddress} LightningAddress instance
         */
        LightningAddress.create = function create(properties) {
            return new LightningAddress(properties);
        };

        /**
         * Encodes the specified LightningAddress message. Does not implicitly {@link lnrpc.LightningAddress.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress} message LightningAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkey);
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            return writer;
        };

        /**
         * Encodes the specified LightningAddress message, length delimited. Does not implicitly {@link lnrpc.LightningAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress} message LightningAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightningAddress message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.LightningAddress} LightningAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.LightningAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubkey = reader.string();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightningAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.LightningAddress} LightningAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightningAddress message.
         * @function verify
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightningAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!$util.isString(message.pubkey))
                    return "pubkey: string expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            return null;
        };

        /**
         * Creates a LightningAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.LightningAddress} LightningAddress
         */
        LightningAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.LightningAddress)
                return object;
            var message = new $root.lnrpc.LightningAddress();
            if (object.pubkey != null)
                message.pubkey = String(object.pubkey);
            if (object.host != null)
                message.host = String(object.host);
            return message;
        };

        /**
         * Creates a plain object from a LightningAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.LightningAddress} message LightningAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightningAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pubkey = "";
                object.host = "";
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = message.pubkey;
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            return object;
        };

        /**
         * Converts this LightningAddress to JSON.
         * @function toJSON
         * @memberof lnrpc.LightningAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightningAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightningAddress;
    })();

    lnrpc.SendManyRequest = (function() {

        /**
         * Properties of a SendManyRequest.
         * @memberof lnrpc
         * @interface ISendManyRequest
         * @property {Object.<string,number|Long>|null} [AddrToAmount] The map from addresses to amounts
         * @property {number|null} [targetConf] The target number of blocks that this transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the transaction.
         */

        /**
         * Constructs a new SendManyRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendManyRequest.
         * @implements ISendManyRequest
         * @constructor
         * @param {lnrpc.ISendManyRequest=} [properties] Properties to set
         */
        function SendManyRequest(properties) {
            this.AddrToAmount = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The map from addresses to amounts
         * @member {Object.<string,number|Long>} AddrToAmount
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.AddrToAmount = $util.emptyObject;

        /**
         * The target number of blocks that this transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SendManyRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest=} [properties] Properties to set
         * @returns {lnrpc.SendManyRequest} SendManyRequest instance
         */
        SendManyRequest.create = function create(properties) {
            return new SendManyRequest(properties);
        };

        /**
         * Encodes the specified SendManyRequest message. Does not implicitly {@link lnrpc.SendManyRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest} message SendManyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount"))
                for (var keys = Object.keys(message.AddrToAmount), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.AddrToAmount[keys[i]]).ldelim();
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.satPerByte);
            return writer;
        };

        /**
         * Encodes the specified SendManyRequest message, length delimited. Does not implicitly {@link lnrpc.SendManyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest} message SendManyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendManyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendManyRequest(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.AddrToAmount === $util.emptyObject)
                        message.AddrToAmount = {};
                    key = reader.string();
                    reader.pos++;
                    message.AddrToAmount[key] = reader.int64();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 5:
                    message.satPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendManyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendManyRequest message.
         * @function verify
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendManyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount")) {
                if (!$util.isObject(message.AddrToAmount))
                    return "AddrToAmount: object expected";
                var key = Object.keys(message.AddrToAmount);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.AddrToAmount[key[i]]) && !(message.AddrToAmount[key[i]] && $util.isInteger(message.AddrToAmount[key[i]].low) && $util.isInteger(message.AddrToAmount[key[i]].high)))
                        return "AddrToAmount: integer|Long{k:string} expected";
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates a SendManyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         */
        SendManyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendManyRequest)
                return object;
            var message = new $root.lnrpc.SendManyRequest();
            if (object.AddrToAmount) {
                if (typeof object.AddrToAmount !== "object")
                    throw TypeError(".lnrpc.SendManyRequest.AddrToAmount: object expected");
                message.AddrToAmount = {};
                for (var keys = Object.keys(object.AddrToAmount), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.AddrToAmount[keys[i]] = $util.Long.fromValue(object.AddrToAmount[keys[i]])).unsigned = false;
                    else if (typeof object.AddrToAmount[keys[i]] === "string")
                        message.AddrToAmount[keys[i]] = parseInt(object.AddrToAmount[keys[i]], 10);
                    else if (typeof object.AddrToAmount[keys[i]] === "number")
                        message.AddrToAmount[keys[i]] = object.AddrToAmount[keys[i]];
                    else if (typeof object.AddrToAmount[keys[i]] === "object")
                        message.AddrToAmount[keys[i]] = new $util.LongBits(object.AddrToAmount[keys[i]].low >>> 0, object.AddrToAmount[keys[i]].high >>> 0).toNumber();
            }
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SendManyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.SendManyRequest} message SendManyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendManyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.AddrToAmount = {};
            if (options.defaults) {
                object.targetConf = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
            }
            var keys2;
            if (message.AddrToAmount && (keys2 = Object.keys(message.AddrToAmount)).length) {
                object.AddrToAmount = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.AddrToAmount[keys2[j]] === "number")
                        object.AddrToAmount[keys2[j]] = options.longs === String ? String(message.AddrToAmount[keys2[j]]) : message.AddrToAmount[keys2[j]];
                    else
                        object.AddrToAmount[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.AddrToAmount[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.AddrToAmount[keys2[j]].low >>> 0, message.AddrToAmount[keys2[j]].high >>> 0).toNumber() : message.AddrToAmount[keys2[j]];
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            return object;
        };

        /**
         * Converts this SendManyRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendManyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendManyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendManyRequest;
    })();

    lnrpc.SendManyResponse = (function() {

        /**
         * Properties of a SendManyResponse.
         * @memberof lnrpc
         * @interface ISendManyResponse
         * @property {string|null} [txid] The id of the transaction
         */

        /**
         * Constructs a new SendManyResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendManyResponse.
         * @implements ISendManyResponse
         * @constructor
         * @param {lnrpc.ISendManyResponse=} [properties] Properties to set
         */
        function SendManyResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The id of the transaction
         * @member {string} txid
         * @memberof lnrpc.SendManyResponse
         * @instance
         */
        SendManyResponse.prototype.txid = "";

        /**
         * Creates a new SendManyResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse=} [properties] Properties to set
         * @returns {lnrpc.SendManyResponse} SendManyResponse instance
         */
        SendManyResponse.create = function create(properties) {
            return new SendManyResponse(properties);
        };

        /**
         * Encodes the specified SendManyResponse message. Does not implicitly {@link lnrpc.SendManyResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse} message SendManyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            return writer;
        };

        /**
         * Encodes the specified SendManyResponse message, length delimited. Does not implicitly {@link lnrpc.SendManyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse} message SendManyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendManyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendManyResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendManyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendManyResponse message.
         * @function verify
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendManyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            return null;
        };

        /**
         * Creates a SendManyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         */
        SendManyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendManyResponse)
                return object;
            var message = new $root.lnrpc.SendManyResponse();
            if (object.txid != null)
                message.txid = String(object.txid);
            return message;
        };

        /**
         * Creates a plain object from a SendManyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.SendManyResponse} message SendManyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendManyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.txid = "";
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            return object;
        };

        /**
         * Converts this SendManyResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendManyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendManyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendManyResponse;
    })();

    lnrpc.SendCoinsRequest = (function() {

        /**
         * Properties of a SendCoinsRequest.
         * @memberof lnrpc
         * @interface ISendCoinsRequest
         * @property {string|null} [addr] The address to send coins to
         * @property {number|Long|null} [amount] The amount in satoshis to send
         * @property {number|null} [targetConf] The target number of blocks that this transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the transaction.
         */

        /**
         * Constructs a new SendCoinsRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendCoinsRequest.
         * @implements ISendCoinsRequest
         * @constructor
         * @param {lnrpc.ISendCoinsRequest=} [properties] Properties to set
         */
        function SendCoinsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The address to send coins to
         * @member {string} addr
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.addr = "";

        /**
         * The amount in satoshis to send
         * @member {number|Long} amount
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The target number of blocks that this transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SendCoinsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest=} [properties] Properties to set
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest instance
         */
        SendCoinsRequest.create = function create(properties) {
            return new SendCoinsRequest(properties);
        };

        /**
         * Encodes the specified SendCoinsRequest message. Does not implicitly {@link lnrpc.SendCoinsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest} message SendCoinsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && message.hasOwnProperty("addr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.addr);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.satPerByte);
            return writer;
        };

        /**
         * Encodes the specified SendCoinsRequest message, length delimited. Does not implicitly {@link lnrpc.SendCoinsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest} message SendCoinsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendCoinsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendCoinsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 5:
                    message.satPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendCoinsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendCoinsRequest message.
         * @function verify
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendCoinsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates a SendCoinsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         */
        SendCoinsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendCoinsRequest)
                return object;
            var message = new $root.lnrpc.SendCoinsRequest();
            if (object.addr != null)
                message.addr = String(object.addr);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SendCoinsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.SendCoinsRequest} message SendCoinsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendCoinsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.addr = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.targetConf = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            return object;
        };

        /**
         * Converts this SendCoinsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendCoinsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendCoinsRequest;
    })();

    lnrpc.SendCoinsResponse = (function() {

        /**
         * Properties of a SendCoinsResponse.
         * @memberof lnrpc
         * @interface ISendCoinsResponse
         * @property {string|null} [txid] The transaction ID of the transaction
         */

        /**
         * Constructs a new SendCoinsResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendCoinsResponse.
         * @implements ISendCoinsResponse
         * @constructor
         * @param {lnrpc.ISendCoinsResponse=} [properties] Properties to set
         */
        function SendCoinsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The transaction ID of the transaction
         * @member {string} txid
         * @memberof lnrpc.SendCoinsResponse
         * @instance
         */
        SendCoinsResponse.prototype.txid = "";

        /**
         * Creates a new SendCoinsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse=} [properties] Properties to set
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse instance
         */
        SendCoinsResponse.create = function create(properties) {
            return new SendCoinsResponse(properties);
        };

        /**
         * Encodes the specified SendCoinsResponse message. Does not implicitly {@link lnrpc.SendCoinsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse} message SendCoinsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            return writer;
        };

        /**
         * Encodes the specified SendCoinsResponse message, length delimited. Does not implicitly {@link lnrpc.SendCoinsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse} message SendCoinsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendCoinsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendCoinsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendCoinsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendCoinsResponse message.
         * @function verify
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendCoinsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            return null;
        };

        /**
         * Creates a SendCoinsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         */
        SendCoinsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendCoinsResponse)
                return object;
            var message = new $root.lnrpc.SendCoinsResponse();
            if (object.txid != null)
                message.txid = String(object.txid);
            return message;
        };

        /**
         * Creates a plain object from a SendCoinsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.SendCoinsResponse} message SendCoinsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendCoinsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.txid = "";
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            return object;
        };

        /**
         * Converts this SendCoinsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendCoinsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendCoinsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendCoinsResponse;
    })();

    lnrpc.NewAddressRequest = (function() {

        /**
         * Properties of a NewAddressRequest.
         * @memberof lnrpc
         * @interface INewAddressRequest
         * @property {lnrpc.NewAddressRequest.AddressType|null} [type] The address type
         */

        /**
         * Constructs a new NewAddressRequest.
         * @memberof lnrpc
         * @classdesc `AddressType` has to be one of:
         * 
         * - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
         * - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
         * - `p2pkh`:  Pay to public key hash (`PUBKEY_HASH` = 2)
         * @implements INewAddressRequest
         * @constructor
         * @param {lnrpc.INewAddressRequest=} [properties] Properties to set
         */
        function NewAddressRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The address type
         * @member {lnrpc.NewAddressRequest.AddressType} type
         * @memberof lnrpc.NewAddressRequest
         * @instance
         */
        NewAddressRequest.prototype.type = 0;

        /**
         * Creates a new NewAddressRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest=} [properties] Properties to set
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest instance
         */
        NewAddressRequest.create = function create(properties) {
            return new NewAddressRequest(properties);
        };

        /**
         * Encodes the specified NewAddressRequest message. Does not implicitly {@link lnrpc.NewAddressRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest} message NewAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified NewAddressRequest message, length delimited. Does not implicitly {@link lnrpc.NewAddressRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest} message NewAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewAddressRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewAddressRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewAddressRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewAddressRequest message.
         * @function verify
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewAddressRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a NewAddressRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         */
        NewAddressRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewAddressRequest)
                return object;
            var message = new $root.lnrpc.NewAddressRequest();
            switch (object.type) {
            case "WITNESS_PUBKEY_HASH":
            case 0:
                message.type = 0;
                break;
            case "NESTED_PUBKEY_HASH":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a NewAddressRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.NewAddressRequest} message NewAddressRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewAddressRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "WITNESS_PUBKEY_HASH" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.NewAddressRequest.AddressType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this NewAddressRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NewAddressRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewAddressRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AddressType enum.
         * @name lnrpc.NewAddressRequest.AddressType
         * @enum {string}
         * @property {number} WITNESS_PUBKEY_HASH=0 WITNESS_PUBKEY_HASH value
         * @property {number} NESTED_PUBKEY_HASH=1 NESTED_PUBKEY_HASH value
         */
        NewAddressRequest.AddressType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "WITNESS_PUBKEY_HASH"] = 0;
            values[valuesById[1] = "NESTED_PUBKEY_HASH"] = 1;
            return values;
        })();

        return NewAddressRequest;
    })();

    lnrpc.NewWitnessAddressRequest = (function() {

        /**
         * Properties of a NewWitnessAddressRequest.
         * @memberof lnrpc
         * @interface INewWitnessAddressRequest
         */

        /**
         * Constructs a new NewWitnessAddressRequest.
         * @memberof lnrpc
         * @classdesc Represents a NewWitnessAddressRequest.
         * @implements INewWitnessAddressRequest
         * @constructor
         * @param {lnrpc.INewWitnessAddressRequest=} [properties] Properties to set
         */
        function NewWitnessAddressRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NewWitnessAddressRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {lnrpc.INewWitnessAddressRequest=} [properties] Properties to set
         * @returns {lnrpc.NewWitnessAddressRequest} NewWitnessAddressRequest instance
         */
        NewWitnessAddressRequest.create = function create(properties) {
            return new NewWitnessAddressRequest(properties);
        };

        /**
         * Encodes the specified NewWitnessAddressRequest message. Does not implicitly {@link lnrpc.NewWitnessAddressRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {lnrpc.INewWitnessAddressRequest} message NewWitnessAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewWitnessAddressRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NewWitnessAddressRequest message, length delimited. Does not implicitly {@link lnrpc.NewWitnessAddressRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {lnrpc.INewWitnessAddressRequest} message NewWitnessAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewWitnessAddressRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewWitnessAddressRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewWitnessAddressRequest} NewWitnessAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewWitnessAddressRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewWitnessAddressRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewWitnessAddressRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewWitnessAddressRequest} NewWitnessAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewWitnessAddressRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewWitnessAddressRequest message.
         * @function verify
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewWitnessAddressRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a NewWitnessAddressRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewWitnessAddressRequest} NewWitnessAddressRequest
         */
        NewWitnessAddressRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewWitnessAddressRequest)
                return object;
            return new $root.lnrpc.NewWitnessAddressRequest();
        };

        /**
         * Creates a plain object from a NewWitnessAddressRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewWitnessAddressRequest
         * @static
         * @param {lnrpc.NewWitnessAddressRequest} message NewWitnessAddressRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewWitnessAddressRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NewWitnessAddressRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NewWitnessAddressRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewWitnessAddressRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewWitnessAddressRequest;
    })();

    lnrpc.NewAddressResponse = (function() {

        /**
         * Properties of a NewAddressResponse.
         * @memberof lnrpc
         * @interface INewAddressResponse
         * @property {string|null} [address] The newly generated wallet address
         */

        /**
         * Constructs a new NewAddressResponse.
         * @memberof lnrpc
         * @classdesc Represents a NewAddressResponse.
         * @implements INewAddressResponse
         * @constructor
         * @param {lnrpc.INewAddressResponse=} [properties] Properties to set
         */
        function NewAddressResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The newly generated wallet address
         * @member {string} address
         * @memberof lnrpc.NewAddressResponse
         * @instance
         */
        NewAddressResponse.prototype.address = "";

        /**
         * Creates a new NewAddressResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse=} [properties] Properties to set
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse instance
         */
        NewAddressResponse.create = function create(properties) {
            return new NewAddressResponse(properties);
        };

        /**
         * Encodes the specified NewAddressResponse message. Does not implicitly {@link lnrpc.NewAddressResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse} message NewAddressResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified NewAddressResponse message, length delimited. Does not implicitly {@link lnrpc.NewAddressResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse} message NewAddressResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewAddressResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewAddressResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewAddressResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewAddressResponse message.
         * @function verify
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewAddressResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a NewAddressResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         */
        NewAddressResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewAddressResponse)
                return object;
            var message = new $root.lnrpc.NewAddressResponse();
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a NewAddressResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.NewAddressResponse} message NewAddressResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewAddressResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.address = "";
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this NewAddressResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.NewAddressResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewAddressResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewAddressResponse;
    })();

    lnrpc.SignMessageRequest = (function() {

        /**
         * Properties of a SignMessageRequest.
         * @memberof lnrpc
         * @interface ISignMessageRequest
         * @property {Uint8Array|null} [msg] The message to be signed
         */

        /**
         * Constructs a new SignMessageRequest.
         * @memberof lnrpc
         * @classdesc Represents a SignMessageRequest.
         * @implements ISignMessageRequest
         * @constructor
         * @param {lnrpc.ISignMessageRequest=} [properties] Properties to set
         */
        function SignMessageRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The message to be signed
         * @member {Uint8Array} msg
         * @memberof lnrpc.SignMessageRequest
         * @instance
         */
        SignMessageRequest.prototype.msg = $util.newBuffer([]);

        /**
         * Creates a new SignMessageRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest=} [properties] Properties to set
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest instance
         */
        SignMessageRequest.create = function create(properties) {
            return new SignMessageRequest(properties);
        };

        /**
         * Encodes the specified SignMessageRequest message. Does not implicitly {@link lnrpc.SignMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest} message SignMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && message.hasOwnProperty("msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msg);
            return writer;
        };

        /**
         * Encodes the specified SignMessageRequest message, length delimited. Does not implicitly {@link lnrpc.SignMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest} message SignMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SignMessageRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignMessageRequest message.
         * @function verify
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            return null;
        };

        /**
         * Creates a SignMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         */
        SignMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SignMessageRequest)
                return object;
            var message = new $root.lnrpc.SignMessageRequest();
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            return message;
        };

        /**
         * Creates a plain object from a SignMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.SignMessageRequest} message SignMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            return object;
        };

        /**
         * Converts this SignMessageRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SignMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignMessageRequest;
    })();

    lnrpc.SignMessageResponse = (function() {

        /**
         * Properties of a SignMessageResponse.
         * @memberof lnrpc
         * @interface ISignMessageResponse
         * @property {string|null} [signature] The signature for the given message
         */

        /**
         * Constructs a new SignMessageResponse.
         * @memberof lnrpc
         * @classdesc Represents a SignMessageResponse.
         * @implements ISignMessageResponse
         * @constructor
         * @param {lnrpc.ISignMessageResponse=} [properties] Properties to set
         */
        function SignMessageResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The signature for the given message
         * @member {string} signature
         * @memberof lnrpc.SignMessageResponse
         * @instance
         */
        SignMessageResponse.prototype.signature = "";

        /**
         * Creates a new SignMessageResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse=} [properties] Properties to set
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse instance
         */
        SignMessageResponse.create = function create(properties) {
            return new SignMessageResponse(properties);
        };

        /**
         * Encodes the specified SignMessageResponse message. Does not implicitly {@link lnrpc.SignMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse} message SignMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified SignMessageResponse message, length delimited. Does not implicitly {@link lnrpc.SignMessageResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse} message SignMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SignMessageResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignMessageResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignMessageResponse message.
         * @function verify
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignMessageResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a SignMessageResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         */
        SignMessageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SignMessageResponse)
                return object;
            var message = new $root.lnrpc.SignMessageResponse();
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a SignMessageResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.SignMessageResponse} message SignMessageResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignMessageResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.signature = "";
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this SignMessageResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SignMessageResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignMessageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignMessageResponse;
    })();

    lnrpc.VerifyMessageRequest = (function() {

        /**
         * Properties of a VerifyMessageRequest.
         * @memberof lnrpc
         * @interface IVerifyMessageRequest
         * @property {Uint8Array|null} [msg] The message over which the signature is to be verified
         * @property {string|null} [signature] The signature to be verified over the given message
         */

        /**
         * Constructs a new VerifyMessageRequest.
         * @memberof lnrpc
         * @classdesc Represents a VerifyMessageRequest.
         * @implements IVerifyMessageRequest
         * @constructor
         * @param {lnrpc.IVerifyMessageRequest=} [properties] Properties to set
         */
        function VerifyMessageRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The message over which the signature is to be verified
         * @member {Uint8Array} msg
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         */
        VerifyMessageRequest.prototype.msg = $util.newBuffer([]);

        /**
         * The signature to be verified over the given message
         * @member {string} signature
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         */
        VerifyMessageRequest.prototype.signature = "";

        /**
         * Creates a new VerifyMessageRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest=} [properties] Properties to set
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest instance
         */
        VerifyMessageRequest.create = function create(properties) {
            return new VerifyMessageRequest(properties);
        };

        /**
         * Encodes the specified VerifyMessageRequest message. Does not implicitly {@link lnrpc.VerifyMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest} message VerifyMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && message.hasOwnProperty("msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msg);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified VerifyMessageRequest message, length delimited. Does not implicitly {@link lnrpc.VerifyMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest} message VerifyMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyMessageRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyMessageRequest message.
         * @function verify
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a VerifyMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         */
        VerifyMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyMessageRequest)
                return object;
            var message = new $root.lnrpc.VerifyMessageRequest();
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a VerifyMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.VerifyMessageRequest} message VerifyMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
                object.signature = "";
            }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this VerifyMessageRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyMessageRequest;
    })();

    lnrpc.VerifyMessageResponse = (function() {

        /**
         * Properties of a VerifyMessageResponse.
         * @memberof lnrpc
         * @interface IVerifyMessageResponse
         * @property {boolean|null} [valid] Whether the signature was valid over the given message
         * @property {string|null} [pubkey] The pubkey recovered from the signature
         */

        /**
         * Constructs a new VerifyMessageResponse.
         * @memberof lnrpc
         * @classdesc Represents a VerifyMessageResponse.
         * @implements IVerifyMessageResponse
         * @constructor
         * @param {lnrpc.IVerifyMessageResponse=} [properties] Properties to set
         */
        function VerifyMessageResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whether the signature was valid over the given message
         * @member {boolean} valid
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         */
        VerifyMessageResponse.prototype.valid = false;

        /**
         * The pubkey recovered from the signature
         * @member {string} pubkey
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         */
        VerifyMessageResponse.prototype.pubkey = "";

        /**
         * Creates a new VerifyMessageResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse=} [properties] Properties to set
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse instance
         */
        VerifyMessageResponse.create = function create(properties) {
            return new VerifyMessageResponse(properties);
        };

        /**
         * Encodes the specified VerifyMessageResponse message. Does not implicitly {@link lnrpc.VerifyMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse} message VerifyMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.valid != null && message.hasOwnProperty("valid"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.valid);
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pubkey);
            return writer;
        };

        /**
         * Encodes the specified VerifyMessageResponse message, length delimited. Does not implicitly {@link lnrpc.VerifyMessageResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse} message VerifyMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyMessageResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.valid = reader.bool();
                    break;
                case 2:
                    message.pubkey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyMessageResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyMessageResponse message.
         * @function verify
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyMessageResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.valid != null && message.hasOwnProperty("valid"))
                if (typeof message.valid !== "boolean")
                    return "valid: boolean expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!$util.isString(message.pubkey))
                    return "pubkey: string expected";
            return null;
        };

        /**
         * Creates a VerifyMessageResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         */
        VerifyMessageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyMessageResponse)
                return object;
            var message = new $root.lnrpc.VerifyMessageResponse();
            if (object.valid != null)
                message.valid = Boolean(object.valid);
            if (object.pubkey != null)
                message.pubkey = String(object.pubkey);
            return message;
        };

        /**
         * Creates a plain object from a VerifyMessageResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.VerifyMessageResponse} message VerifyMessageResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyMessageResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.valid = false;
                object.pubkey = "";
            }
            if (message.valid != null && message.hasOwnProperty("valid"))
                object.valid = message.valid;
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = message.pubkey;
            return object;
        };

        /**
         * Converts this VerifyMessageResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyMessageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyMessageResponse;
    })();

    lnrpc.ConnectPeerRequest = (function() {

        /**
         * Properties of a ConnectPeerRequest.
         * @memberof lnrpc
         * @interface IConnectPeerRequest
         * @property {lnrpc.ILightningAddress|null} [addr] Lightning address of the peer, in the format `<pubkey>@host`
         * @property {boolean|null} [perm] If set, the daemon will attempt to persistently connect to the target
         * peer.  Otherwise, the call will be synchronous.
         */

        /**
         * Constructs a new ConnectPeerRequest.
         * @memberof lnrpc
         * @classdesc Represents a ConnectPeerRequest.
         * @implements IConnectPeerRequest
         * @constructor
         * @param {lnrpc.IConnectPeerRequest=} [properties] Properties to set
         */
        function ConnectPeerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Lightning address of the peer, in the format `<pubkey>@host`
         * @member {lnrpc.ILightningAddress|null|undefined} addr
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.addr = null;

        /**
         * If set, the daemon will attempt to persistently connect to the target
         * peer.  Otherwise, the call will be synchronous.
         * @member {boolean} perm
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.perm = false;

        /**
         * Creates a new ConnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest=} [properties] Properties to set
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest instance
         */
        ConnectPeerRequest.create = function create(properties) {
            return new ConnectPeerRequest(properties);
        };

        /**
         * Encodes the specified ConnectPeerRequest message. Does not implicitly {@link lnrpc.ConnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && message.hasOwnProperty("addr"))
                $root.lnrpc.LightningAddress.encode(message.addr, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.perm != null && message.hasOwnProperty("perm"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.perm);
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerRequest message, length delimited. Does not implicitly {@link lnrpc.ConnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConnectPeerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = $root.lnrpc.LightningAddress.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.perm = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerRequest message.
         * @function verify
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr")) {
                var error = $root.lnrpc.LightningAddress.verify(message.addr);
                if (error)
                    return "addr." + error;
            }
            if (message.perm != null && message.hasOwnProperty("perm"))
                if (typeof message.perm !== "boolean")
                    return "perm: boolean expected";
            return null;
        };

        /**
         * Creates a ConnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         */
        ConnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConnectPeerRequest)
                return object;
            var message = new $root.lnrpc.ConnectPeerRequest();
            if (object.addr != null) {
                if (typeof object.addr !== "object")
                    throw TypeError(".lnrpc.ConnectPeerRequest.addr: object expected");
                message.addr = $root.lnrpc.LightningAddress.fromObject(object.addr);
            }
            if (object.perm != null)
                message.perm = Boolean(object.perm);
            return message;
        };

        /**
         * Creates a plain object from a ConnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.ConnectPeerRequest} message ConnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.addr = null;
                object.perm = false;
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = $root.lnrpc.LightningAddress.toObject(message.addr, options);
            if (message.perm != null && message.hasOwnProperty("perm"))
                object.perm = message.perm;
            return object;
        };

        /**
         * Converts this ConnectPeerRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectPeerRequest;
    })();

    lnrpc.ConnectPeerResponse = (function() {

        /**
         * Properties of a ConnectPeerResponse.
         * @memberof lnrpc
         * @interface IConnectPeerResponse
         */

        /**
         * Constructs a new ConnectPeerResponse.
         * @memberof lnrpc
         * @classdesc Represents a ConnectPeerResponse.
         * @implements IConnectPeerResponse
         * @constructor
         * @param {lnrpc.IConnectPeerResponse=} [properties] Properties to set
         */
        function ConnectPeerResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ConnectPeerResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse=} [properties] Properties to set
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse instance
         */
        ConnectPeerResponse.create = function create(properties) {
            return new ConnectPeerResponse(properties);
        };

        /**
         * Encodes the specified ConnectPeerResponse message. Does not implicitly {@link lnrpc.ConnectPeerResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse} message ConnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerResponse message, length delimited. Does not implicitly {@link lnrpc.ConnectPeerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse} message ConnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConnectPeerResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerResponse message.
         * @function verify
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ConnectPeerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         */
        ConnectPeerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConnectPeerResponse)
                return object;
            return new $root.lnrpc.ConnectPeerResponse();
        };

        /**
         * Creates a plain object from a ConnectPeerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.ConnectPeerResponse} message ConnectPeerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ConnectPeerResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ConnectPeerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectPeerResponse;
    })();

    lnrpc.DisconnectPeerRequest = (function() {

        /**
         * Properties of a DisconnectPeerRequest.
         * @memberof lnrpc
         * @interface IDisconnectPeerRequest
         * @property {string|null} [pubKey] The pubkey of the node to disconnect from
         */

        /**
         * Constructs a new DisconnectPeerRequest.
         * @memberof lnrpc
         * @classdesc Represents a DisconnectPeerRequest.
         * @implements IDisconnectPeerRequest
         * @constructor
         * @param {lnrpc.IDisconnectPeerRequest=} [properties] Properties to set
         */
        function DisconnectPeerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The pubkey of the node to disconnect from
         * @member {string} pubKey
         * @memberof lnrpc.DisconnectPeerRequest
         * @instance
         */
        DisconnectPeerRequest.prototype.pubKey = "";

        /**
         * Creates a new DisconnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest=} [properties] Properties to set
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest instance
         */
        DisconnectPeerRequest.create = function create(properties) {
            return new DisconnectPeerRequest(properties);
        };

        /**
         * Encodes the specified DisconnectPeerRequest message. Does not implicitly {@link lnrpc.DisconnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest} message DisconnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            return writer;
        };

        /**
         * Encodes the specified DisconnectPeerRequest message, length delimited. Does not implicitly {@link lnrpc.DisconnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest} message DisconnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DisconnectPeerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectPeerRequest message.
         * @function verify
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            return null;
        };

        /**
         * Creates a DisconnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         */
        DisconnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DisconnectPeerRequest)
                return object;
            var message = new $root.lnrpc.DisconnectPeerRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            return message;
        };

        /**
         * Creates a plain object from a DisconnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.DisconnectPeerRequest} message DisconnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pubKey = "";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            return object;
        };

        /**
         * Converts this DisconnectPeerRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DisconnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectPeerRequest;
    })();

    lnrpc.DisconnectPeerResponse = (function() {

        /**
         * Properties of a DisconnectPeerResponse.
         * @memberof lnrpc
         * @interface IDisconnectPeerResponse
         */

        /**
         * Constructs a new DisconnectPeerResponse.
         * @memberof lnrpc
         * @classdesc Represents a DisconnectPeerResponse.
         * @implements IDisconnectPeerResponse
         * @constructor
         * @param {lnrpc.IDisconnectPeerResponse=} [properties] Properties to set
         */
        function DisconnectPeerResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DisconnectPeerResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse=} [properties] Properties to set
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse instance
         */
        DisconnectPeerResponse.create = function create(properties) {
            return new DisconnectPeerResponse(properties);
        };

        /**
         * Encodes the specified DisconnectPeerResponse message. Does not implicitly {@link lnrpc.DisconnectPeerResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse} message DisconnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DisconnectPeerResponse message, length delimited. Does not implicitly {@link lnrpc.DisconnectPeerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse} message DisconnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectPeerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DisconnectPeerResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectPeerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectPeerResponse message.
         * @function verify
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectPeerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DisconnectPeerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         */
        DisconnectPeerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DisconnectPeerResponse)
                return object;
            return new $root.lnrpc.DisconnectPeerResponse();
        };

        /**
         * Creates a plain object from a DisconnectPeerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.DisconnectPeerResponse} message DisconnectPeerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectPeerResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DisconnectPeerResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DisconnectPeerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectPeerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectPeerResponse;
    })();

    lnrpc.HTLC = (function() {

        /**
         * Properties of a HTLC.
         * @memberof lnrpc
         * @interface IHTLC
         * @property {boolean|null} [incoming] HTLC incoming
         * @property {number|Long|null} [amount] HTLC amount
         * @property {Uint8Array|null} [hashLock] HTLC hashLock
         * @property {number|null} [expirationHeight] HTLC expirationHeight
         */

        /**
         * Constructs a new HTLC.
         * @memberof lnrpc
         * @classdesc Represents a HTLC.
         * @implements IHTLC
         * @constructor
         * @param {lnrpc.IHTLC=} [properties] Properties to set
         */
        function HTLC(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HTLC incoming.
         * @member {boolean} incoming
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.incoming = false;

        /**
         * HTLC amount.
         * @member {number|Long} amount
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HTLC hashLock.
         * @member {Uint8Array} hashLock
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.hashLock = $util.newBuffer([]);

        /**
         * HTLC expirationHeight.
         * @member {number} expirationHeight
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.expirationHeight = 0;

        /**
         * Creates a new HTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC=} [properties] Properties to set
         * @returns {lnrpc.HTLC} HTLC instance
         */
        HTLC.create = function create(properties) {
            return new HTLC(properties);
        };

        /**
         * Encodes the specified HTLC message. Does not implicitly {@link lnrpc.HTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC} message HTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.incoming);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hashLock);
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expirationHeight);
            return writer;
        };

        /**
         * Encodes the specified HTLC message, length delimited. Does not implicitly {@link lnrpc.HTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC} message HTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HTLC} HTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HTLC();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incoming = reader.bool();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.hashLock = reader.bytes();
                    break;
                case 4:
                    message.expirationHeight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HTLC} HTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HTLC message.
         * @function verify
         * @memberof lnrpc.HTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                if (typeof message.incoming !== "boolean")
                    return "incoming: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                if (!(message.hashLock && typeof message.hashLock.length === "number" || $util.isString(message.hashLock)))
                    return "hashLock: buffer expected";
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                if (!$util.isInteger(message.expirationHeight))
                    return "expirationHeight: integer expected";
            return null;
        };

        /**
         * Creates a HTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HTLC} HTLC
         */
        HTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HTLC)
                return object;
            var message = new $root.lnrpc.HTLC();
            if (object.incoming != null)
                message.incoming = Boolean(object.incoming);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.hashLock != null)
                if (typeof object.hashLock === "string")
                    $util.base64.decode(object.hashLock, message.hashLock = $util.newBuffer($util.base64.length(object.hashLock)), 0);
                else if (object.hashLock.length)
                    message.hashLock = object.hashLock;
            if (object.expirationHeight != null)
                message.expirationHeight = object.expirationHeight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.HTLC} message HTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.incoming = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hashLock = "";
                else {
                    object.hashLock = [];
                    if (options.bytes !== Array)
                        object.hashLock = $util.newBuffer(object.hashLock);
                }
                object.expirationHeight = 0;
            }
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                object.incoming = message.incoming;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                object.hashLock = options.bytes === String ? $util.base64.encode(message.hashLock, 0, message.hashLock.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashLock) : message.hashLock;
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                object.expirationHeight = message.expirationHeight;
            return object;
        };

        /**
         * Converts this HTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.HTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HTLC;
    })();

    lnrpc.Channel = (function() {

        /**
         * Properties of a Channel.
         * @memberof lnrpc
         * @interface IChannel
         * @property {boolean|null} [active] Whether this channel is active or not
         * @property {string|null} [remotePubkey] The identity pubkey of the remote node
         * @property {string|null} [channelPoint] The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {number|Long|null} [capacity] The total amount of funds held in this channel
         * @property {number|Long|null} [localBalance] This node's current balance in this channel
         * @property {number|Long|null} [remoteBalance] The counterparty's current balance in this channel
         * @property {number|Long|null} [commitFee] The amount calculated to be paid in fees for the current set of commitment
         * transactions. The fee amount is persisted with the channel in order to
         * allow the fee amount to be removed and recalculated with each channel state
         * update, including updates that happen after a system restart.
         * @property {number|Long|null} [commitWeight] The weight of the commitment transaction
         * @property {number|Long|null} [feePerKw] The required number of satoshis per kilo-weight that the requester will pay
         * at all times, for both the funding transaction and commitment transaction.
         * This value can later be updated once the channel is open.
         * @property {number|Long|null} [unsettledBalance] The unsettled balance in this channel
         * @property {number|Long|null} [totalSatoshisSent] The total number of satoshis we've sent within this channel.
         * @property {number|Long|null} [totalSatoshisReceived] The total number of satoshis we've received within this channel.
         * @property {number|Long|null} [numUpdates] The total number of updates conducted within this channel.
         * @property {Array.<lnrpc.IHTLC>|null} [pendingHtlcs] The list of active, uncleared HTLCs currently pending within the channel.
         * @property {number|null} [csvDelay] The CSV delay expressed in relative blocks. If the channel is force
         * closed, we'll need to wait for this many blocks before we can regain our
         * funds.
         * @property {boolean|null} ["private"] Whether this channel is advertised to the network or not
         */

        /**
         * Constructs a new Channel.
         * @memberof lnrpc
         * @classdesc Represents a Channel.
         * @implements IChannel
         * @constructor
         * @param {lnrpc.IChannel=} [properties] Properties to set
         */
        function Channel(properties) {
            this.pendingHtlcs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whether this channel is active or not
         * @member {boolean} active
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.active = false;

        /**
         * The identity pubkey of the remote node
         * @member {string} remotePubkey
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remotePubkey = "";

        /**
         * The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @member {string} channelPoint
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.channelPoint = "";

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of funds held in this channel
         * @member {number|Long} capacity
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * This node's current balance in this channel
         * @member {number|Long} localBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.localBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The counterparty's current balance in this channel
         * @member {number|Long} remoteBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remoteBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount calculated to be paid in fees for the current set of commitment
         * transactions. The fee amount is persisted with the channel in order to
         * allow the fee amount to be removed and recalculated with each channel state
         * update, including updates that happen after a system restart.
         * @member {number|Long} commitFee
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The weight of the commitment transaction
         * @member {number|Long} commitWeight
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitWeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The required number of satoshis per kilo-weight that the requester will pay
         * at all times, for both the funding transaction and commitment transaction.
         * This value can later be updated once the channel is open.
         * @member {number|Long} feePerKw
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The unsettled balance in this channel
         * @member {number|Long} unsettledBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.unsettledBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total number of satoshis we've sent within this channel.
         * @member {number|Long} totalSatoshisSent
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.totalSatoshisSent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total number of satoshis we've received within this channel.
         * @member {number|Long} totalSatoshisReceived
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.totalSatoshisReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total number of updates conducted within this channel.
         * @member {number|Long} numUpdates
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.numUpdates = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The list of active, uncleared HTLCs currently pending within the channel.
         * @member {Array.<lnrpc.IHTLC>} pendingHtlcs
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.pendingHtlcs = $util.emptyArray;

        /**
         * The CSV delay expressed in relative blocks. If the channel is force
         * closed, we'll need to wait for this many blocks before we can regain our
         * funds.
         * @member {number} csvDelay
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.csvDelay = 0;

        /**
         * Whether this channel is advertised to the network or not
         * @member {boolean} private
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype["private"] = false;

        /**
         * Creates a new Channel instance using the specified properties.
         * @function create
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel=} [properties] Properties to set
         * @returns {lnrpc.Channel} Channel instance
         */
        Channel.create = function create(properties) {
            return new Channel(properties);
        };

        /**
         * Encodes the specified Channel message. Does not implicitly {@link lnrpc.Channel.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.active);
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.remotePubkey);
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelPoint);
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.chanId);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.capacity);
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.localBalance);
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.remoteBalance);
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.commitFee);
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.commitWeight);
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.feePerKw);
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.unsettledBalance);
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.totalSatoshisSent);
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.totalSatoshisReceived);
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.numUpdates);
            if (message.pendingHtlcs != null && message.pendingHtlcs.length)
                for (var i = 0; i < message.pendingHtlcs.length; ++i)
                    $root.lnrpc.HTLC.encode(message.pendingHtlcs[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.csvDelay);
            if (message["private"] != null && message.hasOwnProperty("private"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message["private"]);
            return writer;
        };

        /**
         * Encodes the specified Channel message, length delimited. Does not implicitly {@link lnrpc.Channel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Channel message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Channel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.active = reader.bool();
                    break;
                case 2:
                    message.remotePubkey = reader.string();
                    break;
                case 3:
                    message.channelPoint = reader.string();
                    break;
                case 4:
                    message.chanId = reader.uint64();
                    break;
                case 5:
                    message.capacity = reader.int64();
                    break;
                case 6:
                    message.localBalance = reader.int64();
                    break;
                case 7:
                    message.remoteBalance = reader.int64();
                    break;
                case 8:
                    message.commitFee = reader.int64();
                    break;
                case 9:
                    message.commitWeight = reader.int64();
                    break;
                case 10:
                    message.feePerKw = reader.int64();
                    break;
                case 11:
                    message.unsettledBalance = reader.int64();
                    break;
                case 12:
                    message.totalSatoshisSent = reader.int64();
                    break;
                case 13:
                    message.totalSatoshisReceived = reader.int64();
                    break;
                case 14:
                    message.numUpdates = reader.uint64();
                    break;
                case 15:
                    if (!(message.pendingHtlcs && message.pendingHtlcs.length))
                        message.pendingHtlcs = [];
                    message.pendingHtlcs.push($root.lnrpc.HTLC.decode(reader, reader.uint32()));
                    break;
                case 16:
                    message.csvDelay = reader.uint32();
                    break;
                case 17:
                    message["private"] = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Channel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Channel message.
         * @function verify
         * @memberof lnrpc.Channel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Channel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                if (!$util.isString(message.remotePubkey))
                    return "remotePubkey: string expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                if (!$util.isInteger(message.localBalance) && !(message.localBalance && $util.isInteger(message.localBalance.low) && $util.isInteger(message.localBalance.high)))
                    return "localBalance: integer|Long expected";
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                if (!$util.isInteger(message.remoteBalance) && !(message.remoteBalance && $util.isInteger(message.remoteBalance.low) && $util.isInteger(message.remoteBalance.high)))
                    return "remoteBalance: integer|Long expected";
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                if (!$util.isInteger(message.commitFee) && !(message.commitFee && $util.isInteger(message.commitFee.low) && $util.isInteger(message.commitFee.high)))
                    return "commitFee: integer|Long expected";
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                if (!$util.isInteger(message.commitWeight) && !(message.commitWeight && $util.isInteger(message.commitWeight.low) && $util.isInteger(message.commitWeight.high)))
                    return "commitWeight: integer|Long expected";
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                    return "feePerKw: integer|Long expected";
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                if (!$util.isInteger(message.unsettledBalance) && !(message.unsettledBalance && $util.isInteger(message.unsettledBalance.low) && $util.isInteger(message.unsettledBalance.high)))
                    return "unsettledBalance: integer|Long expected";
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                if (!$util.isInteger(message.totalSatoshisSent) && !(message.totalSatoshisSent && $util.isInteger(message.totalSatoshisSent.low) && $util.isInteger(message.totalSatoshisSent.high)))
                    return "totalSatoshisSent: integer|Long expected";
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                if (!$util.isInteger(message.totalSatoshisReceived) && !(message.totalSatoshisReceived && $util.isInteger(message.totalSatoshisReceived.low) && $util.isInteger(message.totalSatoshisReceived.high)))
                    return "totalSatoshisReceived: integer|Long expected";
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                if (!$util.isInteger(message.numUpdates) && !(message.numUpdates && $util.isInteger(message.numUpdates.low) && $util.isInteger(message.numUpdates.high)))
                    return "numUpdates: integer|Long expected";
            if (message.pendingHtlcs != null && message.hasOwnProperty("pendingHtlcs")) {
                if (!Array.isArray(message.pendingHtlcs))
                    return "pendingHtlcs: array expected";
                for (var i = 0; i < message.pendingHtlcs.length; ++i) {
                    var error = $root.lnrpc.HTLC.verify(message.pendingHtlcs[i]);
                    if (error)
                        return "pendingHtlcs." + error;
                }
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                if (!$util.isInteger(message.csvDelay))
                    return "csvDelay: integer expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            return null;
        };

        /**
         * Creates a Channel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Channel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Channel} Channel
         */
        Channel.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Channel)
                return object;
            var message = new $root.lnrpc.Channel();
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.remotePubkey != null)
                message.remotePubkey = String(object.remotePubkey);
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.localBalance != null)
                if ($util.Long)
                    (message.localBalance = $util.Long.fromValue(object.localBalance)).unsigned = false;
                else if (typeof object.localBalance === "string")
                    message.localBalance = parseInt(object.localBalance, 10);
                else if (typeof object.localBalance === "number")
                    message.localBalance = object.localBalance;
                else if (typeof object.localBalance === "object")
                    message.localBalance = new $util.LongBits(object.localBalance.low >>> 0, object.localBalance.high >>> 0).toNumber();
            if (object.remoteBalance != null)
                if ($util.Long)
                    (message.remoteBalance = $util.Long.fromValue(object.remoteBalance)).unsigned = false;
                else if (typeof object.remoteBalance === "string")
                    message.remoteBalance = parseInt(object.remoteBalance, 10);
                else if (typeof object.remoteBalance === "number")
                    message.remoteBalance = object.remoteBalance;
                else if (typeof object.remoteBalance === "object")
                    message.remoteBalance = new $util.LongBits(object.remoteBalance.low >>> 0, object.remoteBalance.high >>> 0).toNumber();
            if (object.commitFee != null)
                if ($util.Long)
                    (message.commitFee = $util.Long.fromValue(object.commitFee)).unsigned = false;
                else if (typeof object.commitFee === "string")
                    message.commitFee = parseInt(object.commitFee, 10);
                else if (typeof object.commitFee === "number")
                    message.commitFee = object.commitFee;
                else if (typeof object.commitFee === "object")
                    message.commitFee = new $util.LongBits(object.commitFee.low >>> 0, object.commitFee.high >>> 0).toNumber();
            if (object.commitWeight != null)
                if ($util.Long)
                    (message.commitWeight = $util.Long.fromValue(object.commitWeight)).unsigned = false;
                else if (typeof object.commitWeight === "string")
                    message.commitWeight = parseInt(object.commitWeight, 10);
                else if (typeof object.commitWeight === "number")
                    message.commitWeight = object.commitWeight;
                else if (typeof object.commitWeight === "object")
                    message.commitWeight = new $util.LongBits(object.commitWeight.low >>> 0, object.commitWeight.high >>> 0).toNumber();
            if (object.feePerKw != null)
                if ($util.Long)
                    (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = false;
                else if (typeof object.feePerKw === "string")
                    message.feePerKw = parseInt(object.feePerKw, 10);
                else if (typeof object.feePerKw === "number")
                    message.feePerKw = object.feePerKw;
                else if (typeof object.feePerKw === "object")
                    message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber();
            if (object.unsettledBalance != null)
                if ($util.Long)
                    (message.unsettledBalance = $util.Long.fromValue(object.unsettledBalance)).unsigned = false;
                else if (typeof object.unsettledBalance === "string")
                    message.unsettledBalance = parseInt(object.unsettledBalance, 10);
                else if (typeof object.unsettledBalance === "number")
                    message.unsettledBalance = object.unsettledBalance;
                else if (typeof object.unsettledBalance === "object")
                    message.unsettledBalance = new $util.LongBits(object.unsettledBalance.low >>> 0, object.unsettledBalance.high >>> 0).toNumber();
            if (object.totalSatoshisSent != null)
                if ($util.Long)
                    (message.totalSatoshisSent = $util.Long.fromValue(object.totalSatoshisSent)).unsigned = false;
                else if (typeof object.totalSatoshisSent === "string")
                    message.totalSatoshisSent = parseInt(object.totalSatoshisSent, 10);
                else if (typeof object.totalSatoshisSent === "number")
                    message.totalSatoshisSent = object.totalSatoshisSent;
                else if (typeof object.totalSatoshisSent === "object")
                    message.totalSatoshisSent = new $util.LongBits(object.totalSatoshisSent.low >>> 0, object.totalSatoshisSent.high >>> 0).toNumber();
            if (object.totalSatoshisReceived != null)
                if ($util.Long)
                    (message.totalSatoshisReceived = $util.Long.fromValue(object.totalSatoshisReceived)).unsigned = false;
                else if (typeof object.totalSatoshisReceived === "string")
                    message.totalSatoshisReceived = parseInt(object.totalSatoshisReceived, 10);
                else if (typeof object.totalSatoshisReceived === "number")
                    message.totalSatoshisReceived = object.totalSatoshisReceived;
                else if (typeof object.totalSatoshisReceived === "object")
                    message.totalSatoshisReceived = new $util.LongBits(object.totalSatoshisReceived.low >>> 0, object.totalSatoshisReceived.high >>> 0).toNumber();
            if (object.numUpdates != null)
                if ($util.Long)
                    (message.numUpdates = $util.Long.fromValue(object.numUpdates)).unsigned = true;
                else if (typeof object.numUpdates === "string")
                    message.numUpdates = parseInt(object.numUpdates, 10);
                else if (typeof object.numUpdates === "number")
                    message.numUpdates = object.numUpdates;
                else if (typeof object.numUpdates === "object")
                    message.numUpdates = new $util.LongBits(object.numUpdates.low >>> 0, object.numUpdates.high >>> 0).toNumber(true);
            if (object.pendingHtlcs) {
                if (!Array.isArray(object.pendingHtlcs))
                    throw TypeError(".lnrpc.Channel.pendingHtlcs: array expected");
                message.pendingHtlcs = [];
                for (var i = 0; i < object.pendingHtlcs.length; ++i) {
                    if (typeof object.pendingHtlcs[i] !== "object")
                        throw TypeError(".lnrpc.Channel.pendingHtlcs: object expected");
                    message.pendingHtlcs[i] = $root.lnrpc.HTLC.fromObject(object.pendingHtlcs[i]);
                }
            }
            if (object.csvDelay != null)
                message.csvDelay = object.csvDelay >>> 0;
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            return message;
        };

        /**
         * Creates a plain object from a Channel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.Channel} message Channel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Channel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pendingHtlcs = [];
            if (options.defaults) {
                object.active = false;
                object.remotePubkey = "";
                object.channelPoint = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.localBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.remoteBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remoteBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.commitFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commitFee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.commitWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commitWeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerKw = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.unsettledBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unsettledBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalSatoshisSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSatoshisSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalSatoshisReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSatoshisReceived = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.numUpdates = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numUpdates = options.longs === String ? "0" : 0;
                object.csvDelay = 0;
                object["private"] = false;
            }
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                object.remotePubkey = message.remotePubkey;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                if (typeof message.localBalance === "number")
                    object.localBalance = options.longs === String ? String(message.localBalance) : message.localBalance;
                else
                    object.localBalance = options.longs === String ? $util.Long.prototype.toString.call(message.localBalance) : options.longs === Number ? new $util.LongBits(message.localBalance.low >>> 0, message.localBalance.high >>> 0).toNumber() : message.localBalance;
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                if (typeof message.remoteBalance === "number")
                    object.remoteBalance = options.longs === String ? String(message.remoteBalance) : message.remoteBalance;
                else
                    object.remoteBalance = options.longs === String ? $util.Long.prototype.toString.call(message.remoteBalance) : options.longs === Number ? new $util.LongBits(message.remoteBalance.low >>> 0, message.remoteBalance.high >>> 0).toNumber() : message.remoteBalance;
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                if (typeof message.commitFee === "number")
                    object.commitFee = options.longs === String ? String(message.commitFee) : message.commitFee;
                else
                    object.commitFee = options.longs === String ? $util.Long.prototype.toString.call(message.commitFee) : options.longs === Number ? new $util.LongBits(message.commitFee.low >>> 0, message.commitFee.high >>> 0).toNumber() : message.commitFee;
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                if (typeof message.commitWeight === "number")
                    object.commitWeight = options.longs === String ? String(message.commitWeight) : message.commitWeight;
                else
                    object.commitWeight = options.longs === String ? $util.Long.prototype.toString.call(message.commitWeight) : options.longs === Number ? new $util.LongBits(message.commitWeight.low >>> 0, message.commitWeight.high >>> 0).toNumber() : message.commitWeight;
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (typeof message.feePerKw === "number")
                    object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                else
                    object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber() : message.feePerKw;
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                if (typeof message.unsettledBalance === "number")
                    object.unsettledBalance = options.longs === String ? String(message.unsettledBalance) : message.unsettledBalance;
                else
                    object.unsettledBalance = options.longs === String ? $util.Long.prototype.toString.call(message.unsettledBalance) : options.longs === Number ? new $util.LongBits(message.unsettledBalance.low >>> 0, message.unsettledBalance.high >>> 0).toNumber() : message.unsettledBalance;
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                if (typeof message.totalSatoshisSent === "number")
                    object.totalSatoshisSent = options.longs === String ? String(message.totalSatoshisSent) : message.totalSatoshisSent;
                else
                    object.totalSatoshisSent = options.longs === String ? $util.Long.prototype.toString.call(message.totalSatoshisSent) : options.longs === Number ? new $util.LongBits(message.totalSatoshisSent.low >>> 0, message.totalSatoshisSent.high >>> 0).toNumber() : message.totalSatoshisSent;
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                if (typeof message.totalSatoshisReceived === "number")
                    object.totalSatoshisReceived = options.longs === String ? String(message.totalSatoshisReceived) : message.totalSatoshisReceived;
                else
                    object.totalSatoshisReceived = options.longs === String ? $util.Long.prototype.toString.call(message.totalSatoshisReceived) : options.longs === Number ? new $util.LongBits(message.totalSatoshisReceived.low >>> 0, message.totalSatoshisReceived.high >>> 0).toNumber() : message.totalSatoshisReceived;
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                if (typeof message.numUpdates === "number")
                    object.numUpdates = options.longs === String ? String(message.numUpdates) : message.numUpdates;
                else
                    object.numUpdates = options.longs === String ? $util.Long.prototype.toString.call(message.numUpdates) : options.longs === Number ? new $util.LongBits(message.numUpdates.low >>> 0, message.numUpdates.high >>> 0).toNumber(true) : message.numUpdates;
            if (message.pendingHtlcs && message.pendingHtlcs.length) {
                object.pendingHtlcs = [];
                for (var j = 0; j < message.pendingHtlcs.length; ++j)
                    object.pendingHtlcs[j] = $root.lnrpc.HTLC.toObject(message.pendingHtlcs[j], options);
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                object.csvDelay = message.csvDelay;
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            return object;
        };

        /**
         * Converts this Channel to JSON.
         * @function toJSON
         * @memberof lnrpc.Channel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Channel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Channel;
    })();

    lnrpc.ListChannelsRequest = (function() {

        /**
         * Properties of a ListChannelsRequest.
         * @memberof lnrpc
         * @interface IListChannelsRequest
         * @property {boolean|null} [activeOnly] ListChannelsRequest activeOnly
         * @property {boolean|null} [inactiveOnly] ListChannelsRequest inactiveOnly
         * @property {boolean|null} [publicOnly] ListChannelsRequest publicOnly
         * @property {boolean|null} [privateOnly] ListChannelsRequest privateOnly
         */

        /**
         * Constructs a new ListChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListChannelsRequest.
         * @implements IListChannelsRequest
         * @constructor
         * @param {lnrpc.IListChannelsRequest=} [properties] Properties to set
         */
        function ListChannelsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListChannelsRequest activeOnly.
         * @member {boolean} activeOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.activeOnly = false;

        /**
         * ListChannelsRequest inactiveOnly.
         * @member {boolean} inactiveOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.inactiveOnly = false;

        /**
         * ListChannelsRequest publicOnly.
         * @member {boolean} publicOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.publicOnly = false;

        /**
         * ListChannelsRequest privateOnly.
         * @member {boolean} privateOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.privateOnly = false;

        /**
         * Creates a new ListChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest instance
         */
        ListChannelsRequest.create = function create(properties) {
            return new ListChannelsRequest(properties);
        };

        /**
         * Encodes the specified ListChannelsRequest message. Does not implicitly {@link lnrpc.ListChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest} message ListChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.activeOnly);
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inactiveOnly);
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.publicOnly);
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.privateOnly);
            return writer;
        };

        /**
         * Encodes the specified ListChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.ListChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest} message ListChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListChannelsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activeOnly = reader.bool();
                    break;
                case 2:
                    message.inactiveOnly = reader.bool();
                    break;
                case 3:
                    message.publicOnly = reader.bool();
                    break;
                case 4:
                    message.privateOnly = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListChannelsRequest message.
         * @function verify
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                if (typeof message.activeOnly !== "boolean")
                    return "activeOnly: boolean expected";
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                if (typeof message.inactiveOnly !== "boolean")
                    return "inactiveOnly: boolean expected";
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                if (typeof message.publicOnly !== "boolean")
                    return "publicOnly: boolean expected";
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                if (typeof message.privateOnly !== "boolean")
                    return "privateOnly: boolean expected";
            return null;
        };

        /**
         * Creates a ListChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         */
        ListChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListChannelsRequest)
                return object;
            var message = new $root.lnrpc.ListChannelsRequest();
            if (object.activeOnly != null)
                message.activeOnly = Boolean(object.activeOnly);
            if (object.inactiveOnly != null)
                message.inactiveOnly = Boolean(object.inactiveOnly);
            if (object.publicOnly != null)
                message.publicOnly = Boolean(object.publicOnly);
            if (object.privateOnly != null)
                message.privateOnly = Boolean(object.privateOnly);
            return message;
        };

        /**
         * Creates a plain object from a ListChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.ListChannelsRequest} message ListChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListChannelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.activeOnly = false;
                object.inactiveOnly = false;
                object.publicOnly = false;
                object.privateOnly = false;
            }
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                object.activeOnly = message.activeOnly;
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                object.inactiveOnly = message.inactiveOnly;
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                object.publicOnly = message.publicOnly;
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                object.privateOnly = message.privateOnly;
            return object;
        };

        /**
         * Converts this ListChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListChannelsRequest;
    })();

    lnrpc.ListChannelsResponse = (function() {

        /**
         * Properties of a ListChannelsResponse.
         * @memberof lnrpc
         * @interface IListChannelsResponse
         * @property {Array.<lnrpc.IChannel>|null} [channels] The list of active channels
         */

        /**
         * Constructs a new ListChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListChannelsResponse.
         * @implements IListChannelsResponse
         * @constructor
         * @param {lnrpc.IListChannelsResponse=} [properties] Properties to set
         */
        function ListChannelsResponse(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of active channels
         * @member {Array.<lnrpc.IChannel>} channels
         * @memberof lnrpc.ListChannelsResponse
         * @instance
         */
        ListChannelsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ListChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse instance
         */
        ListChannelsResponse.create = function create(properties) {
            return new ListChannelsResponse(properties);
        };

        /**
         * Encodes the specified ListChannelsResponse message. Does not implicitly {@link lnrpc.ListChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse} message ListChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.Channel.encode(message.channels[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.ListChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse} message ListChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListChannelsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 11:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.Channel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListChannelsResponse message.
         * @function verify
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (var i = 0; i < message.channels.length; ++i) {
                    var error = $root.lnrpc.Channel.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         */
        ListChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListChannelsResponse)
                return object;
            var message = new $root.lnrpc.ListChannelsResponse();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.ListChannelsResponse.channels: array expected");
                message.channels = [];
                for (var i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.ListChannelsResponse.channels: object expected");
                    message.channels[i] = $root.lnrpc.Channel.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.ListChannelsResponse} message ListChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (var j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.Channel.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this ListChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListChannelsResponse;
    })();

    lnrpc.ChannelCloseSummary = (function() {

        /**
         * Properties of a ChannelCloseSummary.
         * @memberof lnrpc
         * @interface IChannelCloseSummary
         * @property {string|null} [channelPoint] The outpoint (txid:index) of the funding transaction.
         * @property {number|Long|null} [chanId] The unique channel ID for the channel.
         * @property {string|null} [chainHash] The hash of the genesis block that this channel resides within.
         * @property {string|null} [closingTxHash] The txid of the transaction which ultimately closed this channel.
         * @property {string|null} [remotePubkey] Public key of the remote peer that we formerly had a channel with.
         * @property {number|Long|null} [capacity] Total capacity of the channel.
         * @property {number|null} [closeHeight] Height at which the funding transaction was spent.
         * @property {number|Long|null} [settledBalance] Settled balance at the time of channel closure
         * @property {number|Long|null} [timeLockedBalance] The sum of all the time-locked outputs at the time of channel closure
         * @property {lnrpc.ChannelCloseSummary.ClosureType|null} [closeType] Details on how the channel was closed.
         */

        /**
         * Constructs a new ChannelCloseSummary.
         * @memberof lnrpc
         * @classdesc Represents a ChannelCloseSummary.
         * @implements IChannelCloseSummary
         * @constructor
         * @param {lnrpc.IChannelCloseSummary=} [properties] Properties to set
         */
        function ChannelCloseSummary(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The outpoint (txid:index) of the funding transaction.
         * @member {string} channelPoint
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.channelPoint = "";

        /**
         * The unique channel ID for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The hash of the genesis block that this channel resides within.
         * @member {string} chainHash
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.chainHash = "";

        /**
         * The txid of the transaction which ultimately closed this channel.
         * @member {string} closingTxHash
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closingTxHash = "";

        /**
         * Public key of the remote peer that we formerly had a channel with.
         * @member {string} remotePubkey
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.remotePubkey = "";

        /**
         * Total capacity of the channel.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Height at which the funding transaction was spent.
         * @member {number} closeHeight
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeHeight = 0;

        /**
         * Settled balance at the time of channel closure
         * @member {number|Long} settledBalance
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.settledBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The sum of all the time-locked outputs at the time of channel closure
         * @member {number|Long} timeLockedBalance
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.timeLockedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Details on how the channel was closed.
         * @member {lnrpc.ChannelCloseSummary.ClosureType} closeType
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeType = 0;

        /**
         * Creates a new ChannelCloseSummary instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary=} [properties] Properties to set
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary instance
         */
        ChannelCloseSummary.create = function create(properties) {
            return new ChannelCloseSummary(properties);
        };

        /**
         * Encodes the specified ChannelCloseSummary message. Does not implicitly {@link lnrpc.ChannelCloseSummary.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary} message ChannelCloseSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelPoint);
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanId);
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.chainHash);
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.closingTxHash);
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.remotePubkey);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.capacity);
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.closeHeight);
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.settledBalance);
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeLockedBalance);
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.closeType);
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseSummary message, length delimited. Does not implicitly {@link lnrpc.ChannelCloseSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary} message ChannelCloseSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseSummary message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelCloseSummary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = reader.string();
                    break;
                case 2:
                    message.chanId = reader.uint64();
                    break;
                case 3:
                    message.chainHash = reader.string();
                    break;
                case 4:
                    message.closingTxHash = reader.string();
                    break;
                case 5:
                    message.remotePubkey = reader.string();
                    break;
                case 6:
                    message.capacity = reader.int64();
                    break;
                case 7:
                    message.closeHeight = reader.uint32();
                    break;
                case 8:
                    message.settledBalance = reader.int64();
                    break;
                case 9:
                    message.timeLockedBalance = reader.int64();
                    break;
                case 10:
                    message.closeType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseSummary message.
         * @function verify
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                if (!$util.isString(message.chainHash))
                    return "chainHash: string expected";
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                if (!$util.isString(message.closingTxHash))
                    return "closingTxHash: string expected";
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                if (!$util.isString(message.remotePubkey))
                    return "remotePubkey: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                if (!$util.isInteger(message.closeHeight))
                    return "closeHeight: integer expected";
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                if (!$util.isInteger(message.settledBalance) && !(message.settledBalance && $util.isInteger(message.settledBalance.low) && $util.isInteger(message.settledBalance.high)))
                    return "settledBalance: integer|Long expected";
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                if (!$util.isInteger(message.timeLockedBalance) && !(message.timeLockedBalance && $util.isInteger(message.timeLockedBalance.low) && $util.isInteger(message.timeLockedBalance.high)))
                    return "timeLockedBalance: integer|Long expected";
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                switch (message.closeType) {
                default:
                    return "closeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelCloseSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         */
        ChannelCloseSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelCloseSummary)
                return object;
            var message = new $root.lnrpc.ChannelCloseSummary();
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chainHash != null)
                message.chainHash = String(object.chainHash);
            if (object.closingTxHash != null)
                message.closingTxHash = String(object.closingTxHash);
            if (object.remotePubkey != null)
                message.remotePubkey = String(object.remotePubkey);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.closeHeight != null)
                message.closeHeight = object.closeHeight >>> 0;
            if (object.settledBalance != null)
                if ($util.Long)
                    (message.settledBalance = $util.Long.fromValue(object.settledBalance)).unsigned = false;
                else if (typeof object.settledBalance === "string")
                    message.settledBalance = parseInt(object.settledBalance, 10);
                else if (typeof object.settledBalance === "number")
                    message.settledBalance = object.settledBalance;
                else if (typeof object.settledBalance === "object")
                    message.settledBalance = new $util.LongBits(object.settledBalance.low >>> 0, object.settledBalance.high >>> 0).toNumber();
            if (object.timeLockedBalance != null)
                if ($util.Long)
                    (message.timeLockedBalance = $util.Long.fromValue(object.timeLockedBalance)).unsigned = false;
                else if (typeof object.timeLockedBalance === "string")
                    message.timeLockedBalance = parseInt(object.timeLockedBalance, 10);
                else if (typeof object.timeLockedBalance === "number")
                    message.timeLockedBalance = object.timeLockedBalance;
                else if (typeof object.timeLockedBalance === "object")
                    message.timeLockedBalance = new $util.LongBits(object.timeLockedBalance.low >>> 0, object.timeLockedBalance.high >>> 0).toNumber();
            switch (object.closeType) {
            case "COOPERATIVE_CLOSE":
            case 0:
                message.closeType = 0;
                break;
            case "LOCAL_FORCE_CLOSE":
            case 1:
                message.closeType = 1;
                break;
            case "REMOTE_FORCE_CLOSE":
            case 2:
                message.closeType = 2;
                break;
            case "BREACH_CLOSE":
            case 3:
                message.closeType = 3;
                break;
            case "FUNDING_CANCELED":
            case 4:
                message.closeType = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.ChannelCloseSummary} message ChannelCloseSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channelPoint = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.chainHash = "";
                object.closingTxHash = "";
                object.remotePubkey = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.closeHeight = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.settledBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settledBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeLockedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeLockedBalance = options.longs === String ? "0" : 0;
                object.closeType = options.enums === String ? "COOPERATIVE_CLOSE" : 0;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                object.chainHash = message.chainHash;
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                object.closingTxHash = message.closingTxHash;
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                object.remotePubkey = message.remotePubkey;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                object.closeHeight = message.closeHeight;
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                if (typeof message.settledBalance === "number")
                    object.settledBalance = options.longs === String ? String(message.settledBalance) : message.settledBalance;
                else
                    object.settledBalance = options.longs === String ? $util.Long.prototype.toString.call(message.settledBalance) : options.longs === Number ? new $util.LongBits(message.settledBalance.low >>> 0, message.settledBalance.high >>> 0).toNumber() : message.settledBalance;
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                if (typeof message.timeLockedBalance === "number")
                    object.timeLockedBalance = options.longs === String ? String(message.timeLockedBalance) : message.timeLockedBalance;
                else
                    object.timeLockedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.timeLockedBalance) : options.longs === Number ? new $util.LongBits(message.timeLockedBalance.low >>> 0, message.timeLockedBalance.high >>> 0).toNumber() : message.timeLockedBalance;
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                object.closeType = options.enums === String ? $root.lnrpc.ChannelCloseSummary.ClosureType[message.closeType] : message.closeType;
            return object;
        };

        /**
         * Converts this ChannelCloseSummary to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ClosureType enum.
         * @name lnrpc.ChannelCloseSummary.ClosureType
         * @enum {string}
         * @property {number} COOPERATIVE_CLOSE=0 COOPERATIVE_CLOSE value
         * @property {number} LOCAL_FORCE_CLOSE=1 LOCAL_FORCE_CLOSE value
         * @property {number} REMOTE_FORCE_CLOSE=2 REMOTE_FORCE_CLOSE value
         * @property {number} BREACH_CLOSE=3 BREACH_CLOSE value
         * @property {number} FUNDING_CANCELED=4 FUNDING_CANCELED value
         */
        ChannelCloseSummary.ClosureType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COOPERATIVE_CLOSE"] = 0;
            values[valuesById[1] = "LOCAL_FORCE_CLOSE"] = 1;
            values[valuesById[2] = "REMOTE_FORCE_CLOSE"] = 2;
            values[valuesById[3] = "BREACH_CLOSE"] = 3;
            values[valuesById[4] = "FUNDING_CANCELED"] = 4;
            return values;
        })();

        return ChannelCloseSummary;
    })();

    lnrpc.ClosedChannelsRequest = (function() {

        /**
         * Properties of a ClosedChannelsRequest.
         * @memberof lnrpc
         * @interface IClosedChannelsRequest
         * @property {boolean|null} [cooperative] ClosedChannelsRequest cooperative
         * @property {boolean|null} [localForce] ClosedChannelsRequest localForce
         * @property {boolean|null} [remoteForce] ClosedChannelsRequest remoteForce
         * @property {boolean|null} [breach] ClosedChannelsRequest breach
         * @property {boolean|null} [fundingCanceled] ClosedChannelsRequest fundingCanceled
         */

        /**
         * Constructs a new ClosedChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelsRequest.
         * @implements IClosedChannelsRequest
         * @constructor
         * @param {lnrpc.IClosedChannelsRequest=} [properties] Properties to set
         */
        function ClosedChannelsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelsRequest cooperative.
         * @member {boolean} cooperative
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.cooperative = false;

        /**
         * ClosedChannelsRequest localForce.
         * @member {boolean} localForce
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.localForce = false;

        /**
         * ClosedChannelsRequest remoteForce.
         * @member {boolean} remoteForce
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.remoteForce = false;

        /**
         * ClosedChannelsRequest breach.
         * @member {boolean} breach
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.breach = false;

        /**
         * ClosedChannelsRequest fundingCanceled.
         * @member {boolean} fundingCanceled
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.fundingCanceled = false;

        /**
         * Creates a new ClosedChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest instance
         */
        ClosedChannelsRequest.create = function create(properties) {
            return new ClosedChannelsRequest(properties);
        };

        /**
         * Encodes the specified ClosedChannelsRequest message. Does not implicitly {@link lnrpc.ClosedChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest} message ClosedChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.cooperative);
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.localForce);
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.remoteForce);
            if (message.breach != null && message.hasOwnProperty("breach"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.breach);
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fundingCanceled);
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest} message ClosedChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cooperative = reader.bool();
                    break;
                case 2:
                    message.localForce = reader.bool();
                    break;
                case 3:
                    message.remoteForce = reader.bool();
                    break;
                case 4:
                    message.breach = reader.bool();
                    break;
                case 5:
                    message.fundingCanceled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelsRequest message.
         * @function verify
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                if (typeof message.cooperative !== "boolean")
                    return "cooperative: boolean expected";
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                if (typeof message.localForce !== "boolean")
                    return "localForce: boolean expected";
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                if (typeof message.remoteForce !== "boolean")
                    return "remoteForce: boolean expected";
            if (message.breach != null && message.hasOwnProperty("breach"))
                if (typeof message.breach !== "boolean")
                    return "breach: boolean expected";
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                if (typeof message.fundingCanceled !== "boolean")
                    return "fundingCanceled: boolean expected";
            return null;
        };

        /**
         * Creates a ClosedChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         */
        ClosedChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelsRequest)
                return object;
            var message = new $root.lnrpc.ClosedChannelsRequest();
            if (object.cooperative != null)
                message.cooperative = Boolean(object.cooperative);
            if (object.localForce != null)
                message.localForce = Boolean(object.localForce);
            if (object.remoteForce != null)
                message.remoteForce = Boolean(object.remoteForce);
            if (object.breach != null)
                message.breach = Boolean(object.breach);
            if (object.fundingCanceled != null)
                message.fundingCanceled = Boolean(object.fundingCanceled);
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.ClosedChannelsRequest} message ClosedChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cooperative = false;
                object.localForce = false;
                object.remoteForce = false;
                object.breach = false;
                object.fundingCanceled = false;
            }
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                object.cooperative = message.cooperative;
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                object.localForce = message.localForce;
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                object.remoteForce = message.remoteForce;
            if (message.breach != null && message.hasOwnProperty("breach"))
                object.breach = message.breach;
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                object.fundingCanceled = message.fundingCanceled;
            return object;
        };

        /**
         * Converts this ClosedChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelsRequest;
    })();

    lnrpc.ClosedChannelsResponse = (function() {

        /**
         * Properties of a ClosedChannelsResponse.
         * @memberof lnrpc
         * @interface IClosedChannelsResponse
         * @property {Array.<lnrpc.IChannelCloseSummary>|null} [channels] ClosedChannelsResponse channels
         */

        /**
         * Constructs a new ClosedChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelsResponse.
         * @implements IClosedChannelsResponse
         * @constructor
         * @param {lnrpc.IClosedChannelsResponse=} [properties] Properties to set
         */
        function ClosedChannelsResponse(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelsResponse channels.
         * @member {Array.<lnrpc.IChannelCloseSummary>} channels
         * @memberof lnrpc.ClosedChannelsResponse
         * @instance
         */
        ClosedChannelsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ClosedChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse instance
         */
        ClosedChannelsResponse.create = function create(properties) {
            return new ClosedChannelsResponse(properties);
        };

        /**
         * Encodes the specified ClosedChannelsResponse message. Does not implicitly {@link lnrpc.ClosedChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse} message ClosedChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.ChannelCloseSummary.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse} message ClosedChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.ChannelCloseSummary.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelsResponse message.
         * @function verify
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (var i = 0; i < message.channels.length; ++i) {
                    var error = $root.lnrpc.ChannelCloseSummary.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClosedChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         */
        ClosedChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelsResponse)
                return object;
            var message = new $root.lnrpc.ClosedChannelsResponse();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.ClosedChannelsResponse.channels: array expected");
                message.channels = [];
                for (var i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.ClosedChannelsResponse.channels: object expected");
                    message.channels[i] = $root.lnrpc.ChannelCloseSummary.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.ClosedChannelsResponse} message ClosedChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (var j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.ChannelCloseSummary.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this ClosedChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelsResponse;
    })();

    lnrpc.Peer = (function() {

        /**
         * Properties of a Peer.
         * @memberof lnrpc
         * @interface IPeer
         * @property {string|null} [pubKey] The identity pubkey of the peer
         * @property {string|null} [address] Network address of the peer; eg `127.0.0.1:10011`
         * @property {number|Long|null} [bytesSent] Bytes of data transmitted to this peer
         * @property {number|Long|null} [bytesRecv] Bytes of data transmitted from this peer
         * @property {number|Long|null} [satSent] Satoshis sent to this peer
         * @property {number|Long|null} [satRecv] Satoshis received from this peer
         * @property {boolean|null} [inbound] A channel is inbound if the counterparty initiated the channel
         * @property {number|Long|null} [pingTime] Ping time to this peer
         */

        /**
         * Constructs a new Peer.
         * @memberof lnrpc
         * @classdesc Represents a Peer.
         * @implements IPeer
         * @constructor
         * @param {lnrpc.IPeer=} [properties] Properties to set
         */
        function Peer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the peer
         * @member {string} pubKey
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.pubKey = "";

        /**
         * Network address of the peer; eg `127.0.0.1:10011`
         * @member {string} address
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.address = "";

        /**
         * Bytes of data transmitted to this peer
         * @member {number|Long} bytesSent
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.bytesSent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Bytes of data transmitted from this peer
         * @member {number|Long} bytesRecv
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.bytesRecv = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Satoshis sent to this peer
         * @member {number|Long} satSent
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.satSent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Satoshis received from this peer
         * @member {number|Long} satRecv
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.satRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A channel is inbound if the counterparty initiated the channel
         * @member {boolean} inbound
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.inbound = false;

        /**
         * Ping time to this peer
         * @member {number|Long} pingTime
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.pingTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Peer instance using the specified properties.
         * @function create
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer=} [properties] Properties to set
         * @returns {lnrpc.Peer} Peer instance
         */
        Peer.create = function create(properties) {
            return new Peer(properties);
        };

        /**
         * Encodes the specified Peer message. Does not implicitly {@link lnrpc.Peer.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer} message Peer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Peer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.bytesSent);
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.bytesRecv);
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.satSent);
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.satRecv);
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.inbound);
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.pingTime);
            return writer;
        };

        /**
         * Encodes the specified Peer message, length delimited. Does not implicitly {@link lnrpc.Peer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer} message Peer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Peer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Peer message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Peer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Peer} Peer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Peer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Peer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                case 4:
                    message.bytesSent = reader.uint64();
                    break;
                case 5:
                    message.bytesRecv = reader.uint64();
                    break;
                case 6:
                    message.satSent = reader.int64();
                    break;
                case 7:
                    message.satRecv = reader.int64();
                    break;
                case 8:
                    message.inbound = reader.bool();
                    break;
                case 9:
                    message.pingTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Peer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Peer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Peer} Peer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Peer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Peer message.
         * @function verify
         * @memberof lnrpc.Peer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Peer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (!$util.isInteger(message.bytesSent) && !(message.bytesSent && $util.isInteger(message.bytesSent.low) && $util.isInteger(message.bytesSent.high)))
                    return "bytesSent: integer|Long expected";
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                if (!$util.isInteger(message.bytesRecv) && !(message.bytesRecv && $util.isInteger(message.bytesRecv.low) && $util.isInteger(message.bytesRecv.high)))
                    return "bytesRecv: integer|Long expected";
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                if (!$util.isInteger(message.satSent) && !(message.satSent && $util.isInteger(message.satSent.low) && $util.isInteger(message.satSent.high)))
                    return "satSent: integer|Long expected";
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                if (!$util.isInteger(message.satRecv) && !(message.satRecv && $util.isInteger(message.satRecv.low) && $util.isInteger(message.satRecv.high)))
                    return "satRecv: integer|Long expected";
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                if (typeof message.inbound !== "boolean")
                    return "inbound: boolean expected";
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                if (!$util.isInteger(message.pingTime) && !(message.pingTime && $util.isInteger(message.pingTime.low) && $util.isInteger(message.pingTime.high)))
                    return "pingTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a Peer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Peer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Peer} Peer
         */
        Peer.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Peer)
                return object;
            var message = new $root.lnrpc.Peer();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.address != null)
                message.address = String(object.address);
            if (object.bytesSent != null)
                if ($util.Long)
                    (message.bytesSent = $util.Long.fromValue(object.bytesSent)).unsigned = true;
                else if (typeof object.bytesSent === "string")
                    message.bytesSent = parseInt(object.bytesSent, 10);
                else if (typeof object.bytesSent === "number")
                    message.bytesSent = object.bytesSent;
                else if (typeof object.bytesSent === "object")
                    message.bytesSent = new $util.LongBits(object.bytesSent.low >>> 0, object.bytesSent.high >>> 0).toNumber(true);
            if (object.bytesRecv != null)
                if ($util.Long)
                    (message.bytesRecv = $util.Long.fromValue(object.bytesRecv)).unsigned = true;
                else if (typeof object.bytesRecv === "string")
                    message.bytesRecv = parseInt(object.bytesRecv, 10);
                else if (typeof object.bytesRecv === "number")
                    message.bytesRecv = object.bytesRecv;
                else if (typeof object.bytesRecv === "object")
                    message.bytesRecv = new $util.LongBits(object.bytesRecv.low >>> 0, object.bytesRecv.high >>> 0).toNumber(true);
            if (object.satSent != null)
                if ($util.Long)
                    (message.satSent = $util.Long.fromValue(object.satSent)).unsigned = false;
                else if (typeof object.satSent === "string")
                    message.satSent = parseInt(object.satSent, 10);
                else if (typeof object.satSent === "number")
                    message.satSent = object.satSent;
                else if (typeof object.satSent === "object")
                    message.satSent = new $util.LongBits(object.satSent.low >>> 0, object.satSent.high >>> 0).toNumber();
            if (object.satRecv != null)
                if ($util.Long)
                    (message.satRecv = $util.Long.fromValue(object.satRecv)).unsigned = false;
                else if (typeof object.satRecv === "string")
                    message.satRecv = parseInt(object.satRecv, 10);
                else if (typeof object.satRecv === "number")
                    message.satRecv = object.satRecv;
                else if (typeof object.satRecv === "object")
                    message.satRecv = new $util.LongBits(object.satRecv.low >>> 0, object.satRecv.high >>> 0).toNumber();
            if (object.inbound != null)
                message.inbound = Boolean(object.inbound);
            if (object.pingTime != null)
                if ($util.Long)
                    (message.pingTime = $util.Long.fromValue(object.pingTime)).unsigned = false;
                else if (typeof object.pingTime === "string")
                    message.pingTime = parseInt(object.pingTime, 10);
                else if (typeof object.pingTime === "number")
                    message.pingTime = object.pingTime;
                else if (typeof object.pingTime === "object")
                    message.pingTime = new $util.LongBits(object.pingTime.low >>> 0, object.pingTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Peer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.Peer} message Peer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Peer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pubKey = "";
                object.address = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bytesSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bytesRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesRecv = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.satSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.satRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satRecv = options.longs === String ? "0" : 0;
                object.inbound = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.pingTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pingTime = options.longs === String ? "0" : 0;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (typeof message.bytesSent === "number")
                    object.bytesSent = options.longs === String ? String(message.bytesSent) : message.bytesSent;
                else
                    object.bytesSent = options.longs === String ? $util.Long.prototype.toString.call(message.bytesSent) : options.longs === Number ? new $util.LongBits(message.bytesSent.low >>> 0, message.bytesSent.high >>> 0).toNumber(true) : message.bytesSent;
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                if (typeof message.bytesRecv === "number")
                    object.bytesRecv = options.longs === String ? String(message.bytesRecv) : message.bytesRecv;
                else
                    object.bytesRecv = options.longs === String ? $util.Long.prototype.toString.call(message.bytesRecv) : options.longs === Number ? new $util.LongBits(message.bytesRecv.low >>> 0, message.bytesRecv.high >>> 0).toNumber(true) : message.bytesRecv;
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                if (typeof message.satSent === "number")
                    object.satSent = options.longs === String ? String(message.satSent) : message.satSent;
                else
                    object.satSent = options.longs === String ? $util.Long.prototype.toString.call(message.satSent) : options.longs === Number ? new $util.LongBits(message.satSent.low >>> 0, message.satSent.high >>> 0).toNumber() : message.satSent;
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                if (typeof message.satRecv === "number")
                    object.satRecv = options.longs === String ? String(message.satRecv) : message.satRecv;
                else
                    object.satRecv = options.longs === String ? $util.Long.prototype.toString.call(message.satRecv) : options.longs === Number ? new $util.LongBits(message.satRecv.low >>> 0, message.satRecv.high >>> 0).toNumber() : message.satRecv;
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                object.inbound = message.inbound;
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                if (typeof message.pingTime === "number")
                    object.pingTime = options.longs === String ? String(message.pingTime) : message.pingTime;
                else
                    object.pingTime = options.longs === String ? $util.Long.prototype.toString.call(message.pingTime) : options.longs === Number ? new $util.LongBits(message.pingTime.low >>> 0, message.pingTime.high >>> 0).toNumber() : message.pingTime;
            return object;
        };

        /**
         * Converts this Peer to JSON.
         * @function toJSON
         * @memberof lnrpc.Peer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Peer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Peer;
    })();

    lnrpc.ListPeersRequest = (function() {

        /**
         * Properties of a ListPeersRequest.
         * @memberof lnrpc
         * @interface IListPeersRequest
         */

        /**
         * Constructs a new ListPeersRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPeersRequest.
         * @implements IListPeersRequest
         * @constructor
         * @param {lnrpc.IListPeersRequest=} [properties] Properties to set
         */
        function ListPeersRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ListPeersRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest instance
         */
        ListPeersRequest.create = function create(properties) {
            return new ListPeersRequest(properties);
        };

        /**
         * Encodes the specified ListPeersRequest message. Does not implicitly {@link lnrpc.ListPeersRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest} message ListPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ListPeersRequest message, length delimited. Does not implicitly {@link lnrpc.ListPeersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest} message ListPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPeersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPeersRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPeersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPeersRequest message.
         * @function verify
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPeersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ListPeersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         */
        ListPeersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPeersRequest)
                return object;
            return new $root.lnrpc.ListPeersRequest();
        };

        /**
         * Creates a plain object from a ListPeersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.ListPeersRequest} message ListPeersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPeersRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ListPeersRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPeersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPeersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPeersRequest;
    })();

    lnrpc.ListPeersResponse = (function() {

        /**
         * Properties of a ListPeersResponse.
         * @memberof lnrpc
         * @interface IListPeersResponse
         * @property {Array.<lnrpc.IPeer>|null} [peers] The list of currently connected peers
         */

        /**
         * Constructs a new ListPeersResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPeersResponse.
         * @implements IListPeersResponse
         * @constructor
         * @param {lnrpc.IListPeersResponse=} [properties] Properties to set
         */
        function ListPeersResponse(properties) {
            this.peers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of currently connected peers
         * @member {Array.<lnrpc.IPeer>} peers
         * @memberof lnrpc.ListPeersResponse
         * @instance
         */
        ListPeersResponse.prototype.peers = $util.emptyArray;

        /**
         * Creates a new ListPeersResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse instance
         */
        ListPeersResponse.create = function create(properties) {
            return new ListPeersResponse(properties);
        };

        /**
         * Encodes the specified ListPeersResponse message. Does not implicitly {@link lnrpc.ListPeersResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse} message ListPeersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peers != null && message.peers.length)
                for (var i = 0; i < message.peers.length; ++i)
                    $root.lnrpc.Peer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListPeersResponse message, length delimited. Does not implicitly {@link lnrpc.ListPeersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse} message ListPeersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPeersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPeersResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.peers && message.peers.length))
                        message.peers = [];
                    message.peers.push($root.lnrpc.Peer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPeersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPeersResponse message.
         * @function verify
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPeersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peers != null && message.hasOwnProperty("peers")) {
                if (!Array.isArray(message.peers))
                    return "peers: array expected";
                for (var i = 0; i < message.peers.length; ++i) {
                    var error = $root.lnrpc.Peer.verify(message.peers[i]);
                    if (error)
                        return "peers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPeersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         */
        ListPeersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPeersResponse)
                return object;
            var message = new $root.lnrpc.ListPeersResponse();
            if (object.peers) {
                if (!Array.isArray(object.peers))
                    throw TypeError(".lnrpc.ListPeersResponse.peers: array expected");
                message.peers = [];
                for (var i = 0; i < object.peers.length; ++i) {
                    if (typeof object.peers[i] !== "object")
                        throw TypeError(".lnrpc.ListPeersResponse.peers: object expected");
                    message.peers[i] = $root.lnrpc.Peer.fromObject(object.peers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPeersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.ListPeersResponse} message ListPeersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPeersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peers = [];
            if (message.peers && message.peers.length) {
                object.peers = [];
                for (var j = 0; j < message.peers.length; ++j)
                    object.peers[j] = $root.lnrpc.Peer.toObject(message.peers[j], options);
            }
            return object;
        };

        /**
         * Converts this ListPeersResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPeersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPeersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPeersResponse;
    })();

    lnrpc.GetInfoRequest = (function() {

        /**
         * Properties of a GetInfoRequest.
         * @memberof lnrpc
         * @interface IGetInfoRequest
         */

        /**
         * Constructs a new GetInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetInfoRequest.
         * @implements IGetInfoRequest
         * @constructor
         * @param {lnrpc.IGetInfoRequest=} [properties] Properties to set
         */
        function GetInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest instance
         */
        GetInfoRequest.create = function create(properties) {
            return new GetInfoRequest(properties);
        };

        /**
         * Encodes the specified GetInfoRequest message. Does not implicitly {@link lnrpc.GetInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest} message GetInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetInfoRequest message, length delimited. Does not implicitly {@link lnrpc.GetInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest} message GetInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetInfoRequest message.
         * @function verify
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         */
        GetInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetInfoRequest)
                return object;
            return new $root.lnrpc.GetInfoRequest();
        };

        /**
         * Creates a plain object from a GetInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.GetInfoRequest} message GetInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetInfoRequest;
    })();

    lnrpc.GetInfoResponse = (function() {

        /**
         * Properties of a GetInfoResponse.
         * @memberof lnrpc
         * @interface IGetInfoResponse
         * @property {string|null} [identityPubkey] The identity pubkey of the current node.
         * @property {string|null} [alias] If applicable, the alias of the current node, e.g. "bob"
         * @property {number|null} [numPendingChannels] Number of pending channels
         * @property {number|null} [numActiveChannels] Number of active channels
         * @property {number|null} [numPeers] Number of peers
         * @property {number|null} [blockHeight] The node's current view of the height of the best block
         * @property {string|null} [blockHash] The node's current view of the hash of the best block
         * @property {boolean|null} [syncedToChain] Whether the wallet's view is synced to the main chain
         * @property {boolean|null} [testnet] Whether the current node is connected to testnet
         * @property {Array.<string>|null} [chains] A list of active chains the node is connected to
         * @property {Array.<string>|null} [uris] The URIs of the current node.
         * @property {number|Long|null} [bestHeaderTimestamp] Timestamp of the block best known to the wallet
         * @property {string|null} [version] The version of the LND software that the node is running.
         */

        /**
         * Constructs a new GetInfoResponse.
         * @memberof lnrpc
         * @classdesc Represents a GetInfoResponse.
         * @implements IGetInfoResponse
         * @constructor
         * @param {lnrpc.IGetInfoResponse=} [properties] Properties to set
         */
        function GetInfoResponse(properties) {
            this.chains = [];
            this.uris = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the current node.
         * @member {string} identityPubkey
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.identityPubkey = "";

        /**
         * If applicable, the alias of the current node, e.g. "bob"
         * @member {string} alias
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.alias = "";

        /**
         * Number of pending channels
         * @member {number} numPendingChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numPendingChannels = 0;

        /**
         * Number of active channels
         * @member {number} numActiveChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numActiveChannels = 0;

        /**
         * Number of peers
         * @member {number} numPeers
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numPeers = 0;

        /**
         * The node's current view of the height of the best block
         * @member {number} blockHeight
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.blockHeight = 0;

        /**
         * The node's current view of the hash of the best block
         * @member {string} blockHash
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.blockHash = "";

        /**
         * Whether the wallet's view is synced to the main chain
         * @member {boolean} syncedToChain
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.syncedToChain = false;

        /**
         * Whether the current node is connected to testnet
         * @member {boolean} testnet
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.testnet = false;

        /**
         * A list of active chains the node is connected to
         * @member {Array.<string>} chains
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.chains = $util.emptyArray;

        /**
         * The URIs of the current node.
         * @member {Array.<string>} uris
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.uris = $util.emptyArray;

        /**
         * Timestamp of the block best known to the wallet
         * @member {number|Long} bestHeaderTimestamp
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.bestHeaderTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The version of the LND software that the node is running.
         * @member {string} version
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.version = "";

        /**
         * Creates a new GetInfoResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse=} [properties] Properties to set
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse instance
         */
        GetInfoResponse.create = function create(properties) {
            return new GetInfoResponse(properties);
        };

        /**
         * Encodes the specified GetInfoResponse message. Does not implicitly {@link lnrpc.GetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.identityPubkey);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numPendingChannels);
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numActiveChannels);
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numPeers);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.blockHeight);
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.blockHash);
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.syncedToChain);
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.testnet);
            if (message.chains != null && message.chains.length)
                for (var i = 0; i < message.chains.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.chains[i]);
            if (message.uris != null && message.uris.length)
                for (var i = 0; i < message.uris.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.uris[i]);
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.bestHeaderTimestamp);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.version);
            return writer;
        };

        /**
         * Encodes the specified GetInfoResponse message, length delimited. Does not implicitly {@link lnrpc.GetInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identityPubkey = reader.string();
                    break;
                case 2:
                    message.alias = reader.string();
                    break;
                case 3:
                    message.numPendingChannels = reader.uint32();
                    break;
                case 4:
                    message.numActiveChannels = reader.uint32();
                    break;
                case 5:
                    message.numPeers = reader.uint32();
                    break;
                case 6:
                    message.blockHeight = reader.uint32();
                    break;
                case 8:
                    message.blockHash = reader.string();
                    break;
                case 9:
                    message.syncedToChain = reader.bool();
                    break;
                case 10:
                    message.testnet = reader.bool();
                    break;
                case 11:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push(reader.string());
                    break;
                case 12:
                    if (!(message.uris && message.uris.length))
                        message.uris = [];
                    message.uris.push(reader.string());
                    break;
                case 13:
                    message.bestHeaderTimestamp = reader.int64();
                    break;
                case 14:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetInfoResponse message.
         * @function verify
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                if (!$util.isString(message.identityPubkey))
                    return "identityPubkey: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                if (!$util.isInteger(message.numPendingChannels))
                    return "numPendingChannels: integer expected";
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                if (!$util.isInteger(message.numActiveChannels))
                    return "numActiveChannels: integer expected";
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                if (!$util.isInteger(message.numPeers))
                    return "numPeers: integer expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                if (typeof message.syncedToChain !== "boolean")
                    return "syncedToChain: boolean expected";
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                if (typeof message.testnet !== "boolean")
                    return "testnet: boolean expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (var i = 0; i < message.chains.length; ++i)
                    if (!$util.isString(message.chains[i]))
                        return "chains: string[] expected";
            }
            if (message.uris != null && message.hasOwnProperty("uris")) {
                if (!Array.isArray(message.uris))
                    return "uris: array expected";
                for (var i = 0; i < message.uris.length; ++i)
                    if (!$util.isString(message.uris[i]))
                        return "uris: string[] expected";
            }
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                if (!$util.isInteger(message.bestHeaderTimestamp) && !(message.bestHeaderTimestamp && $util.isInteger(message.bestHeaderTimestamp.low) && $util.isInteger(message.bestHeaderTimestamp.high)))
                    return "bestHeaderTimestamp: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            return null;
        };

        /**
         * Creates a GetInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         */
        GetInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetInfoResponse)
                return object;
            var message = new $root.lnrpc.GetInfoResponse();
            if (object.identityPubkey != null)
                message.identityPubkey = String(object.identityPubkey);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.numPendingChannels != null)
                message.numPendingChannels = object.numPendingChannels >>> 0;
            if (object.numActiveChannels != null)
                message.numActiveChannels = object.numActiveChannels >>> 0;
            if (object.numPeers != null)
                message.numPeers = object.numPeers >>> 0;
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight >>> 0;
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.syncedToChain != null)
                message.syncedToChain = Boolean(object.syncedToChain);
            if (object.testnet != null)
                message.testnet = Boolean(object.testnet);
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".lnrpc.GetInfoResponse.chains: array expected");
                message.chains = [];
                for (var i = 0; i < object.chains.length; ++i)
                    message.chains[i] = String(object.chains[i]);
            }
            if (object.uris) {
                if (!Array.isArray(object.uris))
                    throw TypeError(".lnrpc.GetInfoResponse.uris: array expected");
                message.uris = [];
                for (var i = 0; i < object.uris.length; ++i)
                    message.uris[i] = String(object.uris[i]);
            }
            if (object.bestHeaderTimestamp != null)
                if ($util.Long)
                    (message.bestHeaderTimestamp = $util.Long.fromValue(object.bestHeaderTimestamp)).unsigned = false;
                else if (typeof object.bestHeaderTimestamp === "string")
                    message.bestHeaderTimestamp = parseInt(object.bestHeaderTimestamp, 10);
                else if (typeof object.bestHeaderTimestamp === "number")
                    message.bestHeaderTimestamp = object.bestHeaderTimestamp;
                else if (typeof object.bestHeaderTimestamp === "object")
                    message.bestHeaderTimestamp = new $util.LongBits(object.bestHeaderTimestamp.low >>> 0, object.bestHeaderTimestamp.high >>> 0).toNumber();
            if (object.version != null)
                message.version = String(object.version);
            return message;
        };

        /**
         * Creates a plain object from a GetInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.GetInfoResponse} message GetInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.chains = [];
                object.uris = [];
            }
            if (options.defaults) {
                object.identityPubkey = "";
                object.alias = "";
                object.numPendingChannels = 0;
                object.numActiveChannels = 0;
                object.numPeers = 0;
                object.blockHeight = 0;
                object.blockHash = "";
                object.syncedToChain = false;
                object.testnet = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bestHeaderTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bestHeaderTimestamp = options.longs === String ? "0" : 0;
                object.version = "";
            }
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                object.identityPubkey = message.identityPubkey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                object.numPendingChannels = message.numPendingChannels;
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                object.numActiveChannels = message.numActiveChannels;
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                object.numPeers = message.numPeers;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                object.syncedToChain = message.syncedToChain;
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                object.testnet = message.testnet;
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (var j = 0; j < message.chains.length; ++j)
                    object.chains[j] = message.chains[j];
            }
            if (message.uris && message.uris.length) {
                object.uris = [];
                for (var j = 0; j < message.uris.length; ++j)
                    object.uris[j] = message.uris[j];
            }
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                if (typeof message.bestHeaderTimestamp === "number")
                    object.bestHeaderTimestamp = options.longs === String ? String(message.bestHeaderTimestamp) : message.bestHeaderTimestamp;
                else
                    object.bestHeaderTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.bestHeaderTimestamp) : options.longs === Number ? new $util.LongBits(message.bestHeaderTimestamp.low >>> 0, message.bestHeaderTimestamp.high >>> 0).toNumber() : message.bestHeaderTimestamp;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this GetInfoResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.GetInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetInfoResponse;
    })();

    lnrpc.ConfirmationUpdate = (function() {

        /**
         * Properties of a ConfirmationUpdate.
         * @memberof lnrpc
         * @interface IConfirmationUpdate
         * @property {Uint8Array|null} [blockSha] ConfirmationUpdate blockSha
         * @property {number|null} [blockHeight] ConfirmationUpdate blockHeight
         * @property {number|null} [numConfsLeft] ConfirmationUpdate numConfsLeft
         */

        /**
         * Constructs a new ConfirmationUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ConfirmationUpdate.
         * @implements IConfirmationUpdate
         * @constructor
         * @param {lnrpc.IConfirmationUpdate=} [properties] Properties to set
         */
        function ConfirmationUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfirmationUpdate blockSha.
         * @member {Uint8Array} blockSha
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.blockSha = $util.newBuffer([]);

        /**
         * ConfirmationUpdate blockHeight.
         * @member {number} blockHeight
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.blockHeight = 0;

        /**
         * ConfirmationUpdate numConfsLeft.
         * @member {number} numConfsLeft
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.numConfsLeft = 0;

        /**
         * Creates a new ConfirmationUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate=} [properties] Properties to set
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate instance
         */
        ConfirmationUpdate.create = function create(properties) {
            return new ConfirmationUpdate(properties);
        };

        /**
         * Encodes the specified ConfirmationUpdate message. Does not implicitly {@link lnrpc.ConfirmationUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate} message ConfirmationUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfirmationUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockSha);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.blockHeight);
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numConfsLeft);
            return writer;
        };

        /**
         * Encodes the specified ConfirmationUpdate message, length delimited. Does not implicitly {@link lnrpc.ConfirmationUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate} message ConfirmationUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfirmationUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfirmationUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfirmationUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConfirmationUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSha = reader.bytes();
                    break;
                case 2:
                    message.blockHeight = reader.int32();
                    break;
                case 3:
                    message.numConfsLeft = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfirmationUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfirmationUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfirmationUpdate message.
         * @function verify
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfirmationUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                if (!(message.blockSha && typeof message.blockSha.length === "number" || $util.isString(message.blockSha)))
                    return "blockSha: buffer expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                if (!$util.isInteger(message.numConfsLeft))
                    return "numConfsLeft: integer expected";
            return null;
        };

        /**
         * Creates a ConfirmationUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         */
        ConfirmationUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConfirmationUpdate)
                return object;
            var message = new $root.lnrpc.ConfirmationUpdate();
            if (object.blockSha != null)
                if (typeof object.blockSha === "string")
                    $util.base64.decode(object.blockSha, message.blockSha = $util.newBuffer($util.base64.length(object.blockSha)), 0);
                else if (object.blockSha.length)
                    message.blockSha = object.blockSha;
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight | 0;
            if (object.numConfsLeft != null)
                message.numConfsLeft = object.numConfsLeft >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ConfirmationUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.ConfirmationUpdate} message ConfirmationUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfirmationUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockSha = "";
                else {
                    object.blockSha = [];
                    if (options.bytes !== Array)
                        object.blockSha = $util.newBuffer(object.blockSha);
                }
                object.blockHeight = 0;
                object.numConfsLeft = 0;
            }
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                object.blockSha = options.bytes === String ? $util.base64.encode(message.blockSha, 0, message.blockSha.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockSha) : message.blockSha;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                object.numConfsLeft = message.numConfsLeft;
            return object;
        };

        /**
         * Converts this ConfirmationUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfirmationUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfirmationUpdate;
    })();

    lnrpc.ChannelOpenUpdate = (function() {

        /**
         * Properties of a ChannelOpenUpdate.
         * @memberof lnrpc
         * @interface IChannelOpenUpdate
         * @property {lnrpc.IChannelPoint|null} [channelPoint] ChannelOpenUpdate channelPoint
         */

        /**
         * Constructs a new ChannelOpenUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelOpenUpdate.
         * @implements IChannelOpenUpdate
         * @constructor
         * @param {lnrpc.IChannelOpenUpdate=} [properties] Properties to set
         */
        function ChannelOpenUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelOpenUpdate channelPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.ChannelOpenUpdate
         * @instance
         */
        ChannelOpenUpdate.prototype.channelPoint = null;

        /**
         * Creates a new ChannelOpenUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate instance
         */
        ChannelOpenUpdate.create = function create(properties) {
            return new ChannelOpenUpdate(properties);
        };

        /**
         * Encodes the specified ChannelOpenUpdate message. Does not implicitly {@link lnrpc.ChannelOpenUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate} message ChannelOpenUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelOpenUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelOpenUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate} message ChannelOpenUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelOpenUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelOpenUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelOpenUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelOpenUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelOpenUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                var error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelOpenUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         */
        ChannelOpenUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelOpenUpdate)
                return object;
            var message = new $root.lnrpc.ChannelOpenUpdate();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.ChannelOpenUpdate.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelOpenUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.ChannelOpenUpdate} message ChannelOpenUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelOpenUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.channelPoint = null;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            return object;
        };

        /**
         * Converts this ChannelOpenUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelOpenUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelOpenUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelOpenUpdate;
    })();

    lnrpc.ChannelCloseUpdate = (function() {

        /**
         * Properties of a ChannelCloseUpdate.
         * @memberof lnrpc
         * @interface IChannelCloseUpdate
         * @property {Uint8Array|null} [closingTxid] ChannelCloseUpdate closingTxid
         * @property {boolean|null} [success] ChannelCloseUpdate success
         */

        /**
         * Constructs a new ChannelCloseUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelCloseUpdate.
         * @implements IChannelCloseUpdate
         * @constructor
         * @param {lnrpc.IChannelCloseUpdate=} [properties] Properties to set
         */
        function ChannelCloseUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelCloseUpdate closingTxid.
         * @member {Uint8Array} closingTxid
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         */
        ChannelCloseUpdate.prototype.closingTxid = $util.newBuffer([]);

        /**
         * ChannelCloseUpdate success.
         * @member {boolean} success
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         */
        ChannelCloseUpdate.prototype.success = false;

        /**
         * Creates a new ChannelCloseUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate instance
         */
        ChannelCloseUpdate.create = function create(properties) {
            return new ChannelCloseUpdate(properties);
        };

        /**
         * Encodes the specified ChannelCloseUpdate message. Does not implicitly {@link lnrpc.ChannelCloseUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate} message ChannelCloseUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.closingTxid);
            if (message.success != null && message.hasOwnProperty("success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelCloseUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate} message ChannelCloseUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelCloseUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.closingTxid = reader.bytes();
                    break;
                case 2:
                    message.success = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                if (!(message.closingTxid && typeof message.closingTxid.length === "number" || $util.isString(message.closingTxid)))
                    return "closingTxid: buffer expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ChannelCloseUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         */
        ChannelCloseUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelCloseUpdate)
                return object;
            var message = new $root.lnrpc.ChannelCloseUpdate();
            if (object.closingTxid != null)
                if (typeof object.closingTxid === "string")
                    $util.base64.decode(object.closingTxid, message.closingTxid = $util.newBuffer($util.base64.length(object.closingTxid)), 0);
                else if (object.closingTxid.length)
                    message.closingTxid = object.closingTxid;
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.ChannelCloseUpdate} message ChannelCloseUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.closingTxid = "";
                else {
                    object.closingTxid = [];
                    if (options.bytes !== Array)
                        object.closingTxid = $util.newBuffer(object.closingTxid);
                }
                object.success = false;
            }
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                object.closingTxid = options.bytes === String ? $util.base64.encode(message.closingTxid, 0, message.closingTxid.length) : options.bytes === Array ? Array.prototype.slice.call(message.closingTxid) : message.closingTxid;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ChannelCloseUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelCloseUpdate;
    })();

    lnrpc.CloseChannelRequest = (function() {

        /**
         * Properties of a CloseChannelRequest.
         * @memberof lnrpc
         * @interface ICloseChannelRequest
         * @property {lnrpc.IChannelPoint|null} [channelPoint] The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @property {boolean|null} [force] If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
         * @property {number|null} [targetConf] The target number of blocks that the closure transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
         */

        /**
         * Constructs a new CloseChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents a CloseChannelRequest.
         * @implements ICloseChannelRequest
         * @constructor
         * @param {lnrpc.ICloseChannelRequest=} [properties] Properties to set
         */
        function CloseChannelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.channelPoint = null;

        /**
         * If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
         * @member {boolean} force
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.force = false;

        /**
         * The target number of blocks that the closure transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CloseChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest instance
         */
        CloseChannelRequest.create = function create(properties) {
            return new CloseChannelRequest(properties);
        };

        /**
         * Encodes the specified CloseChannelRequest message. Does not implicitly {@link lnrpc.CloseChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest} message CloseChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.force != null && message.hasOwnProperty("force"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.force);
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.satPerByte);
            return writer;
        };

        /**
         * Encodes the specified CloseChannelRequest message, length delimited. Does not implicitly {@link lnrpc.CloseChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest} message CloseChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.CloseChannelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.force = reader.bool();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 4:
                    message.satPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseChannelRequest message.
         * @function verify
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                var error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates a CloseChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         */
        CloseChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.CloseChannelRequest)
                return object;
            var message = new $root.lnrpc.CloseChannelRequest();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.CloseChannelRequest.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CloseChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.CloseChannelRequest} message CloseChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channelPoint = null;
                object.force = false;
                object.targetConf = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            return object;
        };

        /**
         * Converts this CloseChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseChannelRequest;
    })();

    lnrpc.CloseStatusUpdate = (function() {

        /**
         * Properties of a CloseStatusUpdate.
         * @memberof lnrpc
         * @interface ICloseStatusUpdate
         * @property {lnrpc.IPendingUpdate|null} [closePending] CloseStatusUpdate closePending
         * @property {lnrpc.IConfirmationUpdate|null} [confirmation] CloseStatusUpdate confirmation
         * @property {lnrpc.IChannelCloseUpdate|null} [chanClose] CloseStatusUpdate chanClose
         */

        /**
         * Constructs a new CloseStatusUpdate.
         * @memberof lnrpc
         * @classdesc Represents a CloseStatusUpdate.
         * @implements ICloseStatusUpdate
         * @constructor
         * @param {lnrpc.ICloseStatusUpdate=} [properties] Properties to set
         */
        function CloseStatusUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseStatusUpdate closePending.
         * @member {lnrpc.IPendingUpdate|null|undefined} closePending
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.closePending = null;

        /**
         * CloseStatusUpdate confirmation.
         * @member {lnrpc.IConfirmationUpdate|null|undefined} confirmation
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.confirmation = null;

        /**
         * CloseStatusUpdate chanClose.
         * @member {lnrpc.IChannelCloseUpdate|null|undefined} chanClose
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.chanClose = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * CloseStatusUpdate update.
         * @member {"closePending"|"confirmation"|"chanClose"|undefined} update
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        Object.defineProperty(CloseStatusUpdate.prototype, "update", {
            get: $util.oneOfGetter($oneOfFields = ["closePending", "confirmation", "chanClose"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CloseStatusUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate=} [properties] Properties to set
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate instance
         */
        CloseStatusUpdate.create = function create(properties) {
            return new CloseStatusUpdate(properties);
        };

        /**
         * Encodes the specified CloseStatusUpdate message. Does not implicitly {@link lnrpc.CloseStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate} message CloseStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closePending != null && message.hasOwnProperty("closePending"))
                $root.lnrpc.PendingUpdate.encode(message.closePending, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.confirmation != null && message.hasOwnProperty("confirmation"))
                $root.lnrpc.ConfirmationUpdate.encode(message.confirmation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.chanClose != null && message.hasOwnProperty("chanClose"))
                $root.lnrpc.ChannelCloseUpdate.encode(message.chanClose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CloseStatusUpdate message, length delimited. Does not implicitly {@link lnrpc.CloseStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate} message CloseStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.CloseStatusUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.closePending = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.confirmation = $root.lnrpc.ConfirmationUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chanClose = $root.lnrpc.ChannelCloseUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseStatusUpdate message.
         * @function verify
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.closePending != null && message.hasOwnProperty("closePending")) {
                properties.update = 1;
                {
                    var error = $root.lnrpc.PendingUpdate.verify(message.closePending);
                    if (error)
                        return "closePending." + error;
                }
            }
            if (message.confirmation != null && message.hasOwnProperty("confirmation")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    var error = $root.lnrpc.ConfirmationUpdate.verify(message.confirmation);
                    if (error)
                        return "confirmation." + error;
                }
            }
            if (message.chanClose != null && message.hasOwnProperty("chanClose")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    var error = $root.lnrpc.ChannelCloseUpdate.verify(message.chanClose);
                    if (error)
                        return "chanClose." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CloseStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         */
        CloseStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.CloseStatusUpdate)
                return object;
            var message = new $root.lnrpc.CloseStatusUpdate();
            if (object.closePending != null) {
                if (typeof object.closePending !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.closePending: object expected");
                message.closePending = $root.lnrpc.PendingUpdate.fromObject(object.closePending);
            }
            if (object.confirmation != null) {
                if (typeof object.confirmation !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.confirmation: object expected");
                message.confirmation = $root.lnrpc.ConfirmationUpdate.fromObject(object.confirmation);
            }
            if (object.chanClose != null) {
                if (typeof object.chanClose !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.chanClose: object expected");
                message.chanClose = $root.lnrpc.ChannelCloseUpdate.fromObject(object.chanClose);
            }
            return message;
        };

        /**
         * Creates a plain object from a CloseStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.CloseStatusUpdate} message CloseStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.closePending != null && message.hasOwnProperty("closePending")) {
                object.closePending = $root.lnrpc.PendingUpdate.toObject(message.closePending, options);
                if (options.oneofs)
                    object.update = "closePending";
            }
            if (message.confirmation != null && message.hasOwnProperty("confirmation")) {
                object.confirmation = $root.lnrpc.ConfirmationUpdate.toObject(message.confirmation, options);
                if (options.oneofs)
                    object.update = "confirmation";
            }
            if (message.chanClose != null && message.hasOwnProperty("chanClose")) {
                object.chanClose = $root.lnrpc.ChannelCloseUpdate.toObject(message.chanClose, options);
                if (options.oneofs)
                    object.update = "chanClose";
            }
            return object;
        };

        /**
         * Converts this CloseStatusUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseStatusUpdate;
    })();

    lnrpc.PendingUpdate = (function() {

        /**
         * Properties of a PendingUpdate.
         * @memberof lnrpc
         * @interface IPendingUpdate
         * @property {Uint8Array|null} [txid] PendingUpdate txid
         * @property {number|null} [outputIndex] PendingUpdate outputIndex
         */

        /**
         * Constructs a new PendingUpdate.
         * @memberof lnrpc
         * @classdesc Represents a PendingUpdate.
         * @implements IPendingUpdate
         * @constructor
         * @param {lnrpc.IPendingUpdate=} [properties] Properties to set
         */
        function PendingUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingUpdate txid.
         * @member {Uint8Array} txid
         * @memberof lnrpc.PendingUpdate
         * @instance
         */
        PendingUpdate.prototype.txid = $util.newBuffer([]);

        /**
         * PendingUpdate outputIndex.
         * @member {number} outputIndex
         * @memberof lnrpc.PendingUpdate
         * @instance
         */
        PendingUpdate.prototype.outputIndex = 0;

        /**
         * Creates a new PendingUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate=} [properties] Properties to set
         * @returns {lnrpc.PendingUpdate} PendingUpdate instance
         */
        PendingUpdate.create = function create(properties) {
            return new PendingUpdate(properties);
        };

        /**
         * Encodes the specified PendingUpdate message. Does not implicitly {@link lnrpc.PendingUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate} message PendingUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txid);
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified PendingUpdate message, length delimited. Does not implicitly {@link lnrpc.PendingUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate} message PendingUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                case 2:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingUpdate message.
         * @function verify
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!(message.txid && typeof message.txid.length === "number" || $util.isString(message.txid)))
                    return "txid: buffer expected";
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates a PendingUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         */
        PendingUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingUpdate)
                return object;
            var message = new $root.lnrpc.PendingUpdate();
            if (object.txid != null)
                if (typeof object.txid === "string")
                    $util.base64.decode(object.txid, message.txid = $util.newBuffer($util.base64.length(object.txid)), 0);
                else if (object.txid.length)
                    message.txid = object.txid;
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendingUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.PendingUpdate} message PendingUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.txid = "";
                else {
                    object.txid = [];
                    if (options.bytes !== Array)
                        object.txid = $util.newBuffer(object.txid);
                }
                object.outputIndex = 0;
            }
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = options.bytes === String ? $util.base64.encode(message.txid, 0, message.txid.length) : options.bytes === Array ? Array.prototype.slice.call(message.txid) : message.txid;
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this PendingUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingUpdate;
    })();

    lnrpc.OpenChannelRequest = (function() {

        /**
         * Properties of an OpenChannelRequest.
         * @memberof lnrpc
         * @interface IOpenChannelRequest
         * @property {Uint8Array|null} [nodePubkey] The pubkey of the node to open a channel with
         * @property {string|null} [nodePubkeyString] The hex encoded pubkey of the node to open a channel with
         * @property {number|Long|null} [localFundingAmount] The number of satoshis the wallet should commit to the channel
         * @property {number|Long|null} [pushSat] The number of satoshis to push to the remote side as part of the initial commitment state
         * @property {number|null} [targetConf] The target number of blocks that the funding transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
         * @property {boolean|null} ["private"] Whether this channel should be private, not announced to the greater network.
         * @property {number|Long|null} [minHtlcMsat] The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
         * @property {number|null} [remoteCsvDelay] The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
         */

        /**
         * Constructs a new OpenChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents an OpenChannelRequest.
         * @implements IOpenChannelRequest
         * @constructor
         * @param {lnrpc.IOpenChannelRequest=} [properties] Properties to set
         */
        function OpenChannelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The pubkey of the node to open a channel with
         * @member {Uint8Array} nodePubkey
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.nodePubkey = $util.newBuffer([]);

        /**
         * The hex encoded pubkey of the node to open a channel with
         * @member {string} nodePubkeyString
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.nodePubkeyString = "";

        /**
         * The number of satoshis the wallet should commit to the channel
         * @member {number|Long} localFundingAmount
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.localFundingAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The number of satoshis to push to the remote side as part of the initial commitment state
         * @member {number|Long} pushSat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.pushSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The target number of blocks that the funding transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Whether this channel should be private, not announced to the greater network.
         * @member {boolean} private
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype["private"] = false;

        /**
         * The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
         * @member {number|Long} minHtlcMsat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.minHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
         * @member {number} remoteCsvDelay
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.remoteCsvDelay = 0;

        /**
         * Creates a new OpenChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest instance
         */
        OpenChannelRequest.create = function create(properties) {
            return new OpenChannelRequest(properties);
        };

        /**
         * Encodes the specified OpenChannelRequest message. Does not implicitly {@link lnrpc.OpenChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest} message OpenChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nodePubkey);
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nodePubkeyString);
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.localFundingAmount);
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.pushSat);
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.satPerByte);
            if (message["private"] != null && message.hasOwnProperty("private"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message["private"]);
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.minHtlcMsat);
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.remoteCsvDelay);
            return writer;
        };

        /**
         * Encodes the specified OpenChannelRequest message, length delimited. Does not implicitly {@link lnrpc.OpenChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest} message OpenChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OpenChannelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.nodePubkey = reader.bytes();
                    break;
                case 3:
                    message.nodePubkeyString = reader.string();
                    break;
                case 4:
                    message.localFundingAmount = reader.int64();
                    break;
                case 5:
                    message.pushSat = reader.int64();
                    break;
                case 6:
                    message.targetConf = reader.int32();
                    break;
                case 7:
                    message.satPerByte = reader.int64();
                    break;
                case 8:
                    message["private"] = reader.bool();
                    break;
                case 9:
                    message.minHtlcMsat = reader.int64();
                    break;
                case 10:
                    message.remoteCsvDelay = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenChannelRequest message.
         * @function verify
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                if (!(message.nodePubkey && typeof message.nodePubkey.length === "number" || $util.isString(message.nodePubkey)))
                    return "nodePubkey: buffer expected";
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                if (!$util.isString(message.nodePubkeyString))
                    return "nodePubkeyString: string expected";
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                if (!$util.isInteger(message.localFundingAmount) && !(message.localFundingAmount && $util.isInteger(message.localFundingAmount.low) && $util.isInteger(message.localFundingAmount.high)))
                    return "localFundingAmount: integer|Long expected";
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                if (!$util.isInteger(message.pushSat) && !(message.pushSat && $util.isInteger(message.pushSat.low) && $util.isInteger(message.pushSat.high)))
                    return "pushSat: integer|Long expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (!$util.isInteger(message.minHtlcMsat) && !(message.minHtlcMsat && $util.isInteger(message.minHtlcMsat.low) && $util.isInteger(message.minHtlcMsat.high)))
                    return "minHtlcMsat: integer|Long expected";
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                if (!$util.isInteger(message.remoteCsvDelay))
                    return "remoteCsvDelay: integer expected";
            return null;
        };

        /**
         * Creates an OpenChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         */
        OpenChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OpenChannelRequest)
                return object;
            var message = new $root.lnrpc.OpenChannelRequest();
            if (object.nodePubkey != null)
                if (typeof object.nodePubkey === "string")
                    $util.base64.decode(object.nodePubkey, message.nodePubkey = $util.newBuffer($util.base64.length(object.nodePubkey)), 0);
                else if (object.nodePubkey.length)
                    message.nodePubkey = object.nodePubkey;
            if (object.nodePubkeyString != null)
                message.nodePubkeyString = String(object.nodePubkeyString);
            if (object.localFundingAmount != null)
                if ($util.Long)
                    (message.localFundingAmount = $util.Long.fromValue(object.localFundingAmount)).unsigned = false;
                else if (typeof object.localFundingAmount === "string")
                    message.localFundingAmount = parseInt(object.localFundingAmount, 10);
                else if (typeof object.localFundingAmount === "number")
                    message.localFundingAmount = object.localFundingAmount;
                else if (typeof object.localFundingAmount === "object")
                    message.localFundingAmount = new $util.LongBits(object.localFundingAmount.low >>> 0, object.localFundingAmount.high >>> 0).toNumber();
            if (object.pushSat != null)
                if ($util.Long)
                    (message.pushSat = $util.Long.fromValue(object.pushSat)).unsigned = false;
                else if (typeof object.pushSat === "string")
                    message.pushSat = parseInt(object.pushSat, 10);
                else if (typeof object.pushSat === "number")
                    message.pushSat = object.pushSat;
                else if (typeof object.pushSat === "object")
                    message.pushSat = new $util.LongBits(object.pushSat.low >>> 0, object.pushSat.high >>> 0).toNumber();
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.minHtlcMsat != null)
                if ($util.Long)
                    (message.minHtlcMsat = $util.Long.fromValue(object.minHtlcMsat)).unsigned = false;
                else if (typeof object.minHtlcMsat === "string")
                    message.minHtlcMsat = parseInt(object.minHtlcMsat, 10);
                else if (typeof object.minHtlcMsat === "number")
                    message.minHtlcMsat = object.minHtlcMsat;
                else if (typeof object.minHtlcMsat === "object")
                    message.minHtlcMsat = new $util.LongBits(object.minHtlcMsat.low >>> 0, object.minHtlcMsat.high >>> 0).toNumber();
            if (object.remoteCsvDelay != null)
                message.remoteCsvDelay = object.remoteCsvDelay >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an OpenChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.OpenChannelRequest} message OpenChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nodePubkey = "";
                else {
                    object.nodePubkey = [];
                    if (options.bytes !== Array)
                        object.nodePubkey = $util.newBuffer(object.nodePubkey);
                }
                object.nodePubkeyString = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.localFundingAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localFundingAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.pushSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pushSat = options.longs === String ? "0" : 0;
                object.targetConf = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object["private"] = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.minHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlcMsat = options.longs === String ? "0" : 0;
                object.remoteCsvDelay = 0;
            }
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                object.nodePubkey = options.bytes === String ? $util.base64.encode(message.nodePubkey, 0, message.nodePubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodePubkey) : message.nodePubkey;
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                object.nodePubkeyString = message.nodePubkeyString;
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                if (typeof message.localFundingAmount === "number")
                    object.localFundingAmount = options.longs === String ? String(message.localFundingAmount) : message.localFundingAmount;
                else
                    object.localFundingAmount = options.longs === String ? $util.Long.prototype.toString.call(message.localFundingAmount) : options.longs === Number ? new $util.LongBits(message.localFundingAmount.low >>> 0, message.localFundingAmount.high >>> 0).toNumber() : message.localFundingAmount;
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                if (typeof message.pushSat === "number")
                    object.pushSat = options.longs === String ? String(message.pushSat) : message.pushSat;
                else
                    object.pushSat = options.longs === String ? $util.Long.prototype.toString.call(message.pushSat) : options.longs === Number ? new $util.LongBits(message.pushSat.low >>> 0, message.pushSat.high >>> 0).toNumber() : message.pushSat;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (typeof message.minHtlcMsat === "number")
                    object.minHtlcMsat = options.longs === String ? String(message.minHtlcMsat) : message.minHtlcMsat;
                else
                    object.minHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlcMsat) : options.longs === Number ? new $util.LongBits(message.minHtlcMsat.low >>> 0, message.minHtlcMsat.high >>> 0).toNumber() : message.minHtlcMsat;
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                object.remoteCsvDelay = message.remoteCsvDelay;
            return object;
        };

        /**
         * Converts this OpenChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenChannelRequest;
    })();

    lnrpc.OpenStatusUpdate = (function() {

        /**
         * Properties of an OpenStatusUpdate.
         * @memberof lnrpc
         * @interface IOpenStatusUpdate
         * @property {lnrpc.IPendingUpdate|null} [chanPending] OpenStatusUpdate chanPending
         * @property {lnrpc.IConfirmationUpdate|null} [confirmation] OpenStatusUpdate confirmation
         * @property {lnrpc.IChannelOpenUpdate|null} [chanOpen] OpenStatusUpdate chanOpen
         */

        /**
         * Constructs a new OpenStatusUpdate.
         * @memberof lnrpc
         * @classdesc Represents an OpenStatusUpdate.
         * @implements IOpenStatusUpdate
         * @constructor
         * @param {lnrpc.IOpenStatusUpdate=} [properties] Properties to set
         */
        function OpenStatusUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenStatusUpdate chanPending.
         * @member {lnrpc.IPendingUpdate|null|undefined} chanPending
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.chanPending = null;

        /**
         * OpenStatusUpdate confirmation.
         * @member {lnrpc.IConfirmationUpdate|null|undefined} confirmation
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.confirmation = null;

        /**
         * OpenStatusUpdate chanOpen.
         * @member {lnrpc.IChannelOpenUpdate|null|undefined} chanOpen
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.chanOpen = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * OpenStatusUpdate update.
         * @member {"chanPending"|"confirmation"|"chanOpen"|undefined} update
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        Object.defineProperty(OpenStatusUpdate.prototype, "update", {
            get: $util.oneOfGetter($oneOfFields = ["chanPending", "confirmation", "chanOpen"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new OpenStatusUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate=} [properties] Properties to set
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate instance
         */
        OpenStatusUpdate.create = function create(properties) {
            return new OpenStatusUpdate(properties);
        };

        /**
         * Encodes the specified OpenStatusUpdate message. Does not implicitly {@link lnrpc.OpenStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate} message OpenStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPending != null && message.hasOwnProperty("chanPending"))
                $root.lnrpc.PendingUpdate.encode(message.chanPending, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.confirmation != null && message.hasOwnProperty("confirmation"))
                $root.lnrpc.ConfirmationUpdate.encode(message.confirmation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen"))
                $root.lnrpc.ChannelOpenUpdate.encode(message.chanOpen, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenStatusUpdate message, length delimited. Does not implicitly {@link lnrpc.OpenStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate} message OpenStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OpenStatusUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPending = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.confirmation = $root.lnrpc.ConfirmationUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chanOpen = $root.lnrpc.ChannelOpenUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenStatusUpdate message.
         * @function verify
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.chanPending != null && message.hasOwnProperty("chanPending")) {
                properties.update = 1;
                {
                    var error = $root.lnrpc.PendingUpdate.verify(message.chanPending);
                    if (error)
                        return "chanPending." + error;
                }
            }
            if (message.confirmation != null && message.hasOwnProperty("confirmation")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    var error = $root.lnrpc.ConfirmationUpdate.verify(message.confirmation);
                    if (error)
                        return "confirmation." + error;
                }
            }
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    var error = $root.lnrpc.ChannelOpenUpdate.verify(message.chanOpen);
                    if (error)
                        return "chanOpen." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OpenStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         */
        OpenStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OpenStatusUpdate)
                return object;
            var message = new $root.lnrpc.OpenStatusUpdate();
            if (object.chanPending != null) {
                if (typeof object.chanPending !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.chanPending: object expected");
                message.chanPending = $root.lnrpc.PendingUpdate.fromObject(object.chanPending);
            }
            if (object.confirmation != null) {
                if (typeof object.confirmation !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.confirmation: object expected");
                message.confirmation = $root.lnrpc.ConfirmationUpdate.fromObject(object.confirmation);
            }
            if (object.chanOpen != null) {
                if (typeof object.chanOpen !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.chanOpen: object expected");
                message.chanOpen = $root.lnrpc.ChannelOpenUpdate.fromObject(object.chanOpen);
            }
            return message;
        };

        /**
         * Creates a plain object from an OpenStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.OpenStatusUpdate} message OpenStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.chanPending != null && message.hasOwnProperty("chanPending")) {
                object.chanPending = $root.lnrpc.PendingUpdate.toObject(message.chanPending, options);
                if (options.oneofs)
                    object.update = "chanPending";
            }
            if (message.confirmation != null && message.hasOwnProperty("confirmation")) {
                object.confirmation = $root.lnrpc.ConfirmationUpdate.toObject(message.confirmation, options);
                if (options.oneofs)
                    object.update = "confirmation";
            }
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen")) {
                object.chanOpen = $root.lnrpc.ChannelOpenUpdate.toObject(message.chanOpen, options);
                if (options.oneofs)
                    object.update = "chanOpen";
            }
            return object;
        };

        /**
         * Converts this OpenStatusUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenStatusUpdate;
    })();

    lnrpc.PendingHTLC = (function() {

        /**
         * Properties of a PendingHTLC.
         * @memberof lnrpc
         * @interface IPendingHTLC
         * @property {boolean|null} [incoming] The direction within the channel that the htlc was sent
         * @property {number|Long|null} [amount] The total value of the htlc
         * @property {string|null} [outpoint] The final output to be swept back to the user's wallet
         * @property {number|null} [maturityHeight] The next block height at which we can spend the current stage
         * @property {number|null} [blocksTilMaturity] The number of blocks remaining until the current stage can be swept.
         * Negative values indicate how many blocks have passed since becoming
         * mature.
         * @property {number|null} [stage] Indicates whether the htlc is in its first or second stage of recovery
         */

        /**
         * Constructs a new PendingHTLC.
         * @memberof lnrpc
         * @classdesc Represents a PendingHTLC.
         * @implements IPendingHTLC
         * @constructor
         * @param {lnrpc.IPendingHTLC=} [properties] Properties to set
         */
        function PendingHTLC(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The direction within the channel that the htlc was sent
         * @member {boolean} incoming
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.incoming = false;

        /**
         * The total value of the htlc
         * @member {number|Long} amount
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The final output to be swept back to the user's wallet
         * @member {string} outpoint
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.outpoint = "";

        /**
         * The next block height at which we can spend the current stage
         * @member {number} maturityHeight
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.maturityHeight = 0;

        /**
         * The number of blocks remaining until the current stage can be swept.
         * Negative values indicate how many blocks have passed since becoming
         * mature.
         * @member {number} blocksTilMaturity
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.blocksTilMaturity = 0;

        /**
         * Indicates whether the htlc is in its first or second stage of recovery
         * @member {number} stage
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.stage = 0;

        /**
         * Creates a new PendingHTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC=} [properties] Properties to set
         * @returns {lnrpc.PendingHTLC} PendingHTLC instance
         */
        PendingHTLC.create = function create(properties) {
            return new PendingHTLC(properties);
        };

        /**
         * Encodes the specified PendingHTLC message. Does not implicitly {@link lnrpc.PendingHTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC} message PendingHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingHTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.incoming);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.outpoint);
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maturityHeight);
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blocksTilMaturity);
            if (message.stage != null && message.hasOwnProperty("stage"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.stage);
            return writer;
        };

        /**
         * Encodes the specified PendingHTLC message, length delimited. Does not implicitly {@link lnrpc.PendingHTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC} message PendingHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingHTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingHTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingHTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingHTLC();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incoming = reader.bool();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.outpoint = reader.string();
                    break;
                case 4:
                    message.maturityHeight = reader.uint32();
                    break;
                case 5:
                    message.blocksTilMaturity = reader.int32();
                    break;
                case 6:
                    message.stage = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingHTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingHTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingHTLC message.
         * @function verify
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingHTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                if (typeof message.incoming !== "boolean")
                    return "incoming: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                if (!$util.isString(message.outpoint))
                    return "outpoint: string expected";
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                if (!$util.isInteger(message.maturityHeight))
                    return "maturityHeight: integer expected";
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                if (!$util.isInteger(message.blocksTilMaturity))
                    return "blocksTilMaturity: integer expected";
            if (message.stage != null && message.hasOwnProperty("stage"))
                if (!$util.isInteger(message.stage))
                    return "stage: integer expected";
            return null;
        };

        /**
         * Creates a PendingHTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         */
        PendingHTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingHTLC)
                return object;
            var message = new $root.lnrpc.PendingHTLC();
            if (object.incoming != null)
                message.incoming = Boolean(object.incoming);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.outpoint != null)
                message.outpoint = String(object.outpoint);
            if (object.maturityHeight != null)
                message.maturityHeight = object.maturityHeight >>> 0;
            if (object.blocksTilMaturity != null)
                message.blocksTilMaturity = object.blocksTilMaturity | 0;
            if (object.stage != null)
                message.stage = object.stage >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendingHTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.PendingHTLC} message PendingHTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingHTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.incoming = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.outpoint = "";
                object.maturityHeight = 0;
                object.blocksTilMaturity = 0;
                object.stage = 0;
            }
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                object.incoming = message.incoming;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                object.outpoint = message.outpoint;
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                object.maturityHeight = message.maturityHeight;
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                object.blocksTilMaturity = message.blocksTilMaturity;
            if (message.stage != null && message.hasOwnProperty("stage"))
                object.stage = message.stage;
            return object;
        };

        /**
         * Converts this PendingHTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingHTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingHTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingHTLC;
    })();

    lnrpc.PendingChannelsRequest = (function() {

        /**
         * Properties of a PendingChannelsRequest.
         * @memberof lnrpc
         * @interface IPendingChannelsRequest
         */

        /**
         * Constructs a new PendingChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a PendingChannelsRequest.
         * @implements IPendingChannelsRequest
         * @constructor
         * @param {lnrpc.IPendingChannelsRequest=} [properties] Properties to set
         */
        function PendingChannelsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PendingChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest instance
         */
        PendingChannelsRequest.create = function create(properties) {
            return new PendingChannelsRequest(properties);
        };

        /**
         * Encodes the specified PendingChannelsRequest message. Does not implicitly {@link lnrpc.PendingChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest} message PendingChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PendingChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest} message PendingChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingChannelsRequest message.
         * @function verify
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PendingChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         */
        PendingChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingChannelsRequest)
                return object;
            return new $root.lnrpc.PendingChannelsRequest();
        };

        /**
         * Creates a plain object from a PendingChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.PendingChannelsRequest} message PendingChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingChannelsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PendingChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingChannelsRequest;
    })();

    lnrpc.PendingChannelsResponse = (function() {

        /**
         * Properties of a PendingChannelsResponse.
         * @memberof lnrpc
         * @interface IPendingChannelsResponse
         * @property {number|Long|null} [totalLimboBalance] The balance in satoshis encumbered in pending channels
         * @property {Array.<lnrpc.PendingChannelsResponse.IPendingOpenChannel>|null} [pendingOpenChannels] Channels pending opening
         * @property {Array.<lnrpc.PendingChannelsResponse.IClosedChannel>|null} [pendingClosingChannels] Channels pending closing
         * @property {Array.<lnrpc.PendingChannelsResponse.IForceClosedChannel>|null} [pendingForceClosingChannels] Channels pending force closing
         * @property {Array.<lnrpc.PendingChannelsResponse.IWaitingCloseChannel>|null} [waitingCloseChannels] Channels waiting for closing tx to confirm
         */

        /**
         * Constructs a new PendingChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a PendingChannelsResponse.
         * @implements IPendingChannelsResponse
         * @constructor
         * @param {lnrpc.IPendingChannelsResponse=} [properties] Properties to set
         */
        function PendingChannelsResponse(properties) {
            this.pendingOpenChannels = [];
            this.pendingClosingChannels = [];
            this.pendingForceClosingChannels = [];
            this.waitingCloseChannels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The balance in satoshis encumbered in pending channels
         * @member {number|Long} totalLimboBalance
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.totalLimboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channels pending opening
         * @member {Array.<lnrpc.PendingChannelsResponse.IPendingOpenChannel>} pendingOpenChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingOpenChannels = $util.emptyArray;

        /**
         * Channels pending closing
         * @member {Array.<lnrpc.PendingChannelsResponse.IClosedChannel>} pendingClosingChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingClosingChannels = $util.emptyArray;

        /**
         * Channels pending force closing
         * @member {Array.<lnrpc.PendingChannelsResponse.IForceClosedChannel>} pendingForceClosingChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingForceClosingChannels = $util.emptyArray;

        /**
         * Channels waiting for closing tx to confirm
         * @member {Array.<lnrpc.PendingChannelsResponse.IWaitingCloseChannel>} waitingCloseChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.waitingCloseChannels = $util.emptyArray;

        /**
         * Creates a new PendingChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse instance
         */
        PendingChannelsResponse.create = function create(properties) {
            return new PendingChannelsResponse(properties);
        };

        /**
         * Encodes the specified PendingChannelsResponse message. Does not implicitly {@link lnrpc.PendingChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse} message PendingChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalLimboBalance);
            if (message.pendingOpenChannels != null && message.pendingOpenChannels.length)
                for (var i = 0; i < message.pendingOpenChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.encode(message.pendingOpenChannels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.pendingClosingChannels != null && message.pendingClosingChannels.length)
                for (var i = 0; i < message.pendingClosingChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.ClosedChannel.encode(message.pendingClosingChannels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pendingForceClosingChannels != null && message.pendingForceClosingChannels.length)
                for (var i = 0; i < message.pendingForceClosingChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.encode(message.pendingForceClosingChannels[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.waitingCloseChannels != null && message.waitingCloseChannels.length)
                for (var i = 0; i < message.waitingCloseChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.encode(message.waitingCloseChannels[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PendingChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse} message PendingChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalLimboBalance = reader.int64();
                    break;
                case 2:
                    if (!(message.pendingOpenChannels && message.pendingOpenChannels.length))
                        message.pendingOpenChannels = [];
                    message.pendingOpenChannels.push($root.lnrpc.PendingChannelsResponse.PendingOpenChannel.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.pendingClosingChannels && message.pendingClosingChannels.length))
                        message.pendingClosingChannels = [];
                    message.pendingClosingChannels.push($root.lnrpc.PendingChannelsResponse.ClosedChannel.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.pendingForceClosingChannels && message.pendingForceClosingChannels.length))
                        message.pendingForceClosingChannels = [];
                    message.pendingForceClosingChannels.push($root.lnrpc.PendingChannelsResponse.ForceClosedChannel.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.waitingCloseChannels && message.waitingCloseChannels.length))
                        message.waitingCloseChannels = [];
                    message.waitingCloseChannels.push($root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingChannelsResponse message.
         * @function verify
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                if (!$util.isInteger(message.totalLimboBalance) && !(message.totalLimboBalance && $util.isInteger(message.totalLimboBalance.low) && $util.isInteger(message.totalLimboBalance.high)))
                    return "totalLimboBalance: integer|Long expected";
            if (message.pendingOpenChannels != null && message.hasOwnProperty("pendingOpenChannels")) {
                if (!Array.isArray(message.pendingOpenChannels))
                    return "pendingOpenChannels: array expected";
                for (var i = 0; i < message.pendingOpenChannels.length; ++i) {
                    var error = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.verify(message.pendingOpenChannels[i]);
                    if (error)
                        return "pendingOpenChannels." + error;
                }
            }
            if (message.pendingClosingChannels != null && message.hasOwnProperty("pendingClosingChannels")) {
                if (!Array.isArray(message.pendingClosingChannels))
                    return "pendingClosingChannels: array expected";
                for (var i = 0; i < message.pendingClosingChannels.length; ++i) {
                    var error = $root.lnrpc.PendingChannelsResponse.ClosedChannel.verify(message.pendingClosingChannels[i]);
                    if (error)
                        return "pendingClosingChannels." + error;
                }
            }
            if (message.pendingForceClosingChannels != null && message.hasOwnProperty("pendingForceClosingChannels")) {
                if (!Array.isArray(message.pendingForceClosingChannels))
                    return "pendingForceClosingChannels: array expected";
                for (var i = 0; i < message.pendingForceClosingChannels.length; ++i) {
                    var error = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.verify(message.pendingForceClosingChannels[i]);
                    if (error)
                        return "pendingForceClosingChannels." + error;
                }
            }
            if (message.waitingCloseChannels != null && message.hasOwnProperty("waitingCloseChannels")) {
                if (!Array.isArray(message.waitingCloseChannels))
                    return "waitingCloseChannels: array expected";
                for (var i = 0; i < message.waitingCloseChannels.length; ++i) {
                    var error = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify(message.waitingCloseChannels[i]);
                    if (error)
                        return "waitingCloseChannels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PendingChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         */
        PendingChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingChannelsResponse)
                return object;
            var message = new $root.lnrpc.PendingChannelsResponse();
            if (object.totalLimboBalance != null)
                if ($util.Long)
                    (message.totalLimboBalance = $util.Long.fromValue(object.totalLimboBalance)).unsigned = false;
                else if (typeof object.totalLimboBalance === "string")
                    message.totalLimboBalance = parseInt(object.totalLimboBalance, 10);
                else if (typeof object.totalLimboBalance === "number")
                    message.totalLimboBalance = object.totalLimboBalance;
                else if (typeof object.totalLimboBalance === "object")
                    message.totalLimboBalance = new $util.LongBits(object.totalLimboBalance.low >>> 0, object.totalLimboBalance.high >>> 0).toNumber();
            if (object.pendingOpenChannels) {
                if (!Array.isArray(object.pendingOpenChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingOpenChannels: array expected");
                message.pendingOpenChannels = [];
                for (var i = 0; i < object.pendingOpenChannels.length; ++i) {
                    if (typeof object.pendingOpenChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingOpenChannels: object expected");
                    message.pendingOpenChannels[i] = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.fromObject(object.pendingOpenChannels[i]);
                }
            }
            if (object.pendingClosingChannels) {
                if (!Array.isArray(object.pendingClosingChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingClosingChannels: array expected");
                message.pendingClosingChannels = [];
                for (var i = 0; i < object.pendingClosingChannels.length; ++i) {
                    if (typeof object.pendingClosingChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingClosingChannels: object expected");
                    message.pendingClosingChannels[i] = $root.lnrpc.PendingChannelsResponse.ClosedChannel.fromObject(object.pendingClosingChannels[i]);
                }
            }
            if (object.pendingForceClosingChannels) {
                if (!Array.isArray(object.pendingForceClosingChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingForceClosingChannels: array expected");
                message.pendingForceClosingChannels = [];
                for (var i = 0; i < object.pendingForceClosingChannels.length; ++i) {
                    if (typeof object.pendingForceClosingChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingForceClosingChannels: object expected");
                    message.pendingForceClosingChannels[i] = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.fromObject(object.pendingForceClosingChannels[i]);
                }
            }
            if (object.waitingCloseChannels) {
                if (!Array.isArray(object.waitingCloseChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.waitingCloseChannels: array expected");
                message.waitingCloseChannels = [];
                for (var i = 0; i < object.waitingCloseChannels.length; ++i) {
                    if (typeof object.waitingCloseChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.waitingCloseChannels: object expected");
                    message.waitingCloseChannels[i] = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.fromObject(object.waitingCloseChannels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PendingChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.PendingChannelsResponse} message PendingChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pendingOpenChannels = [];
                object.pendingClosingChannels = [];
                object.pendingForceClosingChannels = [];
                object.waitingCloseChannels = [];
            }
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalLimboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalLimboBalance = options.longs === String ? "0" : 0;
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                if (typeof message.totalLimboBalance === "number")
                    object.totalLimboBalance = options.longs === String ? String(message.totalLimboBalance) : message.totalLimboBalance;
                else
                    object.totalLimboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.totalLimboBalance) : options.longs === Number ? new $util.LongBits(message.totalLimboBalance.low >>> 0, message.totalLimboBalance.high >>> 0).toNumber() : message.totalLimboBalance;
            if (message.pendingOpenChannels && message.pendingOpenChannels.length) {
                object.pendingOpenChannels = [];
                for (var j = 0; j < message.pendingOpenChannels.length; ++j)
                    object.pendingOpenChannels[j] = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.toObject(message.pendingOpenChannels[j], options);
            }
            if (message.pendingClosingChannels && message.pendingClosingChannels.length) {
                object.pendingClosingChannels = [];
                for (var j = 0; j < message.pendingClosingChannels.length; ++j)
                    object.pendingClosingChannels[j] = $root.lnrpc.PendingChannelsResponse.ClosedChannel.toObject(message.pendingClosingChannels[j], options);
            }
            if (message.pendingForceClosingChannels && message.pendingForceClosingChannels.length) {
                object.pendingForceClosingChannels = [];
                for (var j = 0; j < message.pendingForceClosingChannels.length; ++j)
                    object.pendingForceClosingChannels[j] = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.toObject(message.pendingForceClosingChannels[j], options);
            }
            if (message.waitingCloseChannels && message.waitingCloseChannels.length) {
                object.waitingCloseChannels = [];
                for (var j = 0; j < message.waitingCloseChannels.length; ++j)
                    object.waitingCloseChannels[j] = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.toObject(message.waitingCloseChannels[j], options);
            }
            return object;
        };

        /**
         * Converts this PendingChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PendingChannelsResponse.PendingChannel = (function() {

            /**
             * Properties of a PendingChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IPendingChannel
             * @property {string|null} [remoteNodePub] PendingChannel remoteNodePub
             * @property {string|null} [channelPoint] PendingChannel channelPoint
             * @property {number|Long|null} [capacity] PendingChannel capacity
             * @property {number|Long|null} [localBalance] PendingChannel localBalance
             * @property {number|Long|null} [remoteBalance] PendingChannel remoteBalance
             */

            /**
             * Constructs a new PendingChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a PendingChannel.
             * @implements IPendingChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel=} [properties] Properties to set
             */
            function PendingChannel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PendingChannel remoteNodePub.
             * @member {string} remoteNodePub
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteNodePub = "";

            /**
             * PendingChannel channelPoint.
             * @member {string} channelPoint
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.channelPoint = "";

            /**
             * PendingChannel capacity.
             * @member {number|Long} capacity
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel localBalance.
             * @member {number|Long} localBalance
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.localBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel remoteBalance.
             * @member {number|Long} remoteBalance
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PendingChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel instance
             */
            PendingChannel.create = function create(properties) {
                return new PendingChannel(properties);
            };

            /**
             * Encodes the specified PendingChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel} message PendingChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.remoteNodePub);
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelPoint);
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.capacity);
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.localBalance);
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.remoteBalance);
                return writer;
            };

            /**
             * Encodes the specified PendingChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel} message PendingChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.PendingChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.remoteNodePub = reader.string();
                        break;
                    case 2:
                        message.channelPoint = reader.string();
                        break;
                    case 3:
                        message.capacity = reader.int64();
                        break;
                    case 4:
                        message.localBalance = reader.int64();
                        break;
                    case 5:
                        message.remoteBalance = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    if (!$util.isString(message.remoteNodePub))
                        return "remoteNodePub: string expected";
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    if (!$util.isString(message.channelPoint))
                        return "channelPoint: string expected";
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                        return "capacity: integer|Long expected";
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    if (!$util.isInteger(message.localBalance) && !(message.localBalance && $util.isInteger(message.localBalance.low) && $util.isInteger(message.localBalance.high)))
                        return "localBalance: integer|Long expected";
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    if (!$util.isInteger(message.remoteBalance) && !(message.remoteBalance && $util.isInteger(message.remoteBalance.low) && $util.isInteger(message.remoteBalance.high)))
                        return "remoteBalance: integer|Long expected";
                return null;
            };

            /**
             * Creates a PendingChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             */
            PendingChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.PendingChannel)
                    return object;
                var message = new $root.lnrpc.PendingChannelsResponse.PendingChannel();
                if (object.remoteNodePub != null)
                    message.remoteNodePub = String(object.remoteNodePub);
                if (object.channelPoint != null)
                    message.channelPoint = String(object.channelPoint);
                if (object.capacity != null)
                    if ($util.Long)
                        (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                    else if (typeof object.capacity === "string")
                        message.capacity = parseInt(object.capacity, 10);
                    else if (typeof object.capacity === "number")
                        message.capacity = object.capacity;
                    else if (typeof object.capacity === "object")
                        message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
                if (object.localBalance != null)
                    if ($util.Long)
                        (message.localBalance = $util.Long.fromValue(object.localBalance)).unsigned = false;
                    else if (typeof object.localBalance === "string")
                        message.localBalance = parseInt(object.localBalance, 10);
                    else if (typeof object.localBalance === "number")
                        message.localBalance = object.localBalance;
                    else if (typeof object.localBalance === "object")
                        message.localBalance = new $util.LongBits(object.localBalance.low >>> 0, object.localBalance.high >>> 0).toNumber();
                if (object.remoteBalance != null)
                    if ($util.Long)
                        (message.remoteBalance = $util.Long.fromValue(object.remoteBalance)).unsigned = false;
                    else if (typeof object.remoteBalance === "string")
                        message.remoteBalance = parseInt(object.remoteBalance, 10);
                    else if (typeof object.remoteBalance === "number")
                        message.remoteBalance = object.remoteBalance;
                    else if (typeof object.remoteBalance === "object")
                        message.remoteBalance = new $util.LongBits(object.remoteBalance.low >>> 0, object.remoteBalance.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PendingChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.PendingChannel} message PendingChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.remoteNodePub = "";
                    object.channelPoint = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.capacity = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.localBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.localBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.remoteBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remoteBalance = options.longs === String ? "0" : 0;
                }
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    object.remoteNodePub = message.remoteNodePub;
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    object.channelPoint = message.channelPoint;
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (typeof message.capacity === "number")
                        object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                    else
                        object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    if (typeof message.localBalance === "number")
                        object.localBalance = options.longs === String ? String(message.localBalance) : message.localBalance;
                    else
                        object.localBalance = options.longs === String ? $util.Long.prototype.toString.call(message.localBalance) : options.longs === Number ? new $util.LongBits(message.localBalance.low >>> 0, message.localBalance.high >>> 0).toNumber() : message.localBalance;
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    if (typeof message.remoteBalance === "number")
                        object.remoteBalance = options.longs === String ? String(message.remoteBalance) : message.remoteBalance;
                    else
                        object.remoteBalance = options.longs === String ? $util.Long.prototype.toString.call(message.remoteBalance) : options.longs === Number ? new $util.LongBits(message.remoteBalance.low >>> 0, message.remoteBalance.high >>> 0).toNumber() : message.remoteBalance;
                return object;
            };

            /**
             * Converts this PendingChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingChannel;
        })();

        PendingChannelsResponse.PendingOpenChannel = (function() {

            /**
             * Properties of a PendingOpenChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IPendingOpenChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel
             * @property {number|null} [confirmationHeight] The height at which this channel will be confirmed
             * @property {number|Long|null} [commitFee] The amount calculated to be paid in fees for the current set of
             * commitment transactions. The fee amount is persisted with the channel
             * in order to allow the fee amount to be removed and recalculated with
             * each channel state update, including updates that happen after a system
             * restart.
             * @property {number|Long|null} [commitWeight] The weight of the commitment transaction
             * @property {number|Long|null} [feePerKw] The required number of satoshis per kilo-weight that the requester will
             * pay at all times, for both the funding transaction and commitment
             * transaction. This value can later be updated once the channel is open.
             */

            /**
             * Constructs a new PendingOpenChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a PendingOpenChannel.
             * @implements IPendingOpenChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel=} [properties] Properties to set
             */
            function PendingOpenChannel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.channel = null;

            /**
             * The height at which this channel will be confirmed
             * @member {number} confirmationHeight
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.confirmationHeight = 0;

            /**
             * The amount calculated to be paid in fees for the current set of
             * commitment transactions. The fee amount is persisted with the channel
             * in order to allow the fee amount to be removed and recalculated with
             * each channel state update, including updates that happen after a system
             * restart.
             * @member {number|Long} commitFee
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.commitFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The weight of the commitment transaction
             * @member {number|Long} commitWeight
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.commitWeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The required number of satoshis per kilo-weight that the requester will
             * pay at all times, for both the funding transaction and commitment
             * transaction. This value can later be updated once the channel is open.
             * @member {number|Long} feePerKw
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PendingOpenChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel instance
             */
            PendingOpenChannel.create = function create(properties) {
                return new PendingOpenChannel(properties);
            };

            /**
             * Encodes the specified PendingOpenChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingOpenChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel} message PendingOpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingOpenChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.confirmationHeight);
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.commitFee);
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.commitWeight);
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.feePerKw);
                return writer;
            };

            /**
             * Encodes the specified PendingOpenChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingOpenChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel} message PendingOpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingOpenChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingOpenChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingOpenChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.PendingOpenChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.confirmationHeight = reader.uint32();
                        break;
                    case 4:
                        message.commitFee = reader.int64();
                        break;
                    case 5:
                        message.commitWeight = reader.int64();
                        break;
                    case 6:
                        message.feePerKw = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingOpenChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingOpenChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingOpenChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingOpenChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    var error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    if (!$util.isInteger(message.confirmationHeight))
                        return "confirmationHeight: integer expected";
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    if (!$util.isInteger(message.commitFee) && !(message.commitFee && $util.isInteger(message.commitFee.low) && $util.isInteger(message.commitFee.high)))
                        return "commitFee: integer|Long expected";
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    if (!$util.isInteger(message.commitWeight) && !(message.commitWeight && $util.isInteger(message.commitWeight.low) && $util.isInteger(message.commitWeight.high)))
                        return "commitWeight: integer|Long expected";
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                        return "feePerKw: integer|Long expected";
                return null;
            };

            /**
             * Creates a PendingOpenChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             */
            PendingOpenChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.PendingOpenChannel)
                    return object;
                var message = new $root.lnrpc.PendingChannelsResponse.PendingOpenChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.PendingOpenChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.confirmationHeight != null)
                    message.confirmationHeight = object.confirmationHeight >>> 0;
                if (object.commitFee != null)
                    if ($util.Long)
                        (message.commitFee = $util.Long.fromValue(object.commitFee)).unsigned = false;
                    else if (typeof object.commitFee === "string")
                        message.commitFee = parseInt(object.commitFee, 10);
                    else if (typeof object.commitFee === "number")
                        message.commitFee = object.commitFee;
                    else if (typeof object.commitFee === "object")
                        message.commitFee = new $util.LongBits(object.commitFee.low >>> 0, object.commitFee.high >>> 0).toNumber();
                if (object.commitWeight != null)
                    if ($util.Long)
                        (message.commitWeight = $util.Long.fromValue(object.commitWeight)).unsigned = false;
                    else if (typeof object.commitWeight === "string")
                        message.commitWeight = parseInt(object.commitWeight, 10);
                    else if (typeof object.commitWeight === "number")
                        message.commitWeight = object.commitWeight;
                    else if (typeof object.commitWeight === "object")
                        message.commitWeight = new $util.LongBits(object.commitWeight.low >>> 0, object.commitWeight.high >>> 0).toNumber();
                if (object.feePerKw != null)
                    if ($util.Long)
                        (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = false;
                    else if (typeof object.feePerKw === "string")
                        message.feePerKw = parseInt(object.feePerKw, 10);
                    else if (typeof object.feePerKw === "number")
                        message.feePerKw = object.feePerKw;
                    else if (typeof object.feePerKw === "object")
                        message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PendingOpenChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.PendingOpenChannel} message PendingOpenChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingOpenChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = null;
                    object.confirmationHeight = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.commitFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.commitFee = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.commitWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.commitWeight = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.feePerKw = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    object.confirmationHeight = message.confirmationHeight;
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    if (typeof message.commitFee === "number")
                        object.commitFee = options.longs === String ? String(message.commitFee) : message.commitFee;
                    else
                        object.commitFee = options.longs === String ? $util.Long.prototype.toString.call(message.commitFee) : options.longs === Number ? new $util.LongBits(message.commitFee.low >>> 0, message.commitFee.high >>> 0).toNumber() : message.commitFee;
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    if (typeof message.commitWeight === "number")
                        object.commitWeight = options.longs === String ? String(message.commitWeight) : message.commitWeight;
                    else
                        object.commitWeight = options.longs === String ? $util.Long.prototype.toString.call(message.commitWeight) : options.longs === Number ? new $util.LongBits(message.commitWeight.low >>> 0, message.commitWeight.high >>> 0).toNumber() : message.commitWeight;
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    if (typeof message.feePerKw === "number")
                        object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                    else
                        object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber() : message.feePerKw;
                return object;
            };

            /**
             * Converts this PendingOpenChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingOpenChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingOpenChannel;
        })();

        PendingChannelsResponse.WaitingCloseChannel = (function() {

            /**
             * Properties of a WaitingCloseChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IWaitingCloseChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel waiting for closing tx to confirm
             * @property {number|Long|null} [limboBalance] The balance in satoshis encumbered in this channel
             */

            /**
             * Constructs a new WaitingCloseChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a WaitingCloseChannel.
             * @implements IWaitingCloseChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel=} [properties] Properties to set
             */
            function WaitingCloseChannel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel waiting for closing tx to confirm
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.channel = null;

            /**
             * The balance in satoshis encumbered in this channel
             * @member {number|Long} limboBalance
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.limboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new WaitingCloseChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel instance
             */
            WaitingCloseChannel.create = function create(properties) {
                return new WaitingCloseChannel(properties);
            };

            /**
             * Encodes the specified WaitingCloseChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel} message WaitingCloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitingCloseChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.limboBalance);
                return writer;
            };

            /**
             * Encodes the specified WaitingCloseChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel} message WaitingCloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitingCloseChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WaitingCloseChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitingCloseChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limboBalance = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WaitingCloseChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitingCloseChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WaitingCloseChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WaitingCloseChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    var error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (!$util.isInteger(message.limboBalance) && !(message.limboBalance && $util.isInteger(message.limboBalance.low) && $util.isInteger(message.limboBalance.high)))
                        return "limboBalance: integer|Long expected";
                return null;
            };

            /**
             * Creates a WaitingCloseChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             */
            WaitingCloseChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel)
                    return object;
                var message = new $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.WaitingCloseChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.limboBalance != null)
                    if ($util.Long)
                        (message.limboBalance = $util.Long.fromValue(object.limboBalance)).unsigned = false;
                    else if (typeof object.limboBalance === "string")
                        message.limboBalance = parseInt(object.limboBalance, 10);
                    else if (typeof object.limboBalance === "number")
                        message.limboBalance = object.limboBalance;
                    else if (typeof object.limboBalance === "object")
                        message.limboBalance = new $util.LongBits(object.limboBalance.low >>> 0, object.limboBalance.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a WaitingCloseChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.WaitingCloseChannel} message WaitingCloseChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WaitingCloseChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.limboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limboBalance = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (typeof message.limboBalance === "number")
                        object.limboBalance = options.longs === String ? String(message.limboBalance) : message.limboBalance;
                    else
                        object.limboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.limboBalance) : options.longs === Number ? new $util.LongBits(message.limboBalance.low >>> 0, message.limboBalance.high >>> 0).toNumber() : message.limboBalance;
                return object;
            };

            /**
             * Converts this WaitingCloseChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WaitingCloseChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WaitingCloseChannel;
        })();

        PendingChannelsResponse.ClosedChannel = (function() {

            /**
             * Properties of a ClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IClosedChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel to be closed
             * @property {string|null} [closingTxid] The transaction id of the closing transaction
             */

            /**
             * Constructs a new ClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a ClosedChannel.
             * @implements IClosedChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel=} [properties] Properties to set
             */
            function ClosedChannel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel to be closed
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             */
            ClosedChannel.prototype.channel = null;

            /**
             * The transaction id of the closing transaction
             * @member {string} closingTxid
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             */
            ClosedChannel.prototype.closingTxid = "";

            /**
             * Creates a new ClosedChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel instance
             */
            ClosedChannel.create = function create(properties) {
                return new ClosedChannel(properties);
            };

            /**
             * Encodes the specified ClosedChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.ClosedChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel} message ClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClosedChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.closingTxid);
                return writer;
            };

            /**
             * Encodes the specified ClosedChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.ClosedChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel} message ClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClosedChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClosedChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClosedChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.ClosedChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closingTxid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClosedChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClosedChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClosedChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClosedChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    var error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    if (!$util.isString(message.closingTxid))
                        return "closingTxid: string expected";
                return null;
            };

            /**
             * Creates a ClosedChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             */
            ClosedChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.ClosedChannel)
                    return object;
                var message = new $root.lnrpc.PendingChannelsResponse.ClosedChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.ClosedChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.closingTxid != null)
                    message.closingTxid = String(object.closingTxid);
                return message;
            };

            /**
             * Creates a plain object from a ClosedChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.ClosedChannel} message ClosedChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClosedChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = null;
                    object.closingTxid = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    object.closingTxid = message.closingTxid;
                return object;
            };

            /**
             * Converts this ClosedChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClosedChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClosedChannel;
        })();

        PendingChannelsResponse.ForceClosedChannel = (function() {

            /**
             * Properties of a ForceClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IForceClosedChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel to be force closed
             * @property {string|null} [closingTxid] The transaction id of the closing transaction
             * @property {number|Long|null} [limboBalance] The balance in satoshis encumbered in this pending channel
             * @property {number|null} [maturityHeight] The height at which funds can be sweeped into the wallet
             * @property {number|null} [blocksTilMaturity] ForceClosedChannel blocksTilMaturity
             * @property {number|Long|null} [recoveredBalance] The total value of funds successfully recovered from this channel
             * @property {Array.<lnrpc.IPendingHTLC>|null} [pendingHtlcs] ForceClosedChannel pendingHtlcs
             */

            /**
             * Constructs a new ForceClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a ForceClosedChannel.
             * @implements IForceClosedChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel=} [properties] Properties to set
             */
            function ForceClosedChannel(properties) {
                this.pendingHtlcs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel to be force closed
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.channel = null;

            /**
             * The transaction id of the closing transaction
             * @member {string} closingTxid
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.closingTxid = "";

            /**
             * The balance in satoshis encumbered in this pending channel
             * @member {number|Long} limboBalance
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.limboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The height at which funds can be sweeped into the wallet
             * @member {number} maturityHeight
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.maturityHeight = 0;

            /**
             * ForceClosedChannel blocksTilMaturity.
             * @member {number} blocksTilMaturity
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.blocksTilMaturity = 0;

            /**
             * The total value of funds successfully recovered from this channel
             * @member {number|Long} recoveredBalance
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.recoveredBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ForceClosedChannel pendingHtlcs.
             * @member {Array.<lnrpc.IPendingHTLC>} pendingHtlcs
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.pendingHtlcs = $util.emptyArray;

            /**
             * Creates a new ForceClosedChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel instance
             */
            ForceClosedChannel.create = function create(properties) {
                return new ForceClosedChannel(properties);
            };

            /**
             * Encodes the specified ForceClosedChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.ForceClosedChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel} message ForceClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceClosedChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.closingTxid);
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.limboBalance);
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maturityHeight);
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blocksTilMaturity);
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.recoveredBalance);
                if (message.pendingHtlcs != null && message.pendingHtlcs.length)
                    for (var i = 0; i < message.pendingHtlcs.length; ++i)
                        $root.lnrpc.PendingHTLC.encode(message.pendingHtlcs[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForceClosedChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.ForceClosedChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel} message ForceClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceClosedChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForceClosedChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceClosedChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.ForceClosedChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closingTxid = reader.string();
                        break;
                    case 3:
                        message.limboBalance = reader.int64();
                        break;
                    case 4:
                        message.maturityHeight = reader.uint32();
                        break;
                    case 5:
                        message.blocksTilMaturity = reader.int32();
                        break;
                    case 6:
                        message.recoveredBalance = reader.int64();
                        break;
                    case 8:
                        if (!(message.pendingHtlcs && message.pendingHtlcs.length))
                            message.pendingHtlcs = [];
                        message.pendingHtlcs.push($root.lnrpc.PendingHTLC.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForceClosedChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceClosedChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForceClosedChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForceClosedChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    var error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    if (!$util.isString(message.closingTxid))
                        return "closingTxid: string expected";
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (!$util.isInteger(message.limboBalance) && !(message.limboBalance && $util.isInteger(message.limboBalance.low) && $util.isInteger(message.limboBalance.high)))
                        return "limboBalance: integer|Long expected";
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    if (!$util.isInteger(message.maturityHeight))
                        return "maturityHeight: integer expected";
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    if (!$util.isInteger(message.blocksTilMaturity))
                        return "blocksTilMaturity: integer expected";
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    if (!$util.isInteger(message.recoveredBalance) && !(message.recoveredBalance && $util.isInteger(message.recoveredBalance.low) && $util.isInteger(message.recoveredBalance.high)))
                        return "recoveredBalance: integer|Long expected";
                if (message.pendingHtlcs != null && message.hasOwnProperty("pendingHtlcs")) {
                    if (!Array.isArray(message.pendingHtlcs))
                        return "pendingHtlcs: array expected";
                    for (var i = 0; i < message.pendingHtlcs.length; ++i) {
                        var error = $root.lnrpc.PendingHTLC.verify(message.pendingHtlcs[i]);
                        if (error)
                            return "pendingHtlcs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForceClosedChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             */
            ForceClosedChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.ForceClosedChannel)
                    return object;
                var message = new $root.lnrpc.PendingChannelsResponse.ForceClosedChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.closingTxid != null)
                    message.closingTxid = String(object.closingTxid);
                if (object.limboBalance != null)
                    if ($util.Long)
                        (message.limboBalance = $util.Long.fromValue(object.limboBalance)).unsigned = false;
                    else if (typeof object.limboBalance === "string")
                        message.limboBalance = parseInt(object.limboBalance, 10);
                    else if (typeof object.limboBalance === "number")
                        message.limboBalance = object.limboBalance;
                    else if (typeof object.limboBalance === "object")
                        message.limboBalance = new $util.LongBits(object.limboBalance.low >>> 0, object.limboBalance.high >>> 0).toNumber();
                if (object.maturityHeight != null)
                    message.maturityHeight = object.maturityHeight >>> 0;
                if (object.blocksTilMaturity != null)
                    message.blocksTilMaturity = object.blocksTilMaturity | 0;
                if (object.recoveredBalance != null)
                    if ($util.Long)
                        (message.recoveredBalance = $util.Long.fromValue(object.recoveredBalance)).unsigned = false;
                    else if (typeof object.recoveredBalance === "string")
                        message.recoveredBalance = parseInt(object.recoveredBalance, 10);
                    else if (typeof object.recoveredBalance === "number")
                        message.recoveredBalance = object.recoveredBalance;
                    else if (typeof object.recoveredBalance === "object")
                        message.recoveredBalance = new $util.LongBits(object.recoveredBalance.low >>> 0, object.recoveredBalance.high >>> 0).toNumber();
                if (object.pendingHtlcs) {
                    if (!Array.isArray(object.pendingHtlcs))
                        throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.pendingHtlcs: array expected");
                    message.pendingHtlcs = [];
                    for (var i = 0; i < object.pendingHtlcs.length; ++i) {
                        if (typeof object.pendingHtlcs[i] !== "object")
                            throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.pendingHtlcs: object expected");
                        message.pendingHtlcs[i] = $root.lnrpc.PendingHTLC.fromObject(object.pendingHtlcs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ForceClosedChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.ForceClosedChannel} message ForceClosedChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForceClosedChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pendingHtlcs = [];
                if (options.defaults) {
                    object.channel = null;
                    object.closingTxid = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.limboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limboBalance = options.longs === String ? "0" : 0;
                    object.maturityHeight = 0;
                    object.blocksTilMaturity = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.recoveredBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.recoveredBalance = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    object.closingTxid = message.closingTxid;
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (typeof message.limboBalance === "number")
                        object.limboBalance = options.longs === String ? String(message.limboBalance) : message.limboBalance;
                    else
                        object.limboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.limboBalance) : options.longs === Number ? new $util.LongBits(message.limboBalance.low >>> 0, message.limboBalance.high >>> 0).toNumber() : message.limboBalance;
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    object.maturityHeight = message.maturityHeight;
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    object.blocksTilMaturity = message.blocksTilMaturity;
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    if (typeof message.recoveredBalance === "number")
                        object.recoveredBalance = options.longs === String ? String(message.recoveredBalance) : message.recoveredBalance;
                    else
                        object.recoveredBalance = options.longs === String ? $util.Long.prototype.toString.call(message.recoveredBalance) : options.longs === Number ? new $util.LongBits(message.recoveredBalance.low >>> 0, message.recoveredBalance.high >>> 0).toNumber() : message.recoveredBalance;
                if (message.pendingHtlcs && message.pendingHtlcs.length) {
                    object.pendingHtlcs = [];
                    for (var j = 0; j < message.pendingHtlcs.length; ++j)
                        object.pendingHtlcs[j] = $root.lnrpc.PendingHTLC.toObject(message.pendingHtlcs[j], options);
                }
                return object;
            };

            /**
             * Converts this ForceClosedChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForceClosedChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ForceClosedChannel;
        })();

        return PendingChannelsResponse;
    })();

    lnrpc.WalletBalanceRequest = (function() {

        /**
         * Properties of a WalletBalanceRequest.
         * @memberof lnrpc
         * @interface IWalletBalanceRequest
         */

        /**
         * Constructs a new WalletBalanceRequest.
         * @memberof lnrpc
         * @classdesc Represents a WalletBalanceRequest.
         * @implements IWalletBalanceRequest
         * @constructor
         * @param {lnrpc.IWalletBalanceRequest=} [properties] Properties to set
         */
        function WalletBalanceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WalletBalanceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest=} [properties] Properties to set
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest instance
         */
        WalletBalanceRequest.create = function create(properties) {
            return new WalletBalanceRequest(properties);
        };

        /**
         * Encodes the specified WalletBalanceRequest message. Does not implicitly {@link lnrpc.WalletBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest} message WalletBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WalletBalanceRequest message, length delimited. Does not implicitly {@link lnrpc.WalletBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest} message WalletBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WalletBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.WalletBalanceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WalletBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WalletBalanceRequest message.
         * @function verify
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WalletBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WalletBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         */
        WalletBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.WalletBalanceRequest)
                return object;
            return new $root.lnrpc.WalletBalanceRequest();
        };

        /**
         * Creates a plain object from a WalletBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.WalletBalanceRequest} message WalletBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WalletBalanceRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WalletBalanceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.WalletBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WalletBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WalletBalanceRequest;
    })();

    lnrpc.WalletBalanceResponse = (function() {

        /**
         * Properties of a WalletBalanceResponse.
         * @memberof lnrpc
         * @interface IWalletBalanceResponse
         * @property {number|Long|null} [totalBalance] The balance of the wallet
         * @property {number|Long|null} [confirmedBalance] The confirmed balance of a wallet(with >= 1 confirmations)
         * @property {number|Long|null} [unconfirmedBalance] The unconfirmed balance of a wallet(with 0 confirmations)
         */

        /**
         * Constructs a new WalletBalanceResponse.
         * @memberof lnrpc
         * @classdesc Represents a WalletBalanceResponse.
         * @implements IWalletBalanceResponse
         * @constructor
         * @param {lnrpc.IWalletBalanceResponse=} [properties] Properties to set
         */
        function WalletBalanceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The balance of the wallet
         * @member {number|Long} totalBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.totalBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The confirmed balance of a wallet(with >= 1 confirmations)
         * @member {number|Long} confirmedBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.confirmedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The unconfirmed balance of a wallet(with 0 confirmations)
         * @member {number|Long} unconfirmedBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.unconfirmedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new WalletBalanceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse=} [properties] Properties to set
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse instance
         */
        WalletBalanceResponse.create = function create(properties) {
            return new WalletBalanceResponse(properties);
        };

        /**
         * Encodes the specified WalletBalanceResponse message. Does not implicitly {@link lnrpc.WalletBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse} message WalletBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalBalance);
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.confirmedBalance);
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.unconfirmedBalance);
            return writer;
        };

        /**
         * Encodes the specified WalletBalanceResponse message, length delimited. Does not implicitly {@link lnrpc.WalletBalanceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse} message WalletBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WalletBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.WalletBalanceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalBalance = reader.int64();
                    break;
                case 2:
                    message.confirmedBalance = reader.int64();
                    break;
                case 3:
                    message.unconfirmedBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WalletBalanceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WalletBalanceResponse message.
         * @function verify
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WalletBalanceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                if (!$util.isInteger(message.totalBalance) && !(message.totalBalance && $util.isInteger(message.totalBalance.low) && $util.isInteger(message.totalBalance.high)))
                    return "totalBalance: integer|Long expected";
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                if (!$util.isInteger(message.confirmedBalance) && !(message.confirmedBalance && $util.isInteger(message.confirmedBalance.low) && $util.isInteger(message.confirmedBalance.high)))
                    return "confirmedBalance: integer|Long expected";
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                if (!$util.isInteger(message.unconfirmedBalance) && !(message.unconfirmedBalance && $util.isInteger(message.unconfirmedBalance.low) && $util.isInteger(message.unconfirmedBalance.high)))
                    return "unconfirmedBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates a WalletBalanceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         */
        WalletBalanceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.WalletBalanceResponse)
                return object;
            var message = new $root.lnrpc.WalletBalanceResponse();
            if (object.totalBalance != null)
                if ($util.Long)
                    (message.totalBalance = $util.Long.fromValue(object.totalBalance)).unsigned = false;
                else if (typeof object.totalBalance === "string")
                    message.totalBalance = parseInt(object.totalBalance, 10);
                else if (typeof object.totalBalance === "number")
                    message.totalBalance = object.totalBalance;
                else if (typeof object.totalBalance === "object")
                    message.totalBalance = new $util.LongBits(object.totalBalance.low >>> 0, object.totalBalance.high >>> 0).toNumber();
            if (object.confirmedBalance != null)
                if ($util.Long)
                    (message.confirmedBalance = $util.Long.fromValue(object.confirmedBalance)).unsigned = false;
                else if (typeof object.confirmedBalance === "string")
                    message.confirmedBalance = parseInt(object.confirmedBalance, 10);
                else if (typeof object.confirmedBalance === "number")
                    message.confirmedBalance = object.confirmedBalance;
                else if (typeof object.confirmedBalance === "object")
                    message.confirmedBalance = new $util.LongBits(object.confirmedBalance.low >>> 0, object.confirmedBalance.high >>> 0).toNumber();
            if (object.unconfirmedBalance != null)
                if ($util.Long)
                    (message.unconfirmedBalance = $util.Long.fromValue(object.unconfirmedBalance)).unsigned = false;
                else if (typeof object.unconfirmedBalance === "string")
                    message.unconfirmedBalance = parseInt(object.unconfirmedBalance, 10);
                else if (typeof object.unconfirmedBalance === "number")
                    message.unconfirmedBalance = object.unconfirmedBalance;
                else if (typeof object.unconfirmedBalance === "object")
                    message.unconfirmedBalance = new $util.LongBits(object.unconfirmedBalance.low >>> 0, object.unconfirmedBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a WalletBalanceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.WalletBalanceResponse} message WalletBalanceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WalletBalanceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.confirmedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.confirmedBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.unconfirmedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unconfirmedBalance = options.longs === String ? "0" : 0;
            }
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                if (typeof message.totalBalance === "number")
                    object.totalBalance = options.longs === String ? String(message.totalBalance) : message.totalBalance;
                else
                    object.totalBalance = options.longs === String ? $util.Long.prototype.toString.call(message.totalBalance) : options.longs === Number ? new $util.LongBits(message.totalBalance.low >>> 0, message.totalBalance.high >>> 0).toNumber() : message.totalBalance;
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                if (typeof message.confirmedBalance === "number")
                    object.confirmedBalance = options.longs === String ? String(message.confirmedBalance) : message.confirmedBalance;
                else
                    object.confirmedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.confirmedBalance) : options.longs === Number ? new $util.LongBits(message.confirmedBalance.low >>> 0, message.confirmedBalance.high >>> 0).toNumber() : message.confirmedBalance;
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                if (typeof message.unconfirmedBalance === "number")
                    object.unconfirmedBalance = options.longs === String ? String(message.unconfirmedBalance) : message.unconfirmedBalance;
                else
                    object.unconfirmedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.unconfirmedBalance) : options.longs === Number ? new $util.LongBits(message.unconfirmedBalance.low >>> 0, message.unconfirmedBalance.high >>> 0).toNumber() : message.unconfirmedBalance;
            return object;
        };

        /**
         * Converts this WalletBalanceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WalletBalanceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WalletBalanceResponse;
    })();

    lnrpc.ChannelBalanceRequest = (function() {

        /**
         * Properties of a ChannelBalanceRequest.
         * @memberof lnrpc
         * @interface IChannelBalanceRequest
         */

        /**
         * Constructs a new ChannelBalanceRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBalanceRequest.
         * @implements IChannelBalanceRequest
         * @constructor
         * @param {lnrpc.IChannelBalanceRequest=} [properties] Properties to set
         */
        function ChannelBalanceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelBalanceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest instance
         */
        ChannelBalanceRequest.create = function create(properties) {
            return new ChannelBalanceRequest(properties);
        };

        /**
         * Encodes the specified ChannelBalanceRequest message. Does not implicitly {@link lnrpc.ChannelBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest} message ChannelBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelBalanceRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest} message ChannelBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBalanceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBalanceRequest message.
         * @function verify
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         */
        ChannelBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBalanceRequest)
                return object;
            return new $root.lnrpc.ChannelBalanceRequest();
        };

        /**
         * Creates a plain object from a ChannelBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.ChannelBalanceRequest} message ChannelBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBalanceRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelBalanceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBalanceRequest;
    })();

    lnrpc.ChannelBalanceResponse = (function() {

        /**
         * Properties of a ChannelBalanceResponse.
         * @memberof lnrpc
         * @interface IChannelBalanceResponse
         * @property {number|Long|null} [balance] Sum of channels balances denominated in satoshis
         * @property {number|Long|null} [pendingOpenBalance] Sum of channels pending balances denominated in satoshis
         */

        /**
         * Constructs a new ChannelBalanceResponse.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBalanceResponse.
         * @implements IChannelBalanceResponse
         * @constructor
         * @param {lnrpc.IChannelBalanceResponse=} [properties] Properties to set
         */
        function ChannelBalanceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Sum of channels balances denominated in satoshis
         * @member {number|Long} balance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Sum of channels pending balances denominated in satoshis
         * @member {number|Long} pendingOpenBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.pendingOpenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChannelBalanceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse=} [properties] Properties to set
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse instance
         */
        ChannelBalanceResponse.create = function create(properties) {
            return new ChannelBalanceResponse(properties);
        };

        /**
         * Encodes the specified ChannelBalanceResponse message. Does not implicitly {@link lnrpc.ChannelBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse} message ChannelBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.balance != null && message.hasOwnProperty("balance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.balance);
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.pendingOpenBalance);
            return writer;
        };

        /**
         * Encodes the specified ChannelBalanceResponse message, length delimited. Does not implicitly {@link lnrpc.ChannelBalanceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse} message ChannelBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBalanceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.balance = reader.int64();
                    break;
                case 2:
                    message.pendingOpenBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBalanceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBalanceResponse message.
         * @function verify
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBalanceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                if (!$util.isInteger(message.pendingOpenBalance) && !(message.pendingOpenBalance && $util.isInteger(message.pendingOpenBalance.low) && $util.isInteger(message.pendingOpenBalance.high)))
                    return "pendingOpenBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelBalanceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         */
        ChannelBalanceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBalanceResponse)
                return object;
            var message = new $root.lnrpc.ChannelBalanceResponse();
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
            if (object.pendingOpenBalance != null)
                if ($util.Long)
                    (message.pendingOpenBalance = $util.Long.fromValue(object.pendingOpenBalance)).unsigned = false;
                else if (typeof object.pendingOpenBalance === "string")
                    message.pendingOpenBalance = parseInt(object.pendingOpenBalance, 10);
                else if (typeof object.pendingOpenBalance === "number")
                    message.pendingOpenBalance = object.pendingOpenBalance;
                else if (typeof object.pendingOpenBalance === "object")
                    message.pendingOpenBalance = new $util.LongBits(object.pendingOpenBalance.low >>> 0, object.pendingOpenBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChannelBalanceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.ChannelBalanceResponse} message ChannelBalanceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBalanceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.pendingOpenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pendingOpenBalance = options.longs === String ? "0" : 0;
            }
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                if (typeof message.pendingOpenBalance === "number")
                    object.pendingOpenBalance = options.longs === String ? String(message.pendingOpenBalance) : message.pendingOpenBalance;
                else
                    object.pendingOpenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.pendingOpenBalance) : options.longs === Number ? new $util.LongBits(message.pendingOpenBalance.low >>> 0, message.pendingOpenBalance.high >>> 0).toNumber() : message.pendingOpenBalance;
            return object;
        };

        /**
         * Converts this ChannelBalanceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBalanceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBalanceResponse;
    })();

    lnrpc.QueryRoutesRequest = (function() {

        /**
         * Properties of a QueryRoutesRequest.
         * @memberof lnrpc
         * @interface IQueryRoutesRequest
         * @property {string|null} [pubKey] The 33-byte hex-encoded public key for the payment destination
         * @property {number|Long|null} [amt] The amount to send expressed in satoshis
         * @property {number|null} [numRoutes] The max number of routes to return.
         * @property {number|null} [finalCltvDelta] An optional CLTV delta from the current height that should be used for the timelock of the final hop
         * @property {lnrpc.IFeeLimit|null} [feeLimit] The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         */

        /**
         * Constructs a new QueryRoutesRequest.
         * @memberof lnrpc
         * @classdesc Represents a QueryRoutesRequest.
         * @implements IQueryRoutesRequest
         * @constructor
         * @param {lnrpc.IQueryRoutesRequest=} [properties] Properties to set
         */
        function QueryRoutesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The 33-byte hex-encoded public key for the payment destination
         * @member {string} pubKey
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.pubKey = "";

        /**
         * The amount to send expressed in satoshis
         * @member {number|Long} amt
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The max number of routes to return.
         * @member {number} numRoutes
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.numRoutes = 0;

        /**
         * An optional CLTV delta from the current height that should be used for the timelock of the final hop
         * @member {number} finalCltvDelta
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.finalCltvDelta = 0;

        /**
         * The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         * @member {lnrpc.IFeeLimit|null|undefined} feeLimit
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.feeLimit = null;

        /**
         * Creates a new QueryRoutesRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest=} [properties] Properties to set
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest instance
         */
        QueryRoutesRequest.create = function create(properties) {
            return new QueryRoutesRequest(properties);
        };

        /**
         * Encodes the specified QueryRoutesRequest message. Does not implicitly {@link lnrpc.QueryRoutesRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest} message QueryRoutesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.amt != null && message.hasOwnProperty("amt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amt);
            if (message.numRoutes != null && message.hasOwnProperty("numRoutes"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numRoutes);
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.finalCltvDelta);
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                $root.lnrpc.FeeLimit.encode(message.feeLimit, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryRoutesRequest message, length delimited. Does not implicitly {@link lnrpc.QueryRoutesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest} message QueryRoutesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoutesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryRoutesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.amt = reader.int64();
                    break;
                case 3:
                    message.numRoutes = reader.int32();
                    break;
                case 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case 5:
                    message.feeLimit = $root.lnrpc.FeeLimit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoutesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoutesRequest message.
         * @function verify
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoutesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.numRoutes != null && message.hasOwnProperty("numRoutes"))
                if (!$util.isInteger(message.numRoutes))
                    return "numRoutes: integer expected";
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                if (!$util.isInteger(message.finalCltvDelta))
                    return "finalCltvDelta: integer expected";
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit")) {
                var error = $root.lnrpc.FeeLimit.verify(message.feeLimit);
                if (error)
                    return "feeLimit." + error;
            }
            return null;
        };

        /**
         * Creates a QueryRoutesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         */
        QueryRoutesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryRoutesRequest)
                return object;
            var message = new $root.lnrpc.QueryRoutesRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.numRoutes != null)
                message.numRoutes = object.numRoutes | 0;
            if (object.finalCltvDelta != null)
                message.finalCltvDelta = object.finalCltvDelta | 0;
            if (object.feeLimit != null) {
                if (typeof object.feeLimit !== "object")
                    throw TypeError(".lnrpc.QueryRoutesRequest.feeLimit: object expected");
                message.feeLimit = $root.lnrpc.FeeLimit.fromObject(object.feeLimit);
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryRoutesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.QueryRoutesRequest} message QueryRoutesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRoutesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pubKey = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                object.numRoutes = 0;
                object.finalCltvDelta = 0;
                object.feeLimit = null;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.numRoutes != null && message.hasOwnProperty("numRoutes"))
                object.numRoutes = message.numRoutes;
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                object.finalCltvDelta = message.finalCltvDelta;
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                object.feeLimit = $root.lnrpc.FeeLimit.toObject(message.feeLimit, options);
            return object;
        };

        /**
         * Converts this QueryRoutesRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRoutesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRoutesRequest;
    })();

    lnrpc.QueryRoutesResponse = (function() {

        /**
         * Properties of a QueryRoutesResponse.
         * @memberof lnrpc
         * @interface IQueryRoutesResponse
         * @property {Array.<lnrpc.IRoute>|null} [routes] QueryRoutesResponse routes
         */

        /**
         * Constructs a new QueryRoutesResponse.
         * @memberof lnrpc
         * @classdesc Represents a QueryRoutesResponse.
         * @implements IQueryRoutesResponse
         * @constructor
         * @param {lnrpc.IQueryRoutesResponse=} [properties] Properties to set
         */
        function QueryRoutesResponse(properties) {
            this.routes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRoutesResponse routes.
         * @member {Array.<lnrpc.IRoute>} routes
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         */
        QueryRoutesResponse.prototype.routes = $util.emptyArray;

        /**
         * Creates a new QueryRoutesResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse=} [properties] Properties to set
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse instance
         */
        QueryRoutesResponse.create = function create(properties) {
            return new QueryRoutesResponse(properties);
        };

        /**
         * Encodes the specified QueryRoutesResponse message. Does not implicitly {@link lnrpc.QueryRoutesResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse} message QueryRoutesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.routes != null && message.routes.length)
                for (var i = 0; i < message.routes.length; ++i)
                    $root.lnrpc.Route.encode(message.routes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryRoutesResponse message, length delimited. Does not implicitly {@link lnrpc.QueryRoutesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse} message QueryRoutesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoutesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryRoutesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.routes && message.routes.length))
                        message.routes = [];
                    message.routes.push($root.lnrpc.Route.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoutesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoutesResponse message.
         * @function verify
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoutesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.routes != null && message.hasOwnProperty("routes")) {
                if (!Array.isArray(message.routes))
                    return "routes: array expected";
                for (var i = 0; i < message.routes.length; ++i) {
                    var error = $root.lnrpc.Route.verify(message.routes[i]);
                    if (error)
                        return "routes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryRoutesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         */
        QueryRoutesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryRoutesResponse)
                return object;
            var message = new $root.lnrpc.QueryRoutesResponse();
            if (object.routes) {
                if (!Array.isArray(object.routes))
                    throw TypeError(".lnrpc.QueryRoutesResponse.routes: array expected");
                message.routes = [];
                for (var i = 0; i < object.routes.length; ++i) {
                    if (typeof object.routes[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesResponse.routes: object expected");
                    message.routes[i] = $root.lnrpc.Route.fromObject(object.routes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryRoutesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.QueryRoutesResponse} message QueryRoutesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRoutesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.routes = [];
            if (message.routes && message.routes.length) {
                object.routes = [];
                for (var j = 0; j < message.routes.length; ++j)
                    object.routes[j] = $root.lnrpc.Route.toObject(message.routes[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryRoutesResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRoutesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRoutesResponse;
    })();

    lnrpc.Hop = (function() {

        /**
         * Properties of a Hop.
         * @memberof lnrpc
         * @interface IHop
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {number|Long|null} [chanCapacity] Hop chanCapacity
         * @property {number|Long|null} [amtToForward] Hop amtToForward
         * @property {number|Long|null} [fee] Hop fee
         * @property {number|null} [expiry] Hop expiry
         * @property {number|Long|null} [amtToForwardMsat] Hop amtToForwardMsat
         * @property {number|Long|null} [feeMsat] Hop feeMsat
         */

        /**
         * Constructs a new Hop.
         * @memberof lnrpc
         * @classdesc Represents a Hop.
         * @implements IHop
         * @constructor
         * @param {lnrpc.IHop=} [properties] Properties to set
         */
        function Hop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Hop chanCapacity.
         * @member {number|Long} chanCapacity
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.chanCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop amtToForward.
         * @member {number|Long} amtToForward
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.amtToForward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop fee.
         * @member {number|Long} fee
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop expiry.
         * @member {number} expiry
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.expiry = 0;

        /**
         * Hop amtToForwardMsat.
         * @member {number|Long} amtToForwardMsat
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.amtToForwardMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop feeMsat.
         * @member {number|Long} feeMsat
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Hop instance using the specified properties.
         * @function create
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop=} [properties] Properties to set
         * @returns {lnrpc.Hop} Hop instance
         */
        Hop.create = function create(properties) {
            return new Hop(properties);
        };

        /**
         * Encodes the specified Hop message. Does not implicitly {@link lnrpc.Hop.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop} message Hop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.chanCapacity);
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amtToForward);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.expiry);
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.amtToForwardMsat);
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.feeMsat);
            return writer;
        };

        /**
         * Encodes the specified Hop message, length delimited. Does not implicitly {@link lnrpc.Hop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop} message Hop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hop message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Hop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Hop} Hop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Hop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.chanCapacity = reader.int64();
                    break;
                case 3:
                    message.amtToForward = reader.int64();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.expiry = reader.uint32();
                    break;
                case 6:
                    message.amtToForwardMsat = reader.int64();
                    break;
                case 7:
                    message.feeMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Hop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Hop} Hop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hop message.
         * @function verify
         * @memberof lnrpc.Hop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                if (!$util.isInteger(message.chanCapacity) && !(message.chanCapacity && $util.isInteger(message.chanCapacity.low) && $util.isInteger(message.chanCapacity.high)))
                    return "chanCapacity: integer|Long expected";
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                if (!$util.isInteger(message.amtToForward) && !(message.amtToForward && $util.isInteger(message.amtToForward.low) && $util.isInteger(message.amtToForward.high)))
                    return "amtToForward: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry))
                    return "expiry: integer expected";
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                if (!$util.isInteger(message.amtToForwardMsat) && !(message.amtToForwardMsat && $util.isInteger(message.amtToForwardMsat.low) && $util.isInteger(message.amtToForwardMsat.high)))
                    return "amtToForwardMsat: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a Hop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Hop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Hop} Hop
         */
        Hop.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Hop)
                return object;
            var message = new $root.lnrpc.Hop();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chanCapacity != null)
                if ($util.Long)
                    (message.chanCapacity = $util.Long.fromValue(object.chanCapacity)).unsigned = false;
                else if (typeof object.chanCapacity === "string")
                    message.chanCapacity = parseInt(object.chanCapacity, 10);
                else if (typeof object.chanCapacity === "number")
                    message.chanCapacity = object.chanCapacity;
                else if (typeof object.chanCapacity === "object")
                    message.chanCapacity = new $util.LongBits(object.chanCapacity.low >>> 0, object.chanCapacity.high >>> 0).toNumber();
            if (object.amtToForward != null)
                if ($util.Long)
                    (message.amtToForward = $util.Long.fromValue(object.amtToForward)).unsigned = false;
                else if (typeof object.amtToForward === "string")
                    message.amtToForward = parseInt(object.amtToForward, 10);
                else if (typeof object.amtToForward === "number")
                    message.amtToForward = object.amtToForward;
                else if (typeof object.amtToForward === "object")
                    message.amtToForward = new $util.LongBits(object.amtToForward.low >>> 0, object.amtToForward.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.expiry != null)
                message.expiry = object.expiry >>> 0;
            if (object.amtToForwardMsat != null)
                if ($util.Long)
                    (message.amtToForwardMsat = $util.Long.fromValue(object.amtToForwardMsat)).unsigned = false;
                else if (typeof object.amtToForwardMsat === "string")
                    message.amtToForwardMsat = parseInt(object.amtToForwardMsat, 10);
                else if (typeof object.amtToForwardMsat === "number")
                    message.amtToForwardMsat = object.amtToForwardMsat;
                else if (typeof object.amtToForwardMsat === "object")
                    message.amtToForwardMsat = new $util.LongBits(object.amtToForwardMsat.low >>> 0, object.amtToForwardMsat.high >>> 0).toNumber();
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = false;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Hop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.Hop} message Hop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.chanCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanCapacity = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amtToForward = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtToForward = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.expiry = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amtToForwardMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtToForwardMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                if (typeof message.chanCapacity === "number")
                    object.chanCapacity = options.longs === String ? String(message.chanCapacity) : message.chanCapacity;
                else
                    object.chanCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.chanCapacity) : options.longs === Number ? new $util.LongBits(message.chanCapacity.low >>> 0, message.chanCapacity.high >>> 0).toNumber() : message.chanCapacity;
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                if (typeof message.amtToForward === "number")
                    object.amtToForward = options.longs === String ? String(message.amtToForward) : message.amtToForward;
                else
                    object.amtToForward = options.longs === String ? $util.Long.prototype.toString.call(message.amtToForward) : options.longs === Number ? new $util.LongBits(message.amtToForward.low >>> 0, message.amtToForward.high >>> 0).toNumber() : message.amtToForward;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                object.expiry = message.expiry;
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                if (typeof message.amtToForwardMsat === "number")
                    object.amtToForwardMsat = options.longs === String ? String(message.amtToForwardMsat) : message.amtToForwardMsat;
                else
                    object.amtToForwardMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtToForwardMsat) : options.longs === Number ? new $util.LongBits(message.amtToForwardMsat.low >>> 0, message.amtToForwardMsat.high >>> 0).toNumber() : message.amtToForwardMsat;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber() : message.feeMsat;
            return object;
        };

        /**
         * Converts this Hop to JSON.
         * @function toJSON
         * @memberof lnrpc.Hop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Hop;
    })();

    lnrpc.Route = (function() {

        /**
         * Properties of a Route.
         * @memberof lnrpc
         * @interface IRoute
         * @property {number|null} [totalTimeLock] The cumulative (final) time lock across the entire route.  This is the CLTV
         * value that should be extended to the first hop in the route. All other hops
         * will decrement the time-lock as advertised, leaving enough time for all
         * hops to wait for or present the payment preimage to complete the payment.
         * @property {number|Long|null} [totalFees] The sum of the fees paid at each hop within the final route.  In the case
         * of a one-hop payment, this value will be zero as we don't need to pay a fee
         * it ourself.
         * @property {number|Long|null} [totalAmt] The total amount of funds required to complete a payment over this route.
         * This value includes the cumulative fees at each hop. As a result, the HTLC
         * extended to the first-hop in the route will need to have at least this many
         * satoshis, otherwise the route will fail at an intermediate node due to an
         * insufficient amount of fees.
         * @property {Array.<lnrpc.IHop>|null} [hops] Contains details concerning the specific forwarding details at each hop.
         * @property {number|Long|null} [totalFeesMsat] The total fees in millisatoshis.
         * @property {number|Long|null} [totalAmtMsat] The total amount in millisatoshis.
         */

        /**
         * Constructs a new Route.
         * @memberof lnrpc
         * @classdesc A path through the channel graph which runs over one or more channels in
         * succession. This struct carries all the information required to craft the
         * Sphinx onion packet, and send the payment along the first hop in the path. A
         * route is only selected as valid if all the channels have sufficient capacity to
         * carry the initial payment amount after fees are accounted for.
         * @implements IRoute
         * @constructor
         * @param {lnrpc.IRoute=} [properties] Properties to set
         */
        function Route(properties) {
            this.hops = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The cumulative (final) time lock across the entire route.  This is the CLTV
         * value that should be extended to the first hop in the route. All other hops
         * will decrement the time-lock as advertised, leaving enough time for all
         * hops to wait for or present the payment preimage to complete the payment.
         * @member {number} totalTimeLock
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalTimeLock = 0;

        /**
         * The sum of the fees paid at each hop within the final route.  In the case
         * of a one-hop payment, this value will be zero as we don't need to pay a fee
         * it ourself.
         * @member {number|Long} totalFees
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalFees = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount of funds required to complete a payment over this route.
         * This value includes the cumulative fees at each hop. As a result, the HTLC
         * extended to the first-hop in the route will need to have at least this many
         * satoshis, otherwise the route will fail at an intermediate node due to an
         * insufficient amount of fees.
         * @member {number|Long} totalAmt
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalAmt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Contains details concerning the specific forwarding details at each hop.
         * @member {Array.<lnrpc.IHop>} hops
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.hops = $util.emptyArray;

        /**
         * The total fees in millisatoshis.
         * @member {number|Long} totalFeesMsat
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalFeesMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount in millisatoshis.
         * @member {number|Long} totalAmtMsat
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalAmtMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Route instance using the specified properties.
         * @function create
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute=} [properties] Properties to set
         * @returns {lnrpc.Route} Route instance
         */
        Route.create = function create(properties) {
            return new Route(properties);
        };

        /**
         * Encodes the specified Route message. Does not implicitly {@link lnrpc.Route.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute} message Route message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Route.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.totalTimeLock);
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalFees);
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalAmt);
            if (message.hops != null && message.hops.length)
                for (var i = 0; i < message.hops.length; ++i)
                    $root.lnrpc.Hop.encode(message.hops[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.totalFeesMsat);
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalAmtMsat);
            return writer;
        };

        /**
         * Encodes the specified Route message, length delimited. Does not implicitly {@link lnrpc.Route.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute} message Route message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Route.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Route message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Route
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Route} Route
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Route.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Route();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalTimeLock = reader.uint32();
                    break;
                case 2:
                    message.totalFees = reader.int64();
                    break;
                case 3:
                    message.totalAmt = reader.int64();
                    break;
                case 4:
                    if (!(message.hops && message.hops.length))
                        message.hops = [];
                    message.hops.push($root.lnrpc.Hop.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.totalFeesMsat = reader.int64();
                    break;
                case 6:
                    message.totalAmtMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Route message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Route
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Route} Route
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Route.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Route message.
         * @function verify
         * @memberof lnrpc.Route
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Route.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                if (!$util.isInteger(message.totalTimeLock))
                    return "totalTimeLock: integer expected";
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (!$util.isInteger(message.totalFees) && !(message.totalFees && $util.isInteger(message.totalFees.low) && $util.isInteger(message.totalFees.high)))
                    return "totalFees: integer|Long expected";
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                if (!$util.isInteger(message.totalAmt) && !(message.totalAmt && $util.isInteger(message.totalAmt.low) && $util.isInteger(message.totalAmt.high)))
                    return "totalAmt: integer|Long expected";
            if (message.hops != null && message.hasOwnProperty("hops")) {
                if (!Array.isArray(message.hops))
                    return "hops: array expected";
                for (var i = 0; i < message.hops.length; ++i) {
                    var error = $root.lnrpc.Hop.verify(message.hops[i]);
                    if (error)
                        return "hops." + error;
                }
            }
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                if (!$util.isInteger(message.totalFeesMsat) && !(message.totalFeesMsat && $util.isInteger(message.totalFeesMsat.low) && $util.isInteger(message.totalFeesMsat.high)))
                    return "totalFeesMsat: integer|Long expected";
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (!$util.isInteger(message.totalAmtMsat) && !(message.totalAmtMsat && $util.isInteger(message.totalAmtMsat.low) && $util.isInteger(message.totalAmtMsat.high)))
                    return "totalAmtMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a Route message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Route
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Route} Route
         */
        Route.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Route)
                return object;
            var message = new $root.lnrpc.Route();
            if (object.totalTimeLock != null)
                message.totalTimeLock = object.totalTimeLock >>> 0;
            if (object.totalFees != null)
                if ($util.Long)
                    (message.totalFees = $util.Long.fromValue(object.totalFees)).unsigned = false;
                else if (typeof object.totalFees === "string")
                    message.totalFees = parseInt(object.totalFees, 10);
                else if (typeof object.totalFees === "number")
                    message.totalFees = object.totalFees;
                else if (typeof object.totalFees === "object")
                    message.totalFees = new $util.LongBits(object.totalFees.low >>> 0, object.totalFees.high >>> 0).toNumber();
            if (object.totalAmt != null)
                if ($util.Long)
                    (message.totalAmt = $util.Long.fromValue(object.totalAmt)).unsigned = false;
                else if (typeof object.totalAmt === "string")
                    message.totalAmt = parseInt(object.totalAmt, 10);
                else if (typeof object.totalAmt === "number")
                    message.totalAmt = object.totalAmt;
                else if (typeof object.totalAmt === "object")
                    message.totalAmt = new $util.LongBits(object.totalAmt.low >>> 0, object.totalAmt.high >>> 0).toNumber();
            if (object.hops) {
                if (!Array.isArray(object.hops))
                    throw TypeError(".lnrpc.Route.hops: array expected");
                message.hops = [];
                for (var i = 0; i < object.hops.length; ++i) {
                    if (typeof object.hops[i] !== "object")
                        throw TypeError(".lnrpc.Route.hops: object expected");
                    message.hops[i] = $root.lnrpc.Hop.fromObject(object.hops[i]);
                }
            }
            if (object.totalFeesMsat != null)
                if ($util.Long)
                    (message.totalFeesMsat = $util.Long.fromValue(object.totalFeesMsat)).unsigned = false;
                else if (typeof object.totalFeesMsat === "string")
                    message.totalFeesMsat = parseInt(object.totalFeesMsat, 10);
                else if (typeof object.totalFeesMsat === "number")
                    message.totalFeesMsat = object.totalFeesMsat;
                else if (typeof object.totalFeesMsat === "object")
                    message.totalFeesMsat = new $util.LongBits(object.totalFeesMsat.low >>> 0, object.totalFeesMsat.high >>> 0).toNumber();
            if (object.totalAmtMsat != null)
                if ($util.Long)
                    (message.totalAmtMsat = $util.Long.fromValue(object.totalAmtMsat)).unsigned = false;
                else if (typeof object.totalAmtMsat === "string")
                    message.totalAmtMsat = parseInt(object.totalAmtMsat, 10);
                else if (typeof object.totalAmtMsat === "number")
                    message.totalAmtMsat = object.totalAmtMsat;
                else if (typeof object.totalAmtMsat === "object")
                    message.totalAmtMsat = new $util.LongBits(object.totalAmtMsat.low >>> 0, object.totalAmtMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Route message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.Route} message Route
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Route.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hops = [];
            if (options.defaults) {
                object.totalTimeLock = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalFees = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFees = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalAmt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalFeesMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFeesMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalAmtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmtMsat = options.longs === String ? "0" : 0;
            }
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                object.totalTimeLock = message.totalTimeLock;
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (typeof message.totalFees === "number")
                    object.totalFees = options.longs === String ? String(message.totalFees) : message.totalFees;
                else
                    object.totalFees = options.longs === String ? $util.Long.prototype.toString.call(message.totalFees) : options.longs === Number ? new $util.LongBits(message.totalFees.low >>> 0, message.totalFees.high >>> 0).toNumber() : message.totalFees;
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                if (typeof message.totalAmt === "number")
                    object.totalAmt = options.longs === String ? String(message.totalAmt) : message.totalAmt;
                else
                    object.totalAmt = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmt) : options.longs === Number ? new $util.LongBits(message.totalAmt.low >>> 0, message.totalAmt.high >>> 0).toNumber() : message.totalAmt;
            if (message.hops && message.hops.length) {
                object.hops = [];
                for (var j = 0; j < message.hops.length; ++j)
                    object.hops[j] = $root.lnrpc.Hop.toObject(message.hops[j], options);
            }
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                if (typeof message.totalFeesMsat === "number")
                    object.totalFeesMsat = options.longs === String ? String(message.totalFeesMsat) : message.totalFeesMsat;
                else
                    object.totalFeesMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalFeesMsat) : options.longs === Number ? new $util.LongBits(message.totalFeesMsat.low >>> 0, message.totalFeesMsat.high >>> 0).toNumber() : message.totalFeesMsat;
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (typeof message.totalAmtMsat === "number")
                    object.totalAmtMsat = options.longs === String ? String(message.totalAmtMsat) : message.totalAmtMsat;
                else
                    object.totalAmtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmtMsat) : options.longs === Number ? new $util.LongBits(message.totalAmtMsat.low >>> 0, message.totalAmtMsat.high >>> 0).toNumber() : message.totalAmtMsat;
            return object;
        };

        /**
         * Converts this Route to JSON.
         * @function toJSON
         * @memberof lnrpc.Route
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Route.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Route;
    })();

    lnrpc.NodeInfoRequest = (function() {

        /**
         * Properties of a NodeInfoRequest.
         * @memberof lnrpc
         * @interface INodeInfoRequest
         * @property {string|null} [pubKey] The 33-byte hex-encoded compressed public of the target node
         */

        /**
         * Constructs a new NodeInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a NodeInfoRequest.
         * @implements INodeInfoRequest
         * @constructor
         * @param {lnrpc.INodeInfoRequest=} [properties] Properties to set
         */
        function NodeInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The 33-byte hex-encoded compressed public of the target node
         * @member {string} pubKey
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         */
        NodeInfoRequest.prototype.pubKey = "";

        /**
         * Creates a new NodeInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest instance
         */
        NodeInfoRequest.create = function create(properties) {
            return new NodeInfoRequest(properties);
        };

        /**
         * Encodes the specified NodeInfoRequest message. Does not implicitly {@link lnrpc.NodeInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            return writer;
        };

        /**
         * Encodes the specified NodeInfoRequest message, length delimited. Does not implicitly {@link lnrpc.NodeInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfoRequest message.
         * @function verify
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            return null;
        };

        /**
         * Creates a NodeInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         */
        NodeInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeInfoRequest)
                return object;
            var message = new $root.lnrpc.NodeInfoRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            return message;
        };

        /**
         * Creates a plain object from a NodeInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.NodeInfoRequest} message NodeInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pubKey = "";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            return object;
        };

        /**
         * Converts this NodeInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeInfoRequest;
    })();

    lnrpc.NodeInfo = (function() {

        /**
         * Properties of a NodeInfo.
         * @memberof lnrpc
         * @interface INodeInfo
         * @property {lnrpc.ILightningNode|null} [node] An individual vertex/node within the channel graph. A node is
         * connected to other nodes by one or more channel edges emanating from it. As
         * the graph is directed, a node will also have an incoming edge attached to
         * it for each outgoing edge.
         * @property {number|null} [numChannels] NodeInfo numChannels
         * @property {number|Long|null} [totalCapacity] NodeInfo totalCapacity
         */

        /**
         * Constructs a new NodeInfo.
         * @memberof lnrpc
         * @classdesc Represents a NodeInfo.
         * @implements INodeInfo
         * @constructor
         * @param {lnrpc.INodeInfo=} [properties] Properties to set
         */
        function NodeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An individual vertex/node within the channel graph. A node is
         * connected to other nodes by one or more channel edges emanating from it. As
         * the graph is directed, a node will also have an incoming edge attached to
         * it for each outgoing edge.
         * @member {lnrpc.ILightningNode|null|undefined} node
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.node = null;

        /**
         * NodeInfo numChannels.
         * @member {number} numChannels
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.numChannels = 0;

        /**
         * NodeInfo totalCapacity.
         * @member {number|Long} totalCapacity
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.totalCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NodeInfo instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo=} [properties] Properties to set
         * @returns {lnrpc.NodeInfo} NodeInfo instance
         */
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };

        /**
         * Encodes the specified NodeInfo message. Does not implicitly {@link lnrpc.NodeInfo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.node != null && message.hasOwnProperty("node"))
                $root.lnrpc.LightningNode.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numChannels);
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalCapacity);
            return writer;
        };

        /**
         * Encodes the specified NodeInfo message, length delimited. Does not implicitly {@link lnrpc.NodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.node = $root.lnrpc.LightningNode.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.numChannels = reader.uint32();
                    break;
                case 3:
                    message.totalCapacity = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfo message.
         * @function verify
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
                var error = $root.lnrpc.LightningNode.verify(message.node);
                if (error)
                    return "node." + error;
            }
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                if (!$util.isInteger(message.totalCapacity) && !(message.totalCapacity && $util.isInteger(message.totalCapacity.low) && $util.isInteger(message.totalCapacity.high)))
                    return "totalCapacity: integer|Long expected";
            return null;
        };

        /**
         * Creates a NodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeInfo} NodeInfo
         */
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeInfo)
                return object;
            var message = new $root.lnrpc.NodeInfo();
            if (object.node != null) {
                if (typeof object.node !== "object")
                    throw TypeError(".lnrpc.NodeInfo.node: object expected");
                message.node = $root.lnrpc.LightningNode.fromObject(object.node);
            }
            if (object.numChannels != null)
                message.numChannels = object.numChannels >>> 0;
            if (object.totalCapacity != null)
                if ($util.Long)
                    (message.totalCapacity = $util.Long.fromValue(object.totalCapacity)).unsigned = false;
                else if (typeof object.totalCapacity === "string")
                    message.totalCapacity = parseInt(object.totalCapacity, 10);
                else if (typeof object.totalCapacity === "number")
                    message.totalCapacity = object.totalCapacity;
                else if (typeof object.totalCapacity === "object")
                    message.totalCapacity = new $util.LongBits(object.totalCapacity.low >>> 0, object.totalCapacity.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a NodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.NodeInfo} message NodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.node = null;
                object.numChannels = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalCapacity = options.longs === String ? "0" : 0;
            }
            if (message.node != null && message.hasOwnProperty("node"))
                object.node = $root.lnrpc.LightningNode.toObject(message.node, options);
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                if (typeof message.totalCapacity === "number")
                    object.totalCapacity = options.longs === String ? String(message.totalCapacity) : message.totalCapacity;
                else
                    object.totalCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.totalCapacity) : options.longs === Number ? new $util.LongBits(message.totalCapacity.low >>> 0, message.totalCapacity.high >>> 0).toNumber() : message.totalCapacity;
            return object;
        };

        /**
         * Converts this NodeInfo to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeInfo;
    })();

    lnrpc.LightningNode = (function() {

        /**
         * Properties of a LightningNode.
         * @memberof lnrpc
         * @interface ILightningNode
         * @property {number|null} [lastUpdate] LightningNode lastUpdate
         * @property {string|null} [pubKey] LightningNode pubKey
         * @property {string|null} [alias] LightningNode alias
         * @property {Array.<lnrpc.INodeAddress>|null} [addresses] LightningNode addresses
         * @property {string|null} [color] LightningNode color
         */

        /**
         * Constructs a new LightningNode.
         * @memberof lnrpc
         * @classdesc An individual vertex/node within the channel graph. A node is
         * connected to other nodes by one or more channel edges emanating from it. As the
         * graph is directed, a node will also have an incoming edge attached to it for
         * each outgoing edge.
         * @implements ILightningNode
         * @constructor
         * @param {lnrpc.ILightningNode=} [properties] Properties to set
         */
        function LightningNode(properties) {
            this.addresses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightningNode lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.lastUpdate = 0;

        /**
         * LightningNode pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.pubKey = "";

        /**
         * LightningNode alias.
         * @member {string} alias
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.alias = "";

        /**
         * LightningNode addresses.
         * @member {Array.<lnrpc.INodeAddress>} addresses
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.addresses = $util.emptyArray;

        /**
         * LightningNode color.
         * @member {string} color
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.color = "";

        /**
         * Creates a new LightningNode instance using the specified properties.
         * @function create
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode=} [properties] Properties to set
         * @returns {lnrpc.LightningNode} LightningNode instance
         */
        LightningNode.create = function create(properties) {
            return new LightningNode(properties);
        };

        /**
         * Encodes the specified LightningNode message. Does not implicitly {@link lnrpc.LightningNode.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode} message LightningNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.lastUpdate);
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pubKey);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            if (message.addresses != null && message.addresses.length)
                for (var i = 0; i < message.addresses.length; ++i)
                    $root.lnrpc.NodeAddress.encode(message.addresses[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.color != null && message.hasOwnProperty("color"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
            return writer;
        };

        /**
         * Encodes the specified LightningNode message, length delimited. Does not implicitly {@link lnrpc.LightningNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode} message LightningNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightningNode message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.LightningNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.LightningNode} LightningNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.LightningNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastUpdate = reader.uint32();
                    break;
                case 2:
                    message.pubKey = reader.string();
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                case 4:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push($root.lnrpc.NodeAddress.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightningNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.LightningNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.LightningNode} LightningNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightningNode message.
         * @function verify
         * @memberof lnrpc.LightningNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightningNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (var i = 0; i < message.addresses.length; ++i) {
                    var error = $root.lnrpc.NodeAddress.verify(message.addresses[i]);
                    if (error)
                        return "addresses." + error;
                }
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            return null;
        };

        /**
         * Creates a LightningNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.LightningNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.LightningNode} LightningNode
         */
        LightningNode.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.LightningNode)
                return object;
            var message = new $root.lnrpc.LightningNode();
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".lnrpc.LightningNode.addresses: array expected");
                message.addresses = [];
                for (var i = 0; i < object.addresses.length; ++i) {
                    if (typeof object.addresses[i] !== "object")
                        throw TypeError(".lnrpc.LightningNode.addresses: object expected");
                    message.addresses[i] = $root.lnrpc.NodeAddress.fromObject(object.addresses[i]);
                }
            }
            if (object.color != null)
                message.color = String(object.color);
            return message;
        };

        /**
         * Creates a plain object from a LightningNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.LightningNode} message LightningNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightningNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults) {
                object.lastUpdate = 0;
                object.pubKey = "";
                object.alias = "";
                object.color = "";
            }
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (var j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = $root.lnrpc.NodeAddress.toObject(message.addresses[j], options);
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };

        /**
         * Converts this LightningNode to JSON.
         * @function toJSON
         * @memberof lnrpc.LightningNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightningNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightningNode;
    })();

    lnrpc.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof lnrpc
         * @interface INodeAddress
         * @property {string|null} [network] NodeAddress network
         * @property {string|null} [addr] NodeAddress addr
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof lnrpc
         * @classdesc Represents a NodeAddress.
         * @implements INodeAddress
         * @constructor
         * @param {lnrpc.INodeAddress=} [properties] Properties to set
         */
        function NodeAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeAddress network.
         * @member {string} network
         * @memberof lnrpc.NodeAddress
         * @instance
         */
        NodeAddress.prototype.network = "";

        /**
         * NodeAddress addr.
         * @member {string} addr
         * @memberof lnrpc.NodeAddress
         * @instance
         */
        NodeAddress.prototype.addr = "";

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress=} [properties] Properties to set
         * @returns {lnrpc.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link lnrpc.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.network != null && message.hasOwnProperty("network"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.network);
            if (message.addr != null && message.hasOwnProperty("addr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.addr);
            return writer;
        };

        /**
         * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link lnrpc.NodeAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.network = reader.string();
                    break;
                case 2:
                    message.addr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeAddress message.
         * @function verify
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.network != null && message.hasOwnProperty("network"))
                if (!$util.isString(message.network))
                    return "network: string expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            return null;
        };

        /**
         * Creates a NodeAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeAddress} NodeAddress
         */
        NodeAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeAddress)
                return object;
            var message = new $root.lnrpc.NodeAddress();
            if (object.network != null)
                message.network = String(object.network);
            if (object.addr != null)
                message.addr = String(object.addr);
            return message;
        };

        /**
         * Creates a plain object from a NodeAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.NodeAddress} message NodeAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.network = "";
                object.addr = "";
            }
            if (message.network != null && message.hasOwnProperty("network"))
                object.network = message.network;
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            return object;
        };

        /**
         * Converts this NodeAddress to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeAddress;
    })();

    lnrpc.RoutingPolicy = (function() {

        /**
         * Properties of a RoutingPolicy.
         * @memberof lnrpc
         * @interface IRoutingPolicy
         * @property {number|null} [timeLockDelta] RoutingPolicy timeLockDelta
         * @property {number|Long|null} [minHtlc] RoutingPolicy minHtlc
         * @property {number|Long|null} [feeBaseMsat] RoutingPolicy feeBaseMsat
         * @property {number|Long|null} [feeRateMilliMsat] RoutingPolicy feeRateMilliMsat
         */

        /**
         * Constructs a new RoutingPolicy.
         * @memberof lnrpc
         * @classdesc Represents a RoutingPolicy.
         * @implements IRoutingPolicy
         * @constructor
         * @param {lnrpc.IRoutingPolicy=} [properties] Properties to set
         */
        function RoutingPolicy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoutingPolicy timeLockDelta.
         * @member {number} timeLockDelta
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.timeLockDelta = 0;

        /**
         * RoutingPolicy minHtlc.
         * @member {number|Long} minHtlc
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.minHtlc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy feeBaseMsat.
         * @member {number|Long} feeBaseMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.feeBaseMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy feeRateMilliMsat.
         * @member {number|Long} feeRateMilliMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.feeRateMilliMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RoutingPolicy instance using the specified properties.
         * @function create
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy=} [properties] Properties to set
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy instance
         */
        RoutingPolicy.create = function create(properties) {
            return new RoutingPolicy(properties);
        };

        /**
         * Encodes the specified RoutingPolicy message. Does not implicitly {@link lnrpc.RoutingPolicy.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy} message RoutingPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingPolicy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeLockDelta);
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minHtlc);
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.feeBaseMsat);
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.feeRateMilliMsat);
            return writer;
        };

        /**
         * Encodes the specified RoutingPolicy message, length delimited. Does not implicitly {@link lnrpc.RoutingPolicy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy} message RoutingPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingPolicy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoutingPolicy message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingPolicy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RoutingPolicy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timeLockDelta = reader.uint32();
                    break;
                case 2:
                    message.minHtlc = reader.int64();
                    break;
                case 3:
                    message.feeBaseMsat = reader.int64();
                    break;
                case 4:
                    message.feeRateMilliMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoutingPolicy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingPolicy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoutingPolicy message.
         * @function verify
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoutingPolicy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (!$util.isInteger(message.minHtlc) && !(message.minHtlc && $util.isInteger(message.minHtlc.low) && $util.isInteger(message.minHtlc.high)))
                    return "minHtlc: integer|Long expected";
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (!$util.isInteger(message.feeBaseMsat) && !(message.feeBaseMsat && $util.isInteger(message.feeBaseMsat.low) && $util.isInteger(message.feeBaseMsat.high)))
                    return "feeBaseMsat: integer|Long expected";
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                if (!$util.isInteger(message.feeRateMilliMsat) && !(message.feeRateMilliMsat && $util.isInteger(message.feeRateMilliMsat.low) && $util.isInteger(message.feeRateMilliMsat.high)))
                    return "feeRateMilliMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a RoutingPolicy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         */
        RoutingPolicy.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RoutingPolicy)
                return object;
            var message = new $root.lnrpc.RoutingPolicy();
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            if (object.minHtlc != null)
                if ($util.Long)
                    (message.minHtlc = $util.Long.fromValue(object.minHtlc)).unsigned = false;
                else if (typeof object.minHtlc === "string")
                    message.minHtlc = parseInt(object.minHtlc, 10);
                else if (typeof object.minHtlc === "number")
                    message.minHtlc = object.minHtlc;
                else if (typeof object.minHtlc === "object")
                    message.minHtlc = new $util.LongBits(object.minHtlc.low >>> 0, object.minHtlc.high >>> 0).toNumber();
            if (object.feeBaseMsat != null)
                if ($util.Long)
                    (message.feeBaseMsat = $util.Long.fromValue(object.feeBaseMsat)).unsigned = false;
                else if (typeof object.feeBaseMsat === "string")
                    message.feeBaseMsat = parseInt(object.feeBaseMsat, 10);
                else if (typeof object.feeBaseMsat === "number")
                    message.feeBaseMsat = object.feeBaseMsat;
                else if (typeof object.feeBaseMsat === "object")
                    message.feeBaseMsat = new $util.LongBits(object.feeBaseMsat.low >>> 0, object.feeBaseMsat.high >>> 0).toNumber();
            if (object.feeRateMilliMsat != null)
                if ($util.Long)
                    (message.feeRateMilliMsat = $util.Long.fromValue(object.feeRateMilliMsat)).unsigned = false;
                else if (typeof object.feeRateMilliMsat === "string")
                    message.feeRateMilliMsat = parseInt(object.feeRateMilliMsat, 10);
                else if (typeof object.feeRateMilliMsat === "number")
                    message.feeRateMilliMsat = object.feeRateMilliMsat;
                else if (typeof object.feeRateMilliMsat === "object")
                    message.feeRateMilliMsat = new $util.LongBits(object.feeRateMilliMsat.low >>> 0, object.feeRateMilliMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RoutingPolicy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.RoutingPolicy} message RoutingPolicy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoutingPolicy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.timeLockDelta = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.minHtlc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.feeBaseMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeBaseMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.feeRateMilliMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeRateMilliMsat = options.longs === String ? "0" : 0;
            }
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (typeof message.minHtlc === "number")
                    object.minHtlc = options.longs === String ? String(message.minHtlc) : message.minHtlc;
                else
                    object.minHtlc = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlc) : options.longs === Number ? new $util.LongBits(message.minHtlc.low >>> 0, message.minHtlc.high >>> 0).toNumber() : message.minHtlc;
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (typeof message.feeBaseMsat === "number")
                    object.feeBaseMsat = options.longs === String ? String(message.feeBaseMsat) : message.feeBaseMsat;
                else
                    object.feeBaseMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeBaseMsat) : options.longs === Number ? new $util.LongBits(message.feeBaseMsat.low >>> 0, message.feeBaseMsat.high >>> 0).toNumber() : message.feeBaseMsat;
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                if (typeof message.feeRateMilliMsat === "number")
                    object.feeRateMilliMsat = options.longs === String ? String(message.feeRateMilliMsat) : message.feeRateMilliMsat;
                else
                    object.feeRateMilliMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeRateMilliMsat) : options.longs === Number ? new $util.LongBits(message.feeRateMilliMsat.low >>> 0, message.feeRateMilliMsat.high >>> 0).toNumber() : message.feeRateMilliMsat;
            return object;
        };

        /**
         * Converts this RoutingPolicy to JSON.
         * @function toJSON
         * @memberof lnrpc.RoutingPolicy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoutingPolicy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoutingPolicy;
    })();

    lnrpc.ChannelEdge = (function() {

        /**
         * Properties of a ChannelEdge.
         * @memberof lnrpc
         * @interface IChannelEdge
         * @property {number|Long|null} [channelId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {string|null} [chanPoint] ChannelEdge chanPoint
         * @property {number|null} [lastUpdate] ChannelEdge lastUpdate
         * @property {string|null} [node1Pub] ChannelEdge node1Pub
         * @property {string|null} [node2Pub] ChannelEdge node2Pub
         * @property {number|Long|null} [capacity] ChannelEdge capacity
         * @property {lnrpc.IRoutingPolicy|null} [node1Policy] ChannelEdge node1Policy
         * @property {lnrpc.IRoutingPolicy|null} [node2Policy] ChannelEdge node2Policy
         */

        /**
         * Constructs a new ChannelEdge.
         * @memberof lnrpc
         * @classdesc A fully authenticated channel along with all its unique attributes.
         * Once an authenticated channel announcement has been processed on the network,
         * then an instance of ChannelEdgeInfo encapsulating the channels attributes is
         * stored. The other portions relevant to routing policy of a channel are stored
         * within a ChannelEdgePolicy for each direction of the channel.
         * @implements IChannelEdge
         * @constructor
         * @param {lnrpc.IChannelEdge=} [properties] Properties to set
         */
        function ChannelEdge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} channelId
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelEdge chanPoint.
         * @member {string} chanPoint
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.chanPoint = "";

        /**
         * ChannelEdge lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.lastUpdate = 0;

        /**
         * ChannelEdge node1Pub.
         * @member {string} node1Pub
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node1Pub = "";

        /**
         * ChannelEdge node2Pub.
         * @member {string} node2Pub
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node2Pub = "";

        /**
         * ChannelEdge capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelEdge node1Policy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} node1Policy
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node1Policy = null;

        /**
         * ChannelEdge node2Policy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} node2Policy
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node2Policy = null;

        /**
         * Creates a new ChannelEdge instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge=} [properties] Properties to set
         * @returns {lnrpc.ChannelEdge} ChannelEdge instance
         */
        ChannelEdge.create = function create(properties) {
            return new ChannelEdge(properties);
        };

        /**
         * Encodes the specified ChannelEdge message. Does not implicitly {@link lnrpc.ChannelEdge.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge} message ChannelEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.chanPoint);
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.lastUpdate);
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.node1Pub);
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.node2Pub);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.capacity);
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy"))
                $root.lnrpc.RoutingPolicy.encode(message.node1Policy, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy"))
                $root.lnrpc.RoutingPolicy.encode(message.node2Policy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelEdge message, length delimited. Does not implicitly {@link lnrpc.ChannelEdge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge} message ChannelEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEdge message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEdge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.chanPoint = reader.string();
                    break;
                case 3:
                    message.lastUpdate = reader.uint32();
                    break;
                case 4:
                    message.node1Pub = reader.string();
                    break;
                case 5:
                    message.node2Pub = reader.string();
                    break;
                case 6:
                    message.capacity = reader.int64();
                    break;
                case 7:
                    message.node1Policy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.node2Policy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEdge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEdge message.
         * @function verify
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEdge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                if (!$util.isString(message.chanPoint))
                    return "chanPoint: string expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                if (!$util.isString(message.node1Pub))
                    return "node1Pub: string expected";
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                if (!$util.isString(message.node2Pub))
                    return "node2Pub: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy")) {
                var error = $root.lnrpc.RoutingPolicy.verify(message.node1Policy);
                if (error)
                    return "node1Policy." + error;
            }
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy")) {
                var error = $root.lnrpc.RoutingPolicy.verify(message.node2Policy);
                if (error)
                    return "node2Policy." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelEdge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         */
        ChannelEdge.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEdge)
                return object;
            var message = new $root.lnrpc.ChannelEdge();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.chanPoint != null)
                message.chanPoint = String(object.chanPoint);
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            if (object.node1Pub != null)
                message.node1Pub = String(object.node1Pub);
            if (object.node2Pub != null)
                message.node2Pub = String(object.node2Pub);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.node1Policy != null) {
                if (typeof object.node1Policy !== "object")
                    throw TypeError(".lnrpc.ChannelEdge.node1Policy: object expected");
                message.node1Policy = $root.lnrpc.RoutingPolicy.fromObject(object.node1Policy);
            }
            if (object.node2Policy != null) {
                if (typeof object.node2Policy !== "object")
                    throw TypeError(".lnrpc.ChannelEdge.node2Policy: object expected");
                message.node2Policy = $root.lnrpc.RoutingPolicy.fromObject(object.node2Policy);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelEdge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.ChannelEdge} message ChannelEdge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEdge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.chanPoint = "";
                object.lastUpdate = 0;
                object.node1Pub = "";
                object.node2Pub = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.node1Policy = null;
                object.node2Policy = null;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = message.chanPoint;
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                object.node1Pub = message.node1Pub;
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                object.node2Pub = message.node2Pub;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy"))
                object.node1Policy = $root.lnrpc.RoutingPolicy.toObject(message.node1Policy, options);
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy"))
                object.node2Policy = $root.lnrpc.RoutingPolicy.toObject(message.node2Policy, options);
            return object;
        };

        /**
         * Converts this ChannelEdge to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEdge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEdge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEdge;
    })();

    lnrpc.ChannelGraphRequest = (function() {

        /**
         * Properties of a ChannelGraphRequest.
         * @memberof lnrpc
         * @interface IChannelGraphRequest
         */

        /**
         * Constructs a new ChannelGraphRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelGraphRequest.
         * @implements IChannelGraphRequest
         * @constructor
         * @param {lnrpc.IChannelGraphRequest=} [properties] Properties to set
         */
        function ChannelGraphRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelGraphRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest instance
         */
        ChannelGraphRequest.create = function create(properties) {
            return new ChannelGraphRequest(properties);
        };

        /**
         * Encodes the specified ChannelGraphRequest message. Does not implicitly {@link lnrpc.ChannelGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest} message ChannelGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelGraphRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest} message ChannelGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelGraphRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGraphRequest message.
         * @function verify
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         */
        ChannelGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelGraphRequest)
                return object;
            return new $root.lnrpc.ChannelGraphRequest();
        };

        /**
         * Creates a plain object from a ChannelGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.ChannelGraphRequest} message ChannelGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGraphRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelGraphRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGraphRequest;
    })();

    lnrpc.ChannelGraph = (function() {

        /**
         * Properties of a ChannelGraph.
         * @memberof lnrpc
         * @interface IChannelGraph
         * @property {Array.<lnrpc.ILightningNode>|null} [nodes] The list of `LightningNode`s in this channel graph
         * @property {Array.<lnrpc.IChannelEdge>|null} [edges] The list of `ChannelEdge`s in this channel graph
         */

        /**
         * Constructs a new ChannelGraph.
         * @memberof lnrpc
         * @classdesc Returns a new instance of the directed channel graph.
         * @implements IChannelGraph
         * @constructor
         * @param {lnrpc.IChannelGraph=} [properties] Properties to set
         */
        function ChannelGraph(properties) {
            this.nodes = [];
            this.edges = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of `LightningNode`s in this channel graph
         * @member {Array.<lnrpc.ILightningNode>} nodes
         * @memberof lnrpc.ChannelGraph
         * @instance
         */
        ChannelGraph.prototype.nodes = $util.emptyArray;

        /**
         * The list of `ChannelEdge`s in this channel graph
         * @member {Array.<lnrpc.IChannelEdge>} edges
         * @memberof lnrpc.ChannelGraph
         * @instance
         */
        ChannelGraph.prototype.edges = $util.emptyArray;

        /**
         * Creates a new ChannelGraph instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph=} [properties] Properties to set
         * @returns {lnrpc.ChannelGraph} ChannelGraph instance
         */
        ChannelGraph.create = function create(properties) {
            return new ChannelGraph(properties);
        };

        /**
         * Encodes the specified ChannelGraph message. Does not implicitly {@link lnrpc.ChannelGraph.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph} message ChannelGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
                for (var i = 0; i < message.nodes.length; ++i)
                    $root.lnrpc.LightningNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.edges != null && message.edges.length)
                for (var i = 0; i < message.edges.length; ++i)
                    $root.lnrpc.ChannelEdge.encode(message.edges[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelGraph message, length delimited. Does not implicitly {@link lnrpc.ChannelGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph} message ChannelGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGraph message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelGraph();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push($root.lnrpc.LightningNode.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.edges && message.edges.length))
                        message.edges = [];
                    message.edges.push($root.lnrpc.ChannelEdge.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGraph message.
         * @function verify
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (var i = 0; i < message.nodes.length; ++i) {
                    var error = $root.lnrpc.LightningNode.verify(message.nodes[i]);
                    if (error)
                        return "nodes." + error;
                }
            }
            if (message.edges != null && message.hasOwnProperty("edges")) {
                if (!Array.isArray(message.edges))
                    return "edges: array expected";
                for (var i = 0; i < message.edges.length; ++i) {
                    var error = $root.lnrpc.ChannelEdge.verify(message.edges[i]);
                    if (error)
                        return "edges." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChannelGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         */
        ChannelGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelGraph)
                return object;
            var message = new $root.lnrpc.ChannelGraph();
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".lnrpc.ChannelGraph.nodes: array expected");
                message.nodes = [];
                for (var i = 0; i < object.nodes.length; ++i) {
                    if (typeof object.nodes[i] !== "object")
                        throw TypeError(".lnrpc.ChannelGraph.nodes: object expected");
                    message.nodes[i] = $root.lnrpc.LightningNode.fromObject(object.nodes[i]);
                }
            }
            if (object.edges) {
                if (!Array.isArray(object.edges))
                    throw TypeError(".lnrpc.ChannelGraph.edges: array expected");
                message.edges = [];
                for (var i = 0; i < object.edges.length; ++i) {
                    if (typeof object.edges[i] !== "object")
                        throw TypeError(".lnrpc.ChannelGraph.edges: object expected");
                    message.edges[i] = $root.lnrpc.ChannelEdge.fromObject(object.edges[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.ChannelGraph} message ChannelGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.nodes = [];
                object.edges = [];
            }
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (var j = 0; j < message.nodes.length; ++j)
                    object.nodes[j] = $root.lnrpc.LightningNode.toObject(message.nodes[j], options);
            }
            if (message.edges && message.edges.length) {
                object.edges = [];
                for (var j = 0; j < message.edges.length; ++j)
                    object.edges[j] = $root.lnrpc.ChannelEdge.toObject(message.edges[j], options);
            }
            return object;
        };

        /**
         * Converts this ChannelGraph to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGraph;
    })();

    lnrpc.ChanInfoRequest = (function() {

        /**
         * Properties of a ChanInfoRequest.
         * @memberof lnrpc
         * @interface IChanInfoRequest
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         */

        /**
         * Constructs a new ChanInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChanInfoRequest.
         * @implements IChanInfoRequest
         * @constructor
         * @param {lnrpc.IChanInfoRequest=} [properties] Properties to set
         */
        function ChanInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChanInfoRequest
         * @instance
         */
        ChanInfoRequest.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChanInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest instance
         */
        ChanInfoRequest.create = function create(properties) {
            return new ChanInfoRequest(properties);
        };

        /**
         * Encodes the specified ChanInfoRequest message. Does not implicitly {@link lnrpc.ChanInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest} message ChanInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            return writer;
        };

        /**
         * Encodes the specified ChanInfoRequest message, length delimited. Does not implicitly {@link lnrpc.ChanInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest} message ChanInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanInfoRequest message.
         * @function verify
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChanInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         */
        ChanInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanInfoRequest)
                return object;
            var message = new $root.lnrpc.ChanInfoRequest();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChanInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.ChanInfoRequest} message ChanInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            return object;
        };

        /**
         * Converts this ChanInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanInfoRequest;
    })();

    lnrpc.NetworkInfoRequest = (function() {

        /**
         * Properties of a NetworkInfoRequest.
         * @memberof lnrpc
         * @interface INetworkInfoRequest
         */

        /**
         * Constructs a new NetworkInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a NetworkInfoRequest.
         * @implements INetworkInfoRequest
         * @constructor
         * @param {lnrpc.INetworkInfoRequest=} [properties] Properties to set
         */
        function NetworkInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NetworkInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest instance
         */
        NetworkInfoRequest.create = function create(properties) {
            return new NetworkInfoRequest(properties);
        };

        /**
         * Encodes the specified NetworkInfoRequest message. Does not implicitly {@link lnrpc.NetworkInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest} message NetworkInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NetworkInfoRequest message, length delimited. Does not implicitly {@link lnrpc.NetworkInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest} message NetworkInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NetworkInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfoRequest message.
         * @function verify
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a NetworkInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         */
        NetworkInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NetworkInfoRequest)
                return object;
            return new $root.lnrpc.NetworkInfoRequest();
        };

        /**
         * Creates a plain object from a NetworkInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.NetworkInfoRequest} message NetworkInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NetworkInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NetworkInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkInfoRequest;
    })();

    lnrpc.NetworkInfo = (function() {

        /**
         * Properties of a NetworkInfo.
         * @memberof lnrpc
         * @interface INetworkInfo
         * @property {number|null} [graphDiameter] NetworkInfo graphDiameter
         * @property {number|null} [avgOutDegree] NetworkInfo avgOutDegree
         * @property {number|null} [maxOutDegree] NetworkInfo maxOutDegree
         * @property {number|null} [numNodes] NetworkInfo numNodes
         * @property {number|null} [numChannels] NetworkInfo numChannels
         * @property {number|Long|null} [totalNetworkCapacity] NetworkInfo totalNetworkCapacity
         * @property {number|null} [avgChannelSize] NetworkInfo avgChannelSize
         * @property {number|Long|null} [minChannelSize] NetworkInfo minChannelSize
         * @property {number|Long|null} [maxChannelSize] NetworkInfo maxChannelSize
         */

        /**
         * Constructs a new NetworkInfo.
         * @memberof lnrpc
         * @classdesc Represents a NetworkInfo.
         * @implements INetworkInfo
         * @constructor
         * @param {lnrpc.INetworkInfo=} [properties] Properties to set
         */
        function NetworkInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkInfo graphDiameter.
         * @member {number} graphDiameter
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.graphDiameter = 0;

        /**
         * NetworkInfo avgOutDegree.
         * @member {number} avgOutDegree
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.avgOutDegree = 0;

        /**
         * NetworkInfo maxOutDegree.
         * @member {number} maxOutDegree
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.maxOutDegree = 0;

        /**
         * NetworkInfo numNodes.
         * @member {number} numNodes
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numNodes = 0;

        /**
         * NetworkInfo numChannels.
         * @member {number} numChannels
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numChannels = 0;

        /**
         * NetworkInfo totalNetworkCapacity.
         * @member {number|Long} totalNetworkCapacity
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.totalNetworkCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo avgChannelSize.
         * @member {number} avgChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.avgChannelSize = 0;

        /**
         * NetworkInfo minChannelSize.
         * @member {number|Long} minChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.minChannelSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo maxChannelSize.
         * @member {number|Long} maxChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.maxChannelSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NetworkInfo instance using the specified properties.
         * @function create
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo=} [properties] Properties to set
         * @returns {lnrpc.NetworkInfo} NetworkInfo instance
         */
        NetworkInfo.create = function create(properties) {
            return new NetworkInfo(properties);
        };

        /**
         * Encodes the specified NetworkInfo message. Does not implicitly {@link lnrpc.NetworkInfo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.graphDiameter);
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.avgOutDegree);
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxOutDegree);
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numNodes);
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numChannels);
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalNetworkCapacity);
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.avgChannelSize);
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.minChannelSize);
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.maxChannelSize);
            return writer;
        };

        /**
         * Encodes the specified NetworkInfo message, length delimited. Does not implicitly {@link lnrpc.NetworkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NetworkInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.graphDiameter = reader.uint32();
                    break;
                case 2:
                    message.avgOutDegree = reader.double();
                    break;
                case 3:
                    message.maxOutDegree = reader.uint32();
                    break;
                case 4:
                    message.numNodes = reader.uint32();
                    break;
                case 5:
                    message.numChannels = reader.uint32();
                    break;
                case 6:
                    message.totalNetworkCapacity = reader.int64();
                    break;
                case 7:
                    message.avgChannelSize = reader.double();
                    break;
                case 8:
                    message.minChannelSize = reader.int64();
                    break;
                case 9:
                    message.maxChannelSize = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfo message.
         * @function verify
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                if (!$util.isInteger(message.graphDiameter))
                    return "graphDiameter: integer expected";
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                if (typeof message.avgOutDegree !== "number")
                    return "avgOutDegree: number expected";
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                if (!$util.isInteger(message.maxOutDegree))
                    return "maxOutDegree: integer expected";
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                if (!$util.isInteger(message.numNodes))
                    return "numNodes: integer expected";
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                if (!$util.isInteger(message.totalNetworkCapacity) && !(message.totalNetworkCapacity && $util.isInteger(message.totalNetworkCapacity.low) && $util.isInteger(message.totalNetworkCapacity.high)))
                    return "totalNetworkCapacity: integer|Long expected";
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                if (typeof message.avgChannelSize !== "number")
                    return "avgChannelSize: number expected";
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                if (!$util.isInteger(message.minChannelSize) && !(message.minChannelSize && $util.isInteger(message.minChannelSize.low) && $util.isInteger(message.minChannelSize.high)))
                    return "minChannelSize: integer|Long expected";
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                if (!$util.isInteger(message.maxChannelSize) && !(message.maxChannelSize && $util.isInteger(message.maxChannelSize.low) && $util.isInteger(message.maxChannelSize.high)))
                    return "maxChannelSize: integer|Long expected";
            return null;
        };

        /**
         * Creates a NetworkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         */
        NetworkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NetworkInfo)
                return object;
            var message = new $root.lnrpc.NetworkInfo();
            if (object.graphDiameter != null)
                message.graphDiameter = object.graphDiameter >>> 0;
            if (object.avgOutDegree != null)
                message.avgOutDegree = Number(object.avgOutDegree);
            if (object.maxOutDegree != null)
                message.maxOutDegree = object.maxOutDegree >>> 0;
            if (object.numNodes != null)
                message.numNodes = object.numNodes >>> 0;
            if (object.numChannels != null)
                message.numChannels = object.numChannels >>> 0;
            if (object.totalNetworkCapacity != null)
                if ($util.Long)
                    (message.totalNetworkCapacity = $util.Long.fromValue(object.totalNetworkCapacity)).unsigned = false;
                else if (typeof object.totalNetworkCapacity === "string")
                    message.totalNetworkCapacity = parseInt(object.totalNetworkCapacity, 10);
                else if (typeof object.totalNetworkCapacity === "number")
                    message.totalNetworkCapacity = object.totalNetworkCapacity;
                else if (typeof object.totalNetworkCapacity === "object")
                    message.totalNetworkCapacity = new $util.LongBits(object.totalNetworkCapacity.low >>> 0, object.totalNetworkCapacity.high >>> 0).toNumber();
            if (object.avgChannelSize != null)
                message.avgChannelSize = Number(object.avgChannelSize);
            if (object.minChannelSize != null)
                if ($util.Long)
                    (message.minChannelSize = $util.Long.fromValue(object.minChannelSize)).unsigned = false;
                else if (typeof object.minChannelSize === "string")
                    message.minChannelSize = parseInt(object.minChannelSize, 10);
                else if (typeof object.minChannelSize === "number")
                    message.minChannelSize = object.minChannelSize;
                else if (typeof object.minChannelSize === "object")
                    message.minChannelSize = new $util.LongBits(object.minChannelSize.low >>> 0, object.minChannelSize.high >>> 0).toNumber();
            if (object.maxChannelSize != null)
                if ($util.Long)
                    (message.maxChannelSize = $util.Long.fromValue(object.maxChannelSize)).unsigned = false;
                else if (typeof object.maxChannelSize === "string")
                    message.maxChannelSize = parseInt(object.maxChannelSize, 10);
                else if (typeof object.maxChannelSize === "number")
                    message.maxChannelSize = object.maxChannelSize;
                else if (typeof object.maxChannelSize === "object")
                    message.maxChannelSize = new $util.LongBits(object.maxChannelSize.low >>> 0, object.maxChannelSize.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a NetworkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.NetworkInfo} message NetworkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.graphDiameter = 0;
                object.avgOutDegree = 0;
                object.maxOutDegree = 0;
                object.numNodes = 0;
                object.numChannels = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalNetworkCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalNetworkCapacity = options.longs === String ? "0" : 0;
                object.avgChannelSize = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.minChannelSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minChannelSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.maxChannelSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxChannelSize = options.longs === String ? "0" : 0;
            }
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                object.graphDiameter = message.graphDiameter;
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                object.avgOutDegree = options.json && !isFinite(message.avgOutDegree) ? String(message.avgOutDegree) : message.avgOutDegree;
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                object.maxOutDegree = message.maxOutDegree;
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                object.numNodes = message.numNodes;
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                if (typeof message.totalNetworkCapacity === "number")
                    object.totalNetworkCapacity = options.longs === String ? String(message.totalNetworkCapacity) : message.totalNetworkCapacity;
                else
                    object.totalNetworkCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.totalNetworkCapacity) : options.longs === Number ? new $util.LongBits(message.totalNetworkCapacity.low >>> 0, message.totalNetworkCapacity.high >>> 0).toNumber() : message.totalNetworkCapacity;
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                object.avgChannelSize = options.json && !isFinite(message.avgChannelSize) ? String(message.avgChannelSize) : message.avgChannelSize;
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                if (typeof message.minChannelSize === "number")
                    object.minChannelSize = options.longs === String ? String(message.minChannelSize) : message.minChannelSize;
                else
                    object.minChannelSize = options.longs === String ? $util.Long.prototype.toString.call(message.minChannelSize) : options.longs === Number ? new $util.LongBits(message.minChannelSize.low >>> 0, message.minChannelSize.high >>> 0).toNumber() : message.minChannelSize;
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                if (typeof message.maxChannelSize === "number")
                    object.maxChannelSize = options.longs === String ? String(message.maxChannelSize) : message.maxChannelSize;
                else
                    object.maxChannelSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxChannelSize) : options.longs === Number ? new $util.LongBits(message.maxChannelSize.low >>> 0, message.maxChannelSize.high >>> 0).toNumber() : message.maxChannelSize;
            return object;
        };

        /**
         * Converts this NetworkInfo to JSON.
         * @function toJSON
         * @memberof lnrpc.NetworkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkInfo;
    })();

    lnrpc.StopRequest = (function() {

        /**
         * Properties of a StopRequest.
         * @memberof lnrpc
         * @interface IStopRequest
         */

        /**
         * Constructs a new StopRequest.
         * @memberof lnrpc
         * @classdesc Represents a StopRequest.
         * @implements IStopRequest
         * @constructor
         * @param {lnrpc.IStopRequest=} [properties] Properties to set
         */
        function StopRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest=} [properties] Properties to set
         * @returns {lnrpc.StopRequest} StopRequest instance
         */
        StopRequest.create = function create(properties) {
            return new StopRequest(properties);
        };

        /**
         * Encodes the specified StopRequest message. Does not implicitly {@link lnrpc.StopRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest} message StopRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopRequest message, length delimited. Does not implicitly {@link lnrpc.StopRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest} message StopRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StopRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StopRequest} StopRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StopRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StopRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StopRequest} StopRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRequest message.
         * @function verify
         * @memberof lnrpc.StopRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StopRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StopRequest} StopRequest
         */
        StopRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StopRequest)
                return object;
            return new $root.lnrpc.StopRequest();
        };

        /**
         * Creates a plain object from a StopRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.StopRequest} message StopRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.StopRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRequest;
    })();

    lnrpc.StopResponse = (function() {

        /**
         * Properties of a StopResponse.
         * @memberof lnrpc
         * @interface IStopResponse
         */

        /**
         * Constructs a new StopResponse.
         * @memberof lnrpc
         * @classdesc Represents a StopResponse.
         * @implements IStopResponse
         * @constructor
         * @param {lnrpc.IStopResponse=} [properties] Properties to set
         */
        function StopResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse=} [properties] Properties to set
         * @returns {lnrpc.StopResponse} StopResponse instance
         */
        StopResponse.create = function create(properties) {
            return new StopResponse(properties);
        };

        /**
         * Encodes the specified StopResponse message. Does not implicitly {@link lnrpc.StopResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse} message StopResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopResponse message, length delimited. Does not implicitly {@link lnrpc.StopResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse} message StopResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StopResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StopResponse} StopResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StopResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StopResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StopResponse} StopResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopResponse message.
         * @function verify
         * @memberof lnrpc.StopResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StopResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StopResponse} StopResponse
         */
        StopResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StopResponse)
                return object;
            return new $root.lnrpc.StopResponse();
        };

        /**
         * Creates a plain object from a StopResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.StopResponse} message StopResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.StopResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopResponse;
    })();

    lnrpc.GraphTopologySubscription = (function() {

        /**
         * Properties of a GraphTopologySubscription.
         * @memberof lnrpc
         * @interface IGraphTopologySubscription
         */

        /**
         * Constructs a new GraphTopologySubscription.
         * @memberof lnrpc
         * @classdesc Represents a GraphTopologySubscription.
         * @implements IGraphTopologySubscription
         * @constructor
         * @param {lnrpc.IGraphTopologySubscription=} [properties] Properties to set
         */
        function GraphTopologySubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GraphTopologySubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription=} [properties] Properties to set
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription instance
         */
        GraphTopologySubscription.create = function create(properties) {
            return new GraphTopologySubscription(properties);
        };

        /**
         * Encodes the specified GraphTopologySubscription message. Does not implicitly {@link lnrpc.GraphTopologySubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription} message GraphTopologySubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologySubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GraphTopologySubscription message, length delimited. Does not implicitly {@link lnrpc.GraphTopologySubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription} message GraphTopologySubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologySubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphTopologySubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologySubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GraphTopologySubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphTopologySubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologySubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphTopologySubscription message.
         * @function verify
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphTopologySubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GraphTopologySubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         */
        GraphTopologySubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GraphTopologySubscription)
                return object;
            return new $root.lnrpc.GraphTopologySubscription();
        };

        /**
         * Creates a plain object from a GraphTopologySubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.GraphTopologySubscription} message GraphTopologySubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphTopologySubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GraphTopologySubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.GraphTopologySubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphTopologySubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphTopologySubscription;
    })();

    lnrpc.GraphTopologyUpdate = (function() {

        /**
         * Properties of a GraphTopologyUpdate.
         * @memberof lnrpc
         * @interface IGraphTopologyUpdate
         * @property {Array.<lnrpc.INodeUpdate>|null} [nodeUpdates] GraphTopologyUpdate nodeUpdates
         * @property {Array.<lnrpc.IChannelEdgeUpdate>|null} [channelUpdates] GraphTopologyUpdate channelUpdates
         * @property {Array.<lnrpc.IClosedChannelUpdate>|null} [closedChans] GraphTopologyUpdate closedChans
         */

        /**
         * Constructs a new GraphTopologyUpdate.
         * @memberof lnrpc
         * @classdesc Represents a GraphTopologyUpdate.
         * @implements IGraphTopologyUpdate
         * @constructor
         * @param {lnrpc.IGraphTopologyUpdate=} [properties] Properties to set
         */
        function GraphTopologyUpdate(properties) {
            this.nodeUpdates = [];
            this.channelUpdates = [];
            this.closedChans = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphTopologyUpdate nodeUpdates.
         * @member {Array.<lnrpc.INodeUpdate>} nodeUpdates
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.nodeUpdates = $util.emptyArray;

        /**
         * GraphTopologyUpdate channelUpdates.
         * @member {Array.<lnrpc.IChannelEdgeUpdate>} channelUpdates
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.channelUpdates = $util.emptyArray;

        /**
         * GraphTopologyUpdate closedChans.
         * @member {Array.<lnrpc.IClosedChannelUpdate>} closedChans
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.closedChans = $util.emptyArray;

        /**
         * Creates a new GraphTopologyUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate=} [properties] Properties to set
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate instance
         */
        GraphTopologyUpdate.create = function create(properties) {
            return new GraphTopologyUpdate(properties);
        };

        /**
         * Encodes the specified GraphTopologyUpdate message. Does not implicitly {@link lnrpc.GraphTopologyUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate} message GraphTopologyUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologyUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeUpdates != null && message.nodeUpdates.length)
                for (var i = 0; i < message.nodeUpdates.length; ++i)
                    $root.lnrpc.NodeUpdate.encode(message.nodeUpdates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelUpdates != null && message.channelUpdates.length)
                for (var i = 0; i < message.channelUpdates.length; ++i)
                    $root.lnrpc.ChannelEdgeUpdate.encode(message.channelUpdates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.closedChans != null && message.closedChans.length)
                for (var i = 0; i < message.closedChans.length; ++i)
                    $root.lnrpc.ClosedChannelUpdate.encode(message.closedChans[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphTopologyUpdate message, length delimited. Does not implicitly {@link lnrpc.GraphTopologyUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate} message GraphTopologyUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologyUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphTopologyUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologyUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GraphTopologyUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodeUpdates && message.nodeUpdates.length))
                        message.nodeUpdates = [];
                    message.nodeUpdates.push($root.lnrpc.NodeUpdate.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.channelUpdates && message.channelUpdates.length))
                        message.channelUpdates = [];
                    message.channelUpdates.push($root.lnrpc.ChannelEdgeUpdate.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.closedChans && message.closedChans.length))
                        message.closedChans = [];
                    message.closedChans.push($root.lnrpc.ClosedChannelUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphTopologyUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologyUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphTopologyUpdate message.
         * @function verify
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphTopologyUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeUpdates != null && message.hasOwnProperty("nodeUpdates")) {
                if (!Array.isArray(message.nodeUpdates))
                    return "nodeUpdates: array expected";
                for (var i = 0; i < message.nodeUpdates.length; ++i) {
                    var error = $root.lnrpc.NodeUpdate.verify(message.nodeUpdates[i]);
                    if (error)
                        return "nodeUpdates." + error;
                }
            }
            if (message.channelUpdates != null && message.hasOwnProperty("channelUpdates")) {
                if (!Array.isArray(message.channelUpdates))
                    return "channelUpdates: array expected";
                for (var i = 0; i < message.channelUpdates.length; ++i) {
                    var error = $root.lnrpc.ChannelEdgeUpdate.verify(message.channelUpdates[i]);
                    if (error)
                        return "channelUpdates." + error;
                }
            }
            if (message.closedChans != null && message.hasOwnProperty("closedChans")) {
                if (!Array.isArray(message.closedChans))
                    return "closedChans: array expected";
                for (var i = 0; i < message.closedChans.length; ++i) {
                    var error = $root.lnrpc.ClosedChannelUpdate.verify(message.closedChans[i]);
                    if (error)
                        return "closedChans." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphTopologyUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         */
        GraphTopologyUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GraphTopologyUpdate)
                return object;
            var message = new $root.lnrpc.GraphTopologyUpdate();
            if (object.nodeUpdates) {
                if (!Array.isArray(object.nodeUpdates))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.nodeUpdates: array expected");
                message.nodeUpdates = [];
                for (var i = 0; i < object.nodeUpdates.length; ++i) {
                    if (typeof object.nodeUpdates[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.nodeUpdates: object expected");
                    message.nodeUpdates[i] = $root.lnrpc.NodeUpdate.fromObject(object.nodeUpdates[i]);
                }
            }
            if (object.channelUpdates) {
                if (!Array.isArray(object.channelUpdates))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.channelUpdates: array expected");
                message.channelUpdates = [];
                for (var i = 0; i < object.channelUpdates.length; ++i) {
                    if (typeof object.channelUpdates[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.channelUpdates: object expected");
                    message.channelUpdates[i] = $root.lnrpc.ChannelEdgeUpdate.fromObject(object.channelUpdates[i]);
                }
            }
            if (object.closedChans) {
                if (!Array.isArray(object.closedChans))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.closedChans: array expected");
                message.closedChans = [];
                for (var i = 0; i < object.closedChans.length; ++i) {
                    if (typeof object.closedChans[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.closedChans: object expected");
                    message.closedChans[i] = $root.lnrpc.ClosedChannelUpdate.fromObject(object.closedChans[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphTopologyUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.GraphTopologyUpdate} message GraphTopologyUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphTopologyUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.nodeUpdates = [];
                object.channelUpdates = [];
                object.closedChans = [];
            }
            if (message.nodeUpdates && message.nodeUpdates.length) {
                object.nodeUpdates = [];
                for (var j = 0; j < message.nodeUpdates.length; ++j)
                    object.nodeUpdates[j] = $root.lnrpc.NodeUpdate.toObject(message.nodeUpdates[j], options);
            }
            if (message.channelUpdates && message.channelUpdates.length) {
                object.channelUpdates = [];
                for (var j = 0; j < message.channelUpdates.length; ++j)
                    object.channelUpdates[j] = $root.lnrpc.ChannelEdgeUpdate.toObject(message.channelUpdates[j], options);
            }
            if (message.closedChans && message.closedChans.length) {
                object.closedChans = [];
                for (var j = 0; j < message.closedChans.length; ++j)
                    object.closedChans[j] = $root.lnrpc.ClosedChannelUpdate.toObject(message.closedChans[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphTopologyUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphTopologyUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphTopologyUpdate;
    })();

    lnrpc.NodeUpdate = (function() {

        /**
         * Properties of a NodeUpdate.
         * @memberof lnrpc
         * @interface INodeUpdate
         * @property {Array.<string>|null} [addresses] NodeUpdate addresses
         * @property {string|null} [identityKey] NodeUpdate identityKey
         * @property {Uint8Array|null} [globalFeatures] NodeUpdate globalFeatures
         * @property {string|null} [alias] NodeUpdate alias
         */

        /**
         * Constructs a new NodeUpdate.
         * @memberof lnrpc
         * @classdesc Represents a NodeUpdate.
         * @implements INodeUpdate
         * @constructor
         * @param {lnrpc.INodeUpdate=} [properties] Properties to set
         */
        function NodeUpdate(properties) {
            this.addresses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeUpdate addresses.
         * @member {Array.<string>} addresses
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.addresses = $util.emptyArray;

        /**
         * NodeUpdate identityKey.
         * @member {string} identityKey
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.identityKey = "";

        /**
         * NodeUpdate globalFeatures.
         * @member {Uint8Array} globalFeatures
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.globalFeatures = $util.newBuffer([]);

        /**
         * NodeUpdate alias.
         * @member {string} alias
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.alias = "";

        /**
         * Creates a new NodeUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate=} [properties] Properties to set
         * @returns {lnrpc.NodeUpdate} NodeUpdate instance
         */
        NodeUpdate.create = function create(properties) {
            return new NodeUpdate(properties);
        };

        /**
         * Encodes the specified NodeUpdate message. Does not implicitly {@link lnrpc.NodeUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate} message NodeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addresses != null && message.addresses.length)
                for (var i = 0; i < message.addresses.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.addresses[i]);
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.identityKey);
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.globalFeatures);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.alias);
            return writer;
        };

        /**
         * Encodes the specified NodeUpdate message, length delimited. Does not implicitly {@link lnrpc.NodeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate} message NodeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push(reader.string());
                    break;
                case 2:
                    message.identityKey = reader.string();
                    break;
                case 3:
                    message.globalFeatures = reader.bytes();
                    break;
                case 4:
                    message.alias = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeUpdate message.
         * @function verify
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (var i = 0; i < message.addresses.length; ++i)
                    if (!$util.isString(message.addresses[i]))
                        return "addresses: string[] expected";
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!$util.isString(message.identityKey))
                    return "identityKey: string expected";
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                if (!(message.globalFeatures && typeof message.globalFeatures.length === "number" || $util.isString(message.globalFeatures)))
                    return "globalFeatures: buffer expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            return null;
        };

        /**
         * Creates a NodeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         */
        NodeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeUpdate)
                return object;
            var message = new $root.lnrpc.NodeUpdate();
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".lnrpc.NodeUpdate.addresses: array expected");
                message.addresses = [];
                for (var i = 0; i < object.addresses.length; ++i)
                    message.addresses[i] = String(object.addresses[i]);
            }
            if (object.identityKey != null)
                message.identityKey = String(object.identityKey);
            if (object.globalFeatures != null)
                if (typeof object.globalFeatures === "string")
                    $util.base64.decode(object.globalFeatures, message.globalFeatures = $util.newBuffer($util.base64.length(object.globalFeatures)), 0);
                else if (object.globalFeatures.length)
                    message.globalFeatures = object.globalFeatures;
            if (object.alias != null)
                message.alias = String(object.alias);
            return message;
        };

        /**
         * Creates a plain object from a NodeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.NodeUpdate} message NodeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults) {
                object.identityKey = "";
                if (options.bytes === String)
                    object.globalFeatures = "";
                else {
                    object.globalFeatures = [];
                    if (options.bytes !== Array)
                        object.globalFeatures = $util.newBuffer(object.globalFeatures);
                }
                object.alias = "";
            }
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (var j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = message.addresses[j];
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = message.identityKey;
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                object.globalFeatures = options.bytes === String ? $util.base64.encode(message.globalFeatures, 0, message.globalFeatures.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalFeatures) : message.globalFeatures;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            return object;
        };

        /**
         * Converts this NodeUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeUpdate;
    })();

    lnrpc.ChannelEdgeUpdate = (function() {

        /**
         * Properties of a ChannelEdgeUpdate.
         * @memberof lnrpc
         * @interface IChannelEdgeUpdate
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ChannelEdgeUpdate chanPoint
         * @property {number|Long|null} [capacity] ChannelEdgeUpdate capacity
         * @property {lnrpc.IRoutingPolicy|null} [routingPolicy] ChannelEdgeUpdate routingPolicy
         * @property {string|null} [advertisingNode] ChannelEdgeUpdate advertisingNode
         * @property {string|null} [connectingNode] ChannelEdgeUpdate connectingNode
         */

        /**
         * Constructs a new ChannelEdgeUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEdgeUpdate.
         * @implements IChannelEdgeUpdate
         * @constructor
         * @param {lnrpc.IChannelEdgeUpdate=} [properties] Properties to set
         */
        function ChannelEdgeUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelEdgeUpdate chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.chanPoint = null;

        /**
         * ChannelEdgeUpdate capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelEdgeUpdate routingPolicy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} routingPolicy
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.routingPolicy = null;

        /**
         * ChannelEdgeUpdate advertisingNode.
         * @member {string} advertisingNode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.advertisingNode = "";

        /**
         * ChannelEdgeUpdate connectingNode.
         * @member {string} connectingNode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.connectingNode = "";

        /**
         * Creates a new ChannelEdgeUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate instance
         */
        ChannelEdgeUpdate.create = function create(properties) {
            return new ChannelEdgeUpdate(properties);
        };

        /**
         * Encodes the specified ChannelEdgeUpdate message. Does not implicitly {@link lnrpc.ChannelEdgeUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate} message ChannelEdgeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdgeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.capacity);
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy"))
                $root.lnrpc.RoutingPolicy.encode(message.routingPolicy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.advertisingNode);
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.connectingNode);
            return writer;
        };

        /**
         * Encodes the specified ChannelEdgeUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelEdgeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate} message ChannelEdgeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdgeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEdgeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdgeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEdgeUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.capacity = reader.int64();
                    break;
                case 4:
                    message.routingPolicy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.advertisingNode = reader.string();
                    break;
                case 6:
                    message.connectingNode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEdgeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdgeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEdgeUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEdgeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                var error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy")) {
                var error = $root.lnrpc.RoutingPolicy.verify(message.routingPolicy);
                if (error)
                    return "routingPolicy." + error;
            }
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                if (!$util.isString(message.advertisingNode))
                    return "advertisingNode: string expected";
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                if (!$util.isString(message.connectingNode))
                    return "connectingNode: string expected";
            return null;
        };

        /**
         * Creates a ChannelEdgeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         */
        ChannelEdgeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEdgeUpdate)
                return object;
            var message = new $root.lnrpc.ChannelEdgeUpdate();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ChannelEdgeUpdate.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.routingPolicy != null) {
                if (typeof object.routingPolicy !== "object")
                    throw TypeError(".lnrpc.ChannelEdgeUpdate.routingPolicy: object expected");
                message.routingPolicy = $root.lnrpc.RoutingPolicy.fromObject(object.routingPolicy);
            }
            if (object.advertisingNode != null)
                message.advertisingNode = String(object.advertisingNode);
            if (object.connectingNode != null)
                message.connectingNode = String(object.connectingNode);
            return message;
        };

        /**
         * Creates a plain object from a ChannelEdgeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.ChannelEdgeUpdate} message ChannelEdgeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEdgeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.chanPoint = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.routingPolicy = null;
                object.advertisingNode = "";
                object.connectingNode = "";
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy"))
                object.routingPolicy = $root.lnrpc.RoutingPolicy.toObject(message.routingPolicy, options);
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                object.advertisingNode = message.advertisingNode;
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                object.connectingNode = message.connectingNode;
            return object;
        };

        /**
         * Converts this ChannelEdgeUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEdgeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEdgeUpdate;
    })();

    lnrpc.ClosedChannelUpdate = (function() {

        /**
         * Properties of a ClosedChannelUpdate.
         * @memberof lnrpc
         * @interface IClosedChannelUpdate
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {number|Long|null} [capacity] ClosedChannelUpdate capacity
         * @property {number|null} [closedHeight] ClosedChannelUpdate closedHeight
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ClosedChannelUpdate chanPoint
         */

        /**
         * Constructs a new ClosedChannelUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelUpdate.
         * @implements IClosedChannelUpdate
         * @constructor
         * @param {lnrpc.IClosedChannelUpdate=} [properties] Properties to set
         */
        function ClosedChannelUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ClosedChannelUpdate capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ClosedChannelUpdate closedHeight.
         * @member {number} closedHeight
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.closedHeight = 0;

        /**
         * ClosedChannelUpdate chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.chanPoint = null;

        /**
         * Creates a new ClosedChannelUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate instance
         */
        ClosedChannelUpdate.create = function create(properties) {
            return new ClosedChannelUpdate(properties);
        };

        /**
         * Encodes the specified ClosedChannelUpdate message. Does not implicitly {@link lnrpc.ClosedChannelUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate} message ClosedChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.capacity);
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.closedHeight);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelUpdate message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate} message ClosedChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.capacity = reader.int64();
                    break;
                case 3:
                    message.closedHeight = reader.uint32();
                    break;
                case 4:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelUpdate message.
         * @function verify
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                if (!$util.isInteger(message.closedHeight))
                    return "closedHeight: integer expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                var error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            return null;
        };

        /**
         * Creates a ClosedChannelUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         */
        ClosedChannelUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelUpdate)
                return object;
            var message = new $root.lnrpc.ClosedChannelUpdate();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.closedHeight != null)
                message.closedHeight = object.closedHeight >>> 0;
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ClosedChannelUpdate.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.ClosedChannelUpdate} message ClosedChannelUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.closedHeight = 0;
                object.chanPoint = null;
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                object.closedHeight = message.closedHeight;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            return object;
        };

        /**
         * Converts this ClosedChannelUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelUpdate;
    })();

    lnrpc.HopHint = (function() {

        /**
         * Properties of a HopHint.
         * @memberof lnrpc
         * @interface IHopHint
         * @property {string|null} [nodeId] The public key of the node at the start of the channel.
         * @property {number|Long|null} [chanId] The unique identifier of the channel.
         * @property {number|null} [feeBaseMsat] The base fee of the channel denominated in millisatoshis.
         * @property {number|null} [feeProportionalMillionths] The fee rate of the channel for sending one satoshi across it denominated in
         * millionths of a satoshi.
         * @property {number|null} [cltvExpiryDelta] The time-lock delta of the channel.
         */

        /**
         * Constructs a new HopHint.
         * @memberof lnrpc
         * @classdesc Represents a HopHint.
         * @implements IHopHint
         * @constructor
         * @param {lnrpc.IHopHint=} [properties] Properties to set
         */
        function HopHint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The public key of the node at the start of the channel.
         * @member {string} nodeId
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.nodeId = "";

        /**
         * The unique identifier of the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The base fee of the channel denominated in millisatoshis.
         * @member {number} feeBaseMsat
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.feeBaseMsat = 0;

        /**
         * The fee rate of the channel for sending one satoshi across it denominated in
         * millionths of a satoshi.
         * @member {number} feeProportionalMillionths
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.feeProportionalMillionths = 0;

        /**
         * The time-lock delta of the channel.
         * @member {number} cltvExpiryDelta
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.cltvExpiryDelta = 0;

        /**
         * Creates a new HopHint instance using the specified properties.
         * @function create
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint=} [properties] Properties to set
         * @returns {lnrpc.HopHint} HopHint instance
         */
        HopHint.create = function create(properties) {
            return new HopHint(properties);
        };

        /**
         * Encodes the specified HopHint message. Does not implicitly {@link lnrpc.HopHint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint} message HopHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HopHint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanId);
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.feeBaseMsat);
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.feeProportionalMillionths);
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.cltvExpiryDelta);
            return writer;
        };

        /**
         * Encodes the specified HopHint message, length delimited. Does not implicitly {@link lnrpc.HopHint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint} message HopHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HopHint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HopHint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HopHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HopHint} HopHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HopHint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HopHint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodeId = reader.string();
                    break;
                case 2:
                    message.chanId = reader.uint64();
                    break;
                case 3:
                    message.feeBaseMsat = reader.uint32();
                    break;
                case 4:
                    message.feeProportionalMillionths = reader.uint32();
                    break;
                case 5:
                    message.cltvExpiryDelta = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HopHint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HopHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HopHint} HopHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HopHint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HopHint message.
         * @function verify
         * @memberof lnrpc.HopHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HopHint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isString(message.nodeId))
                    return "nodeId: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (!$util.isInteger(message.feeBaseMsat))
                    return "feeBaseMsat: integer expected";
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                if (!$util.isInteger(message.feeProportionalMillionths))
                    return "feeProportionalMillionths: integer expected";
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                if (!$util.isInteger(message.cltvExpiryDelta))
                    return "cltvExpiryDelta: integer expected";
            return null;
        };

        /**
         * Creates a HopHint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HopHint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HopHint} HopHint
         */
        HopHint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HopHint)
                return object;
            var message = new $root.lnrpc.HopHint();
            if (object.nodeId != null)
                message.nodeId = String(object.nodeId);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.feeBaseMsat != null)
                message.feeBaseMsat = object.feeBaseMsat >>> 0;
            if (object.feeProportionalMillionths != null)
                message.feeProportionalMillionths = object.feeProportionalMillionths >>> 0;
            if (object.cltvExpiryDelta != null)
                message.cltvExpiryDelta = object.cltvExpiryDelta >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HopHint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.HopHint} message HopHint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HopHint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nodeId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.feeBaseMsat = 0;
                object.feeProportionalMillionths = 0;
                object.cltvExpiryDelta = 0;
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = message.nodeId;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                object.feeBaseMsat = message.feeBaseMsat;
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                object.feeProportionalMillionths = message.feeProportionalMillionths;
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                object.cltvExpiryDelta = message.cltvExpiryDelta;
            return object;
        };

        /**
         * Converts this HopHint to JSON.
         * @function toJSON
         * @memberof lnrpc.HopHint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HopHint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HopHint;
    })();

    lnrpc.RouteHint = (function() {

        /**
         * Properties of a RouteHint.
         * @memberof lnrpc
         * @interface IRouteHint
         * @property {Array.<lnrpc.IHopHint>|null} [hopHints] A list of hop hints that when chained together can assist in reaching a
         * specific destination.
         */

        /**
         * Constructs a new RouteHint.
         * @memberof lnrpc
         * @classdesc Represents a RouteHint.
         * @implements IRouteHint
         * @constructor
         * @param {lnrpc.IRouteHint=} [properties] Properties to set
         */
        function RouteHint(properties) {
            this.hopHints = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A list of hop hints that when chained together can assist in reaching a
         * specific destination.
         * @member {Array.<lnrpc.IHopHint>} hopHints
         * @memberof lnrpc.RouteHint
         * @instance
         */
        RouteHint.prototype.hopHints = $util.emptyArray;

        /**
         * Creates a new RouteHint instance using the specified properties.
         * @function create
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint=} [properties] Properties to set
         * @returns {lnrpc.RouteHint} RouteHint instance
         */
        RouteHint.create = function create(properties) {
            return new RouteHint(properties);
        };

        /**
         * Encodes the specified RouteHint message. Does not implicitly {@link lnrpc.RouteHint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint} message RouteHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteHint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hopHints != null && message.hopHints.length)
                for (var i = 0; i < message.hopHints.length; ++i)
                    $root.lnrpc.HopHint.encode(message.hopHints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RouteHint message, length delimited. Does not implicitly {@link lnrpc.RouteHint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint} message RouteHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteHint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RouteHint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RouteHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RouteHint} RouteHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteHint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RouteHint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.hopHints && message.hopHints.length))
                        message.hopHints = [];
                    message.hopHints.push($root.lnrpc.HopHint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RouteHint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RouteHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RouteHint} RouteHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteHint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RouteHint message.
         * @function verify
         * @memberof lnrpc.RouteHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RouteHint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hopHints != null && message.hasOwnProperty("hopHints")) {
                if (!Array.isArray(message.hopHints))
                    return "hopHints: array expected";
                for (var i = 0; i < message.hopHints.length; ++i) {
                    var error = $root.lnrpc.HopHint.verify(message.hopHints[i]);
                    if (error)
                        return "hopHints." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RouteHint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RouteHint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RouteHint} RouteHint
         */
        RouteHint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RouteHint)
                return object;
            var message = new $root.lnrpc.RouteHint();
            if (object.hopHints) {
                if (!Array.isArray(object.hopHints))
                    throw TypeError(".lnrpc.RouteHint.hopHints: array expected");
                message.hopHints = [];
                for (var i = 0; i < object.hopHints.length; ++i) {
                    if (typeof object.hopHints[i] !== "object")
                        throw TypeError(".lnrpc.RouteHint.hopHints: object expected");
                    message.hopHints[i] = $root.lnrpc.HopHint.fromObject(object.hopHints[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RouteHint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.RouteHint} message RouteHint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RouteHint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hopHints = [];
            if (message.hopHints && message.hopHints.length) {
                object.hopHints = [];
                for (var j = 0; j < message.hopHints.length; ++j)
                    object.hopHints[j] = $root.lnrpc.HopHint.toObject(message.hopHints[j], options);
            }
            return object;
        };

        /**
         * Converts this RouteHint to JSON.
         * @function toJSON
         * @memberof lnrpc.RouteHint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RouteHint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RouteHint;
    })();

    lnrpc.Invoice = (function() {

        /**
         * Properties of an Invoice.
         * @memberof lnrpc
         * @interface IInvoice
         * @property {string|null} [memo] An optional memo to attach along with the invoice. Used for record keeping
         * purposes for the invoice's creator, and will also be set in the description
         * field of the encoded payment request if the description_hash field is not
         * being used.
         * @property {Uint8Array|null} [receipt] An optional cryptographic receipt of payment
         * @property {Uint8Array|null} [rPreimage] The hex-encoded preimage (32 byte) which will allow settling an incoming
         * HTLC payable to this preimage
         * @property {Uint8Array|null} [rHash] The hash of the preimage
         * @property {number|Long|null} [value] The value of this invoice in satoshis
         * @property {boolean|null} [settled] Whether this invoice has been fulfilled
         * @property {number|Long|null} [creationDate] When this invoice was created
         * @property {number|Long|null} [settleDate] When this invoice was settled
         * @property {string|null} [paymentRequest] A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @property {Uint8Array|null} [descriptionHash] Hash (SHA-256) of a description of the payment. Used if the description of
         * payment (memo) is too long to naturally fit within the description field
         * of an encoded payment request.
         * @property {number|Long|null} [expiry] Payment request expiry time in seconds. Default is 3600 (1 hour).
         * @property {string|null} [fallbackAddr] Fallback on-chain address.
         * @property {number|Long|null} [cltvExpiry] Delta to use for the time-lock of the CLTV extended to the final hop.
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] Route hints that can each be individually used to assist in reaching the
         * invoice's destination.
         * @property {boolean|null} ["private"] Whether this invoice should include routing hints for private channels.
         * @property {number|Long|null} [addIndex] The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         * @property {number|Long|null} [settleIndex] The "settle" index of this invoice. Each newly settled invoice will
         * increment this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all
         * settled invoices with an settle_index greater than this one.
         * @property {number|Long|null} [amtPaid] The amount that was accepted for this invoice. This will ONLY be set if
         * this invoice has been settled. We provide this field as if the invoice was
         * created with a zero value, then we need to record what amount was
         * ultimately accepted. Additionally, it's possible that the sender paid MORE
         * that was specified in the original invoice. So we'll record that here as
         * well.
         */

        /**
         * Constructs a new Invoice.
         * @memberof lnrpc
         * @classdesc Represents an Invoice.
         * @implements IInvoice
         * @constructor
         * @param {lnrpc.IInvoice=} [properties] Properties to set
         */
        function Invoice(properties) {
            this.routeHints = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An optional memo to attach along with the invoice. Used for record keeping
         * purposes for the invoice's creator, and will also be set in the description
         * field of the encoded payment request if the description_hash field is not
         * being used.
         * @member {string} memo
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.memo = "";

        /**
         * An optional cryptographic receipt of payment
         * @member {Uint8Array} receipt
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.receipt = $util.newBuffer([]);

        /**
         * The hex-encoded preimage (32 byte) which will allow settling an incoming
         * HTLC payable to this preimage
         * @member {Uint8Array} rPreimage
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.rPreimage = $util.newBuffer([]);

        /**
         * The hash of the preimage
         * @member {Uint8Array} rHash
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.rHash = $util.newBuffer([]);

        /**
         * The value of this invoice in satoshis
         * @member {number|Long} value
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Whether this invoice has been fulfilled
         * @member {boolean} settled
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settled = false;

        /**
         * When this invoice was created
         * @member {number|Long} creationDate
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.creationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * When this invoice was settled
         * @member {number|Long} settleDate
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settleDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @member {string} paymentRequest
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.paymentRequest = "";

        /**
         * Hash (SHA-256) of a description of the payment. Used if the description of
         * payment (memo) is too long to naturally fit within the description field
         * of an encoded payment request.
         * @member {Uint8Array} descriptionHash
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.descriptionHash = $util.newBuffer([]);

        /**
         * Payment request expiry time in seconds. Default is 3600 (1 hour).
         * @member {number|Long} expiry
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.expiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fallback on-chain address.
         * @member {string} fallbackAddr
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.fallbackAddr = "";

        /**
         * Delta to use for the time-lock of the CLTV extended to the final hop.
         * @member {number|Long} cltvExpiry
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.cltvExpiry = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Route hints that can each be individually used to assist in reaching the
         * invoice's destination.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.routeHints = $util.emptyArray;

        /**
         * Whether this invoice should include routing hints for private channels.
         * @member {boolean} private
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype["private"] = false;

        /**
         * The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         * @member {number|Long} addIndex
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The "settle" index of this invoice. Each newly settled invoice will
         * increment this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all
         * settled invoices with an settle_index greater than this one.
         * @member {number|Long} settleIndex
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settleIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The amount that was accepted for this invoice. This will ONLY be set if
         * this invoice has been settled. We provide this field as if the invoice was
         * created with a zero value, then we need to record what amount was
         * ultimately accepted. Additionally, it's possible that the sender paid MORE
         * that was specified in the original invoice. So we'll record that here as
         * well.
         * @member {number|Long} amtPaid
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Invoice instance using the specified properties.
         * @function create
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice=} [properties] Properties to set
         * @returns {lnrpc.Invoice} Invoice instance
         */
        Invoice.create = function create(properties) {
            return new Invoice(properties);
        };

        /**
         * Encodes the specified Invoice message. Does not implicitly {@link lnrpc.Invoice.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice} message Invoice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invoice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.memo);
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.receipt);
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rPreimage);
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rHash);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.value);
            if (message.settled != null && message.hasOwnProperty("settled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.settled);
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.creationDate);
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.settleDate);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.paymentRequest);
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.descriptionHash);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.expiry);
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.fallbackAddr);
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.cltvExpiry);
            if (message.routeHints != null && message.routeHints.length)
                for (var i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message["private"] != null && message.hasOwnProperty("private"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message["private"]);
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.addIndex);
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.settleIndex);
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.amtPaid);
            return writer;
        };

        /**
         * Encodes the specified Invoice message, length delimited. Does not implicitly {@link lnrpc.Invoice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice} message Invoice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invoice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Invoice message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Invoice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Invoice} Invoice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invoice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Invoice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.memo = reader.string();
                    break;
                case 2:
                    message.receipt = reader.bytes();
                    break;
                case 3:
                    message.rPreimage = reader.bytes();
                    break;
                case 4:
                    message.rHash = reader.bytes();
                    break;
                case 5:
                    message.value = reader.int64();
                    break;
                case 6:
                    message.settled = reader.bool();
                    break;
                case 7:
                    message.creationDate = reader.int64();
                    break;
                case 8:
                    message.settleDate = reader.int64();
                    break;
                case 9:
                    message.paymentRequest = reader.string();
                    break;
                case 10:
                    message.descriptionHash = reader.bytes();
                    break;
                case 11:
                    message.expiry = reader.int64();
                    break;
                case 12:
                    message.fallbackAddr = reader.string();
                    break;
                case 13:
                    message.cltvExpiry = reader.uint64();
                    break;
                case 14:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message["private"] = reader.bool();
                    break;
                case 16:
                    message.addIndex = reader.uint64();
                    break;
                case 17:
                    message.settleIndex = reader.uint64();
                    break;
                case 18:
                    message.amtPaid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Invoice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Invoice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Invoice} Invoice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invoice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Invoice message.
         * @function verify
         * @memberof lnrpc.Invoice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Invoice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                if (!(message.receipt && typeof message.receipt.length === "number" || $util.isString(message.receipt)))
                    return "receipt: buffer expected";
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                if (!(message.rPreimage && typeof message.rPreimage.length === "number" || $util.isString(message.rPreimage)))
                    return "rPreimage: buffer expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.settled != null && message.hasOwnProperty("settled"))
                if (typeof message.settled !== "boolean")
                    return "settled: boolean expected";
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (!$util.isInteger(message.creationDate) && !(message.creationDate && $util.isInteger(message.creationDate.low) && $util.isInteger(message.creationDate.high)))
                    return "creationDate: integer|Long expected";
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                if (!$util.isInteger(message.settleDate) && !(message.settleDate && $util.isInteger(message.settleDate.low) && $util.isInteger(message.settleDate.high)))
                    return "settleDate: integer|Long expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                if (!(message.descriptionHash && typeof message.descriptionHash.length === "number" || $util.isString(message.descriptionHash)))
                    return "descriptionHash: buffer expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry) && !(message.expiry && $util.isInteger(message.expiry.low) && $util.isInteger(message.expiry.high)))
                    return "expiry: integer|Long expected";
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                if (!$util.isString(message.fallbackAddr))
                    return "fallbackAddr: string expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry) && !(message.cltvExpiry && $util.isInteger(message.cltvExpiry.low) && $util.isInteger(message.cltvExpiry.high)))
                    return "cltvExpiry: integer|Long expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (var i = 0; i < message.routeHints.length; ++i) {
                    var error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (!$util.isInteger(message.settleIndex) && !(message.settleIndex && $util.isInteger(message.settleIndex.low) && $util.isInteger(message.settleIndex.high)))
                    return "settleIndex: integer|Long expected";
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                if (!$util.isInteger(message.amtPaid) && !(message.amtPaid && $util.isInteger(message.amtPaid.low) && $util.isInteger(message.amtPaid.high)))
                    return "amtPaid: integer|Long expected";
            return null;
        };

        /**
         * Creates an Invoice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Invoice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Invoice} Invoice
         */
        Invoice.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Invoice)
                return object;
            var message = new $root.lnrpc.Invoice();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.receipt != null)
                if (typeof object.receipt === "string")
                    $util.base64.decode(object.receipt, message.receipt = $util.newBuffer($util.base64.length(object.receipt)), 0);
                else if (object.receipt.length)
                    message.receipt = object.receipt;
            if (object.rPreimage != null)
                if (typeof object.rPreimage === "string")
                    $util.base64.decode(object.rPreimage, message.rPreimage = $util.newBuffer($util.base64.length(object.rPreimage)), 0);
                else if (object.rPreimage.length)
                    message.rPreimage = object.rPreimage;
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.settled != null)
                message.settled = Boolean(object.settled);
            if (object.creationDate != null)
                if ($util.Long)
                    (message.creationDate = $util.Long.fromValue(object.creationDate)).unsigned = false;
                else if (typeof object.creationDate === "string")
                    message.creationDate = parseInt(object.creationDate, 10);
                else if (typeof object.creationDate === "number")
                    message.creationDate = object.creationDate;
                else if (typeof object.creationDate === "object")
                    message.creationDate = new $util.LongBits(object.creationDate.low >>> 0, object.creationDate.high >>> 0).toNumber();
            if (object.settleDate != null)
                if ($util.Long)
                    (message.settleDate = $util.Long.fromValue(object.settleDate)).unsigned = false;
                else if (typeof object.settleDate === "string")
                    message.settleDate = parseInt(object.settleDate, 10);
                else if (typeof object.settleDate === "number")
                    message.settleDate = object.settleDate;
                else if (typeof object.settleDate === "object")
                    message.settleDate = new $util.LongBits(object.settleDate.low >>> 0, object.settleDate.high >>> 0).toNumber();
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.descriptionHash != null)
                if (typeof object.descriptionHash === "string")
                    $util.base64.decode(object.descriptionHash, message.descriptionHash = $util.newBuffer($util.base64.length(object.descriptionHash)), 0);
                else if (object.descriptionHash.length)
                    message.descriptionHash = object.descriptionHash;
            if (object.expiry != null)
                if ($util.Long)
                    (message.expiry = $util.Long.fromValue(object.expiry)).unsigned = false;
                else if (typeof object.expiry === "string")
                    message.expiry = parseInt(object.expiry, 10);
                else if (typeof object.expiry === "number")
                    message.expiry = object.expiry;
                else if (typeof object.expiry === "object")
                    message.expiry = new $util.LongBits(object.expiry.low >>> 0, object.expiry.high >>> 0).toNumber();
            if (object.fallbackAddr != null)
                message.fallbackAddr = String(object.fallbackAddr);
            if (object.cltvExpiry != null)
                if ($util.Long)
                    (message.cltvExpiry = $util.Long.fromValue(object.cltvExpiry)).unsigned = true;
                else if (typeof object.cltvExpiry === "string")
                    message.cltvExpiry = parseInt(object.cltvExpiry, 10);
                else if (typeof object.cltvExpiry === "number")
                    message.cltvExpiry = object.cltvExpiry;
                else if (typeof object.cltvExpiry === "object")
                    message.cltvExpiry = new $util.LongBits(object.cltvExpiry.low >>> 0, object.cltvExpiry.high >>> 0).toNumber(true);
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.Invoice.routeHints: array expected");
                message.routeHints = [];
                for (var i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.Invoice.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            if (object.settleIndex != null)
                if ($util.Long)
                    (message.settleIndex = $util.Long.fromValue(object.settleIndex)).unsigned = true;
                else if (typeof object.settleIndex === "string")
                    message.settleIndex = parseInt(object.settleIndex, 10);
                else if (typeof object.settleIndex === "number")
                    message.settleIndex = object.settleIndex;
                else if (typeof object.settleIndex === "object")
                    message.settleIndex = new $util.LongBits(object.settleIndex.low >>> 0, object.settleIndex.high >>> 0).toNumber(true);
            if (object.amtPaid != null)
                if ($util.Long)
                    (message.amtPaid = $util.Long.fromValue(object.amtPaid)).unsigned = false;
                else if (typeof object.amtPaid === "string")
                    message.amtPaid = parseInt(object.amtPaid, 10);
                else if (typeof object.amtPaid === "number")
                    message.amtPaid = object.amtPaid;
                else if (typeof object.amtPaid === "object")
                    message.amtPaid = new $util.LongBits(object.amtPaid.low >>> 0, object.amtPaid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Invoice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.Invoice} message Invoice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Invoice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.routeHints = [];
            if (options.defaults) {
                object.memo = "";
                if (options.bytes === String)
                    object.receipt = "";
                else {
                    object.receipt = [];
                    if (options.bytes !== Array)
                        object.receipt = $util.newBuffer(object.receipt);
                }
                if (options.bytes === String)
                    object.rPreimage = "";
                else {
                    object.rPreimage = [];
                    if (options.bytes !== Array)
                        object.rPreimage = $util.newBuffer(object.rPreimage);
                }
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                object.settled = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.creationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.settleDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleDate = options.longs === String ? "0" : 0;
                object.paymentRequest = "";
                if (options.bytes === String)
                    object.descriptionHash = "";
                else {
                    object.descriptionHash = [];
                    if (options.bytes !== Array)
                        object.descriptionHash = $util.newBuffer(object.descriptionHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiry = options.longs === String ? "0" : 0;
                object.fallbackAddr = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.cltvExpiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cltvExpiry = options.longs === String ? "0" : 0;
                object["private"] = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.settleIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amtPaid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaid = options.longs === String ? "0" : 0;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                object.receipt = options.bytes === String ? $util.base64.encode(message.receipt, 0, message.receipt.length) : options.bytes === Array ? Array.prototype.slice.call(message.receipt) : message.receipt;
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                object.rPreimage = options.bytes === String ? $util.base64.encode(message.rPreimage, 0, message.rPreimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.rPreimage) : message.rPreimage;
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.settled != null && message.hasOwnProperty("settled"))
                object.settled = message.settled;
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (typeof message.creationDate === "number")
                    object.creationDate = options.longs === String ? String(message.creationDate) : message.creationDate;
                else
                    object.creationDate = options.longs === String ? $util.Long.prototype.toString.call(message.creationDate) : options.longs === Number ? new $util.LongBits(message.creationDate.low >>> 0, message.creationDate.high >>> 0).toNumber() : message.creationDate;
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                if (typeof message.settleDate === "number")
                    object.settleDate = options.longs === String ? String(message.settleDate) : message.settleDate;
                else
                    object.settleDate = options.longs === String ? $util.Long.prototype.toString.call(message.settleDate) : options.longs === Number ? new $util.LongBits(message.settleDate.low >>> 0, message.settleDate.high >>> 0).toNumber() : message.settleDate;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                object.descriptionHash = options.bytes === String ? $util.base64.encode(message.descriptionHash, 0, message.descriptionHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionHash) : message.descriptionHash;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (typeof message.expiry === "number")
                    object.expiry = options.longs === String ? String(message.expiry) : message.expiry;
                else
                    object.expiry = options.longs === String ? $util.Long.prototype.toString.call(message.expiry) : options.longs === Number ? new $util.LongBits(message.expiry.low >>> 0, message.expiry.high >>> 0).toNumber() : message.expiry;
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                object.fallbackAddr = message.fallbackAddr;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (typeof message.cltvExpiry === "number")
                    object.cltvExpiry = options.longs === String ? String(message.cltvExpiry) : message.cltvExpiry;
                else
                    object.cltvExpiry = options.longs === String ? $util.Long.prototype.toString.call(message.cltvExpiry) : options.longs === Number ? new $util.LongBits(message.cltvExpiry.low >>> 0, message.cltvExpiry.high >>> 0).toNumber(true) : message.cltvExpiry;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (var j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (typeof message.settleIndex === "number")
                    object.settleIndex = options.longs === String ? String(message.settleIndex) : message.settleIndex;
                else
                    object.settleIndex = options.longs === String ? $util.Long.prototype.toString.call(message.settleIndex) : options.longs === Number ? new $util.LongBits(message.settleIndex.low >>> 0, message.settleIndex.high >>> 0).toNumber(true) : message.settleIndex;
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                if (typeof message.amtPaid === "number")
                    object.amtPaid = options.longs === String ? String(message.amtPaid) : message.amtPaid;
                else
                    object.amtPaid = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaid) : options.longs === Number ? new $util.LongBits(message.amtPaid.low >>> 0, message.amtPaid.high >>> 0).toNumber() : message.amtPaid;
            return object;
        };

        /**
         * Converts this Invoice to JSON.
         * @function toJSON
         * @memberof lnrpc.Invoice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Invoice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Invoice;
    })();

    lnrpc.AddInvoiceResponse = (function() {

        /**
         * Properties of an AddInvoiceResponse.
         * @memberof lnrpc
         * @interface IAddInvoiceResponse
         * @property {Uint8Array|null} [rHash] AddInvoiceResponse rHash
         * @property {string|null} [paymentRequest] A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @property {number|Long|null} [addIndex] The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         */

        /**
         * Constructs a new AddInvoiceResponse.
         * @memberof lnrpc
         * @classdesc Represents an AddInvoiceResponse.
         * @implements IAddInvoiceResponse
         * @constructor
         * @param {lnrpc.IAddInvoiceResponse=} [properties] Properties to set
         */
        function AddInvoiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddInvoiceResponse rHash.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.rHash = $util.newBuffer([]);

        /**
         * A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @member {string} paymentRequest
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.paymentRequest = "";

        /**
         * The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         * @member {number|Long} addIndex
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AddInvoiceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse=} [properties] Properties to set
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse instance
         */
        AddInvoiceResponse.create = function create(properties) {
            return new AddInvoiceResponse(properties);
        };

        /**
         * Encodes the specified AddInvoiceResponse message. Does not implicitly {@link lnrpc.AddInvoiceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse} message AddInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddInvoiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rHash);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentRequest);
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.addIndex);
            return writer;
        };

        /**
         * Encodes the specified AddInvoiceResponse message, length delimited. Does not implicitly {@link lnrpc.AddInvoiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse} message AddInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddInvoiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddInvoiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddInvoiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AddInvoiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rHash = reader.bytes();
                    break;
                case 2:
                    message.paymentRequest = reader.string();
                    break;
                case 16:
                    message.addIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddInvoiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddInvoiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddInvoiceResponse message.
         * @function verify
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddInvoiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an AddInvoiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         */
        AddInvoiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AddInvoiceResponse)
                return object;
            var message = new $root.lnrpc.AddInvoiceResponse();
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AddInvoiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.AddInvoiceResponse} message AddInvoiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddInvoiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
                object.paymentRequest = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
            }
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            return object;
        };

        /**
         * Converts this AddInvoiceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddInvoiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddInvoiceResponse;
    })();

    lnrpc.PaymentHash = (function() {

        /**
         * Properties of a PaymentHash.
         * @memberof lnrpc
         * @interface IPaymentHash
         * @property {string|null} [rHashStr] The hex-encoded payment hash of the invoice to be looked up. The passed
         * payment hash must be exactly 32 bytes, otherwise an error is returned.
         * @property {Uint8Array|null} [rHash] The payment hash of the invoice to be looked up.
         */

        /**
         * Constructs a new PaymentHash.
         * @memberof lnrpc
         * @classdesc Represents a PaymentHash.
         * @implements IPaymentHash
         * @constructor
         * @param {lnrpc.IPaymentHash=} [properties] Properties to set
         */
        function PaymentHash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The hex-encoded payment hash of the invoice to be looked up. The passed
         * payment hash must be exactly 32 bytes, otherwise an error is returned.
         * @member {string} rHashStr
         * @memberof lnrpc.PaymentHash
         * @instance
         */
        PaymentHash.prototype.rHashStr = "";

        /**
         * The payment hash of the invoice to be looked up.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.PaymentHash
         * @instance
         */
        PaymentHash.prototype.rHash = $util.newBuffer([]);

        /**
         * Creates a new PaymentHash instance using the specified properties.
         * @function create
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash=} [properties] Properties to set
         * @returns {lnrpc.PaymentHash} PaymentHash instance
         */
        PaymentHash.create = function create(properties) {
            return new PaymentHash(properties);
        };

        /**
         * Encodes the specified PaymentHash message. Does not implicitly {@link lnrpc.PaymentHash.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash} message PaymentHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentHash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rHashStr);
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rHash);
            return writer;
        };

        /**
         * Encodes the specified PaymentHash message, length delimited. Does not implicitly {@link lnrpc.PaymentHash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash} message PaymentHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentHash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentHash message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PaymentHash} PaymentHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentHash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PaymentHash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rHashStr = reader.string();
                    break;
                case 2:
                    message.rHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentHash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PaymentHash} PaymentHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentHash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentHash message.
         * @function verify
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentHash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                if (!$util.isString(message.rHashStr))
                    return "rHashStr: string expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            return null;
        };

        /**
         * Creates a PaymentHash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PaymentHash} PaymentHash
         */
        PaymentHash.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PaymentHash)
                return object;
            var message = new $root.lnrpc.PaymentHash();
            if (object.rHashStr != null)
                message.rHashStr = String(object.rHashStr);
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            return message;
        };

        /**
         * Creates a plain object from a PaymentHash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.PaymentHash} message PaymentHash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentHash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rHashStr = "";
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
            }
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                object.rHashStr = message.rHashStr;
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            return object;
        };

        /**
         * Converts this PaymentHash to JSON.
         * @function toJSON
         * @memberof lnrpc.PaymentHash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentHash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaymentHash;
    })();

    lnrpc.ListInvoiceRequest = (function() {

        /**
         * Properties of a ListInvoiceRequest.
         * @memberof lnrpc
         * @interface IListInvoiceRequest
         * @property {boolean|null} [pendingOnly] Toggles if all invoices should be returned, or only those that are currently unsettled.
         */

        /**
         * Constructs a new ListInvoiceRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListInvoiceRequest.
         * @implements IListInvoiceRequest
         * @constructor
         * @param {lnrpc.IListInvoiceRequest=} [properties] Properties to set
         */
        function ListInvoiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Toggles if all invoices should be returned, or only those that are currently unsettled.
         * @member {boolean} pendingOnly
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.pendingOnly = false;

        /**
         * Creates a new ListInvoiceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest=} [properties] Properties to set
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest instance
         */
        ListInvoiceRequest.create = function create(properties) {
            return new ListInvoiceRequest(properties);
        };

        /**
         * Encodes the specified ListInvoiceRequest message. Does not implicitly {@link lnrpc.ListInvoiceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest} message ListInvoiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.pendingOnly);
            return writer;
        };

        /**
         * Encodes the specified ListInvoiceRequest message, length delimited. Does not implicitly {@link lnrpc.ListInvoiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest} message ListInvoiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListInvoiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListInvoiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pendingOnly = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListInvoiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListInvoiceRequest message.
         * @function verify
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListInvoiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                if (typeof message.pendingOnly !== "boolean")
                    return "pendingOnly: boolean expected";
            return null;
        };

        /**
         * Creates a ListInvoiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         */
        ListInvoiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListInvoiceRequest)
                return object;
            var message = new $root.lnrpc.ListInvoiceRequest();
            if (object.pendingOnly != null)
                message.pendingOnly = Boolean(object.pendingOnly);
            return message;
        };

        /**
         * Creates a plain object from a ListInvoiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.ListInvoiceRequest} message ListInvoiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListInvoiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pendingOnly = false;
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                object.pendingOnly = message.pendingOnly;
            return object;
        };

        /**
         * Converts this ListInvoiceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListInvoiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListInvoiceRequest;
    })();

    lnrpc.ListInvoiceResponse = (function() {

        /**
         * Properties of a ListInvoiceResponse.
         * @memberof lnrpc
         * @interface IListInvoiceResponse
         * @property {Array.<lnrpc.IInvoice>|null} [invoices] ListInvoiceResponse invoices
         */

        /**
         * Constructs a new ListInvoiceResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListInvoiceResponse.
         * @implements IListInvoiceResponse
         * @constructor
         * @param {lnrpc.IListInvoiceResponse=} [properties] Properties to set
         */
        function ListInvoiceResponse(properties) {
            this.invoices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListInvoiceResponse invoices.
         * @member {Array.<lnrpc.IInvoice>} invoices
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.invoices = $util.emptyArray;

        /**
         * Creates a new ListInvoiceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse=} [properties] Properties to set
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse instance
         */
        ListInvoiceResponse.create = function create(properties) {
            return new ListInvoiceResponse(properties);
        };

        /**
         * Encodes the specified ListInvoiceResponse message. Does not implicitly {@link lnrpc.ListInvoiceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse} message ListInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invoices != null && message.invoices.length)
                for (var i = 0; i < message.invoices.length; ++i)
                    $root.lnrpc.Invoice.encode(message.invoices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListInvoiceResponse message, length delimited. Does not implicitly {@link lnrpc.ListInvoiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse} message ListInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListInvoiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListInvoiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.invoices && message.invoices.length))
                        message.invoices = [];
                    message.invoices.push($root.lnrpc.Invoice.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListInvoiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListInvoiceResponse message.
         * @function verify
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListInvoiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invoices != null && message.hasOwnProperty("invoices")) {
                if (!Array.isArray(message.invoices))
                    return "invoices: array expected";
                for (var i = 0; i < message.invoices.length; ++i) {
                    var error = $root.lnrpc.Invoice.verify(message.invoices[i]);
                    if (error)
                        return "invoices." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListInvoiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         */
        ListInvoiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListInvoiceResponse)
                return object;
            var message = new $root.lnrpc.ListInvoiceResponse();
            if (object.invoices) {
                if (!Array.isArray(object.invoices))
                    throw TypeError(".lnrpc.ListInvoiceResponse.invoices: array expected");
                message.invoices = [];
                for (var i = 0; i < object.invoices.length; ++i) {
                    if (typeof object.invoices[i] !== "object")
                        throw TypeError(".lnrpc.ListInvoiceResponse.invoices: object expected");
                    message.invoices[i] = $root.lnrpc.Invoice.fromObject(object.invoices[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListInvoiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.ListInvoiceResponse} message ListInvoiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListInvoiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.invoices = [];
            if (message.invoices && message.invoices.length) {
                object.invoices = [];
                for (var j = 0; j < message.invoices.length; ++j)
                    object.invoices[j] = $root.lnrpc.Invoice.toObject(message.invoices[j], options);
            }
            return object;
        };

        /**
         * Converts this ListInvoiceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListInvoiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListInvoiceResponse;
    })();

    lnrpc.InvoiceSubscription = (function() {

        /**
         * Properties of an InvoiceSubscription.
         * @memberof lnrpc
         * @interface IInvoiceSubscription
         * @property {number|Long|null} [addIndex] If specified (non-zero), then we'll first start by sending out
         * notifications for all added indexes with an add_index greater than this
         * value. This allows callers to catch up on any events they missed while they
         * weren't connected to the streaming RPC.
         * @property {number|Long|null} [settleIndex] If specified (non-zero), then we'll first start by sending out
         * notifications for all settled indexes with an settle_index greater than
         * this value. This allows callers to catch up on any events they missed while
         * they weren't connected to the streaming RPC.
         */

        /**
         * Constructs a new InvoiceSubscription.
         * @memberof lnrpc
         * @classdesc Represents an InvoiceSubscription.
         * @implements IInvoiceSubscription
         * @constructor
         * @param {lnrpc.IInvoiceSubscription=} [properties] Properties to set
         */
        function InvoiceSubscription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * If specified (non-zero), then we'll first start by sending out
         * notifications for all added indexes with an add_index greater than this
         * value. This allows callers to catch up on any events they missed while they
         * weren't connected to the streaming RPC.
         * @member {number|Long} addIndex
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         */
        InvoiceSubscription.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * If specified (non-zero), then we'll first start by sending out
         * notifications for all settled indexes with an settle_index greater than
         * this value. This allows callers to catch up on any events they missed while
         * they weren't connected to the streaming RPC.
         * @member {number|Long} settleIndex
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         */
        InvoiceSubscription.prototype.settleIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new InvoiceSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription=} [properties] Properties to set
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription instance
         */
        InvoiceSubscription.create = function create(properties) {
            return new InvoiceSubscription(properties);
        };

        /**
         * Encodes the specified InvoiceSubscription message. Does not implicitly {@link lnrpc.InvoiceSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription} message InvoiceSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.addIndex);
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.settleIndex);
            return writer;
        };

        /**
         * Encodes the specified InvoiceSubscription message, length delimited. Does not implicitly {@link lnrpc.InvoiceSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription} message InvoiceSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvoiceSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InvoiceSubscription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addIndex = reader.uint64();
                    break;
                case 2:
                    message.settleIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvoiceSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvoiceSubscription message.
         * @function verify
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvoiceSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (!$util.isInteger(message.settleIndex) && !(message.settleIndex && $util.isInteger(message.settleIndex.low) && $util.isInteger(message.settleIndex.high)))
                    return "settleIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an InvoiceSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         */
        InvoiceSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InvoiceSubscription)
                return object;
            var message = new $root.lnrpc.InvoiceSubscription();
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            if (object.settleIndex != null)
                if ($util.Long)
                    (message.settleIndex = $util.Long.fromValue(object.settleIndex)).unsigned = true;
                else if (typeof object.settleIndex === "string")
                    message.settleIndex = parseInt(object.settleIndex, 10);
                else if (typeof object.settleIndex === "number")
                    message.settleIndex = object.settleIndex;
                else if (typeof object.settleIndex === "object")
                    message.settleIndex = new $util.LongBits(object.settleIndex.low >>> 0, object.settleIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an InvoiceSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.InvoiceSubscription} message InvoiceSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvoiceSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.settleIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleIndex = options.longs === String ? "0" : 0;
            }
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (typeof message.settleIndex === "number")
                    object.settleIndex = options.longs === String ? String(message.settleIndex) : message.settleIndex;
                else
                    object.settleIndex = options.longs === String ? $util.Long.prototype.toString.call(message.settleIndex) : options.longs === Number ? new $util.LongBits(message.settleIndex.low >>> 0, message.settleIndex.high >>> 0).toNumber(true) : message.settleIndex;
            return object;
        };

        /**
         * Converts this InvoiceSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvoiceSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvoiceSubscription;
    })();

    lnrpc.Payment = (function() {

        /**
         * Properties of a Payment.
         * @memberof lnrpc
         * @interface IPayment
         * @property {string|null} [paymentHash] The payment hash
         * @property {number|Long|null} [value] The value of the payment in satoshis
         * @property {number|Long|null} [creationDate] The date of this payment
         * @property {Array.<string>|null} [path] The path this payment took
         * @property {number|Long|null} [fee] The fee paid for this payment in satoshis
         * @property {string|null} [paymentPreimage] The payment preimage
         */

        /**
         * Constructs a new Payment.
         * @memberof lnrpc
         * @classdesc Represents a Payment.
         * @implements IPayment
         * @constructor
         * @param {lnrpc.IPayment=} [properties] Properties to set
         */
        function Payment(properties) {
            this.path = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The payment hash
         * @member {string} paymentHash
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentHash = "";

        /**
         * The value of the payment in satoshis
         * @member {number|Long} value
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The date of this payment
         * @member {number|Long} creationDate
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.creationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The path this payment took
         * @member {Array.<string>} path
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.path = $util.emptyArray;

        /**
         * The fee paid for this payment in satoshis
         * @member {number|Long} fee
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The payment preimage
         * @member {string} paymentPreimage
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentPreimage = "";

        /**
         * Creates a new Payment instance using the specified properties.
         * @function create
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment=} [properties] Properties to set
         * @returns {lnrpc.Payment} Payment instance
         */
        Payment.create = function create(properties) {
            return new Payment(properties);
        };

        /**
         * Encodes the specified Payment message. Does not implicitly {@link lnrpc.Payment.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.paymentHash);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creationDate);
            if (message.path != null && message.path.length)
                for (var i = 0; i < message.path.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.path[i]);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fee);
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.paymentPreimage);
            return writer;
        };

        /**
         * Encodes the specified Payment message, length delimited. Does not implicitly {@link lnrpc.Payment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payment message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Payment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentHash = reader.string();
                    break;
                case 2:
                    message.value = reader.int64();
                    break;
                case 3:
                    message.creationDate = reader.int64();
                    break;
                case 4:
                    if (!(message.path && message.path.length))
                        message.path = [];
                    message.path.push(reader.string());
                    break;
                case 5:
                    message.fee = reader.int64();
                    break;
                case 6:
                    message.paymentPreimage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payment message.
         * @function verify
         * @memberof lnrpc.Payment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!$util.isString(message.paymentHash))
                    return "paymentHash: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (!$util.isInteger(message.creationDate) && !(message.creationDate && $util.isInteger(message.creationDate.low) && $util.isInteger(message.creationDate.high)))
                    return "creationDate: integer|Long expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (var i = 0; i < message.path.length; ++i)
                    if (!$util.isString(message.path[i]))
                        return "path: string[] expected";
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                if (!$util.isString(message.paymentPreimage))
                    return "paymentPreimage: string expected";
            return null;
        };

        /**
         * Creates a Payment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Payment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Payment} Payment
         */
        Payment.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Payment)
                return object;
            var message = new $root.lnrpc.Payment();
            if (object.paymentHash != null)
                message.paymentHash = String(object.paymentHash);
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.creationDate != null)
                if ($util.Long)
                    (message.creationDate = $util.Long.fromValue(object.creationDate)).unsigned = false;
                else if (typeof object.creationDate === "string")
                    message.creationDate = parseInt(object.creationDate, 10);
                else if (typeof object.creationDate === "number")
                    message.creationDate = object.creationDate;
                else if (typeof object.creationDate === "object")
                    message.creationDate = new $util.LongBits(object.creationDate.low >>> 0, object.creationDate.high >>> 0).toNumber();
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".lnrpc.Payment.path: array expected");
                message.path = [];
                for (var i = 0; i < object.path.length; ++i)
                    message.path[i] = String(object.path[i]);
            }
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.paymentPreimage != null)
                message.paymentPreimage = String(object.paymentPreimage);
            return message;
        };

        /**
         * Creates a plain object from a Payment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.Payment} message Payment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (options.defaults) {
                object.paymentHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.creationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.paymentPreimage = "";
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = message.paymentHash;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (typeof message.creationDate === "number")
                    object.creationDate = options.longs === String ? String(message.creationDate) : message.creationDate;
                else
                    object.creationDate = options.longs === String ? $util.Long.prototype.toString.call(message.creationDate) : options.longs === Number ? new $util.LongBits(message.creationDate.low >>> 0, message.creationDate.high >>> 0).toNumber() : message.creationDate;
            if (message.path && message.path.length) {
                object.path = [];
                for (var j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                object.paymentPreimage = message.paymentPreimage;
            return object;
        };

        /**
         * Converts this Payment to JSON.
         * @function toJSON
         * @memberof lnrpc.Payment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Payment;
    })();

    lnrpc.ListPaymentsRequest = (function() {

        /**
         * Properties of a ListPaymentsRequest.
         * @memberof lnrpc
         * @interface IListPaymentsRequest
         */

        /**
         * Constructs a new ListPaymentsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPaymentsRequest.
         * @implements IListPaymentsRequest
         * @constructor
         * @param {lnrpc.IListPaymentsRequest=} [properties] Properties to set
         */
        function ListPaymentsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ListPaymentsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest instance
         */
        ListPaymentsRequest.create = function create(properties) {
            return new ListPaymentsRequest(properties);
        };

        /**
         * Encodes the specified ListPaymentsRequest message. Does not implicitly {@link lnrpc.ListPaymentsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest} message ListPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ListPaymentsRequest message, length delimited. Does not implicitly {@link lnrpc.ListPaymentsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest} message ListPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPaymentsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPaymentsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPaymentsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPaymentsRequest message.
         * @function verify
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPaymentsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ListPaymentsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         */
        ListPaymentsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPaymentsRequest)
                return object;
            return new $root.lnrpc.ListPaymentsRequest();
        };

        /**
         * Creates a plain object from a ListPaymentsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.ListPaymentsRequest} message ListPaymentsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPaymentsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ListPaymentsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPaymentsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPaymentsRequest;
    })();

    lnrpc.ListPaymentsResponse = (function() {

        /**
         * Properties of a ListPaymentsResponse.
         * @memberof lnrpc
         * @interface IListPaymentsResponse
         * @property {Array.<lnrpc.IPayment>|null} [payments] The list of payments
         */

        /**
         * Constructs a new ListPaymentsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPaymentsResponse.
         * @implements IListPaymentsResponse
         * @constructor
         * @param {lnrpc.IListPaymentsResponse=} [properties] Properties to set
         */
        function ListPaymentsResponse(properties) {
            this.payments = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of payments
         * @member {Array.<lnrpc.IPayment>} payments
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         */
        ListPaymentsResponse.prototype.payments = $util.emptyArray;

        /**
         * Creates a new ListPaymentsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse instance
         */
        ListPaymentsResponse.create = function create(properties) {
            return new ListPaymentsResponse(properties);
        };

        /**
         * Encodes the specified ListPaymentsResponse message. Does not implicitly {@link lnrpc.ListPaymentsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse} message ListPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payments != null && message.payments.length)
                for (var i = 0; i < message.payments.length; ++i)
                    $root.lnrpc.Payment.encode(message.payments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListPaymentsResponse message, length delimited. Does not implicitly {@link lnrpc.ListPaymentsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse} message ListPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPaymentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPaymentsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.payments && message.payments.length))
                        message.payments = [];
                    message.payments.push($root.lnrpc.Payment.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPaymentsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPaymentsResponse message.
         * @function verify
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPaymentsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payments != null && message.hasOwnProperty("payments")) {
                if (!Array.isArray(message.payments))
                    return "payments: array expected";
                for (var i = 0; i < message.payments.length; ++i) {
                    var error = $root.lnrpc.Payment.verify(message.payments[i]);
                    if (error)
                        return "payments." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPaymentsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         */
        ListPaymentsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPaymentsResponse)
                return object;
            var message = new $root.lnrpc.ListPaymentsResponse();
            if (object.payments) {
                if (!Array.isArray(object.payments))
                    throw TypeError(".lnrpc.ListPaymentsResponse.payments: array expected");
                message.payments = [];
                for (var i = 0; i < object.payments.length; ++i) {
                    if (typeof object.payments[i] !== "object")
                        throw TypeError(".lnrpc.ListPaymentsResponse.payments: object expected");
                    message.payments[i] = $root.lnrpc.Payment.fromObject(object.payments[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPaymentsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.ListPaymentsResponse} message ListPaymentsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPaymentsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.payments = [];
            if (message.payments && message.payments.length) {
                object.payments = [];
                for (var j = 0; j < message.payments.length; ++j)
                    object.payments[j] = $root.lnrpc.Payment.toObject(message.payments[j], options);
            }
            return object;
        };

        /**
         * Converts this ListPaymentsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPaymentsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPaymentsResponse;
    })();

    lnrpc.DeleteAllPaymentsRequest = (function() {

        /**
         * Properties of a DeleteAllPaymentsRequest.
         * @memberof lnrpc
         * @interface IDeleteAllPaymentsRequest
         */

        /**
         * Constructs a new DeleteAllPaymentsRequest.
         * @memberof lnrpc
         * @classdesc Represents a DeleteAllPaymentsRequest.
         * @implements IDeleteAllPaymentsRequest
         * @constructor
         * @param {lnrpc.IDeleteAllPaymentsRequest=} [properties] Properties to set
         */
        function DeleteAllPaymentsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteAllPaymentsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest=} [properties] Properties to set
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest instance
         */
        DeleteAllPaymentsRequest.create = function create(properties) {
            return new DeleteAllPaymentsRequest(properties);
        };

        /**
         * Encodes the specified DeleteAllPaymentsRequest message. Does not implicitly {@link lnrpc.DeleteAllPaymentsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest} message DeleteAllPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteAllPaymentsRequest message, length delimited. Does not implicitly {@link lnrpc.DeleteAllPaymentsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest} message DeleteAllPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAllPaymentsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteAllPaymentsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAllPaymentsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAllPaymentsRequest message.
         * @function verify
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAllPaymentsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteAllPaymentsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         */
        DeleteAllPaymentsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteAllPaymentsRequest)
                return object;
            return new $root.lnrpc.DeleteAllPaymentsRequest();
        };

        /**
         * Creates a plain object from a DeleteAllPaymentsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.DeleteAllPaymentsRequest} message DeleteAllPaymentsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAllPaymentsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteAllPaymentsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAllPaymentsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAllPaymentsRequest;
    })();

    lnrpc.DeleteAllPaymentsResponse = (function() {

        /**
         * Properties of a DeleteAllPaymentsResponse.
         * @memberof lnrpc
         * @interface IDeleteAllPaymentsResponse
         */

        /**
         * Constructs a new DeleteAllPaymentsResponse.
         * @memberof lnrpc
         * @classdesc Represents a DeleteAllPaymentsResponse.
         * @implements IDeleteAllPaymentsResponse
         * @constructor
         * @param {lnrpc.IDeleteAllPaymentsResponse=} [properties] Properties to set
         */
        function DeleteAllPaymentsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteAllPaymentsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse=} [properties] Properties to set
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse instance
         */
        DeleteAllPaymentsResponse.create = function create(properties) {
            return new DeleteAllPaymentsResponse(properties);
        };

        /**
         * Encodes the specified DeleteAllPaymentsResponse message. Does not implicitly {@link lnrpc.DeleteAllPaymentsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse} message DeleteAllPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteAllPaymentsResponse message, length delimited. Does not implicitly {@link lnrpc.DeleteAllPaymentsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse} message DeleteAllPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAllPaymentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteAllPaymentsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAllPaymentsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAllPaymentsResponse message.
         * @function verify
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAllPaymentsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteAllPaymentsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         */
        DeleteAllPaymentsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteAllPaymentsResponse)
                return object;
            return new $root.lnrpc.DeleteAllPaymentsResponse();
        };

        /**
         * Creates a plain object from a DeleteAllPaymentsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.DeleteAllPaymentsResponse} message DeleteAllPaymentsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAllPaymentsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteAllPaymentsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAllPaymentsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAllPaymentsResponse;
    })();

    lnrpc.DebugLevelRequest = (function() {

        /**
         * Properties of a DebugLevelRequest.
         * @memberof lnrpc
         * @interface IDebugLevelRequest
         * @property {boolean|null} [show] DebugLevelRequest show
         * @property {string|null} [levelSpec] DebugLevelRequest levelSpec
         */

        /**
         * Constructs a new DebugLevelRequest.
         * @memberof lnrpc
         * @classdesc Represents a DebugLevelRequest.
         * @implements IDebugLevelRequest
         * @constructor
         * @param {lnrpc.IDebugLevelRequest=} [properties] Properties to set
         */
        function DebugLevelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugLevelRequest show.
         * @member {boolean} show
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         */
        DebugLevelRequest.prototype.show = false;

        /**
         * DebugLevelRequest levelSpec.
         * @member {string} levelSpec
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         */
        DebugLevelRequest.prototype.levelSpec = "";

        /**
         * Creates a new DebugLevelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest=} [properties] Properties to set
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest instance
         */
        DebugLevelRequest.create = function create(properties) {
            return new DebugLevelRequest(properties);
        };

        /**
         * Encodes the specified DebugLevelRequest message. Does not implicitly {@link lnrpc.DebugLevelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest} message DebugLevelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.show != null && message.hasOwnProperty("show"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.show);
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.levelSpec);
            return writer;
        };

        /**
         * Encodes the specified DebugLevelRequest message, length delimited. Does not implicitly {@link lnrpc.DebugLevelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest} message DebugLevelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugLevelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DebugLevelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.show = reader.bool();
                    break;
                case 2:
                    message.levelSpec = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugLevelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugLevelRequest message.
         * @function verify
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLevelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.show != null && message.hasOwnProperty("show"))
                if (typeof message.show !== "boolean")
                    return "show: boolean expected";
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                if (!$util.isString(message.levelSpec))
                    return "levelSpec: string expected";
            return null;
        };

        /**
         * Creates a DebugLevelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         */
        DebugLevelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DebugLevelRequest)
                return object;
            var message = new $root.lnrpc.DebugLevelRequest();
            if (object.show != null)
                message.show = Boolean(object.show);
            if (object.levelSpec != null)
                message.levelSpec = String(object.levelSpec);
            return message;
        };

        /**
         * Creates a plain object from a DebugLevelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.DebugLevelRequest} message DebugLevelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLevelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.show = false;
                object.levelSpec = "";
            }
            if (message.show != null && message.hasOwnProperty("show"))
                object.show = message.show;
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                object.levelSpec = message.levelSpec;
            return object;
        };

        /**
         * Converts this DebugLevelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLevelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebugLevelRequest;
    })();

    lnrpc.DebugLevelResponse = (function() {

        /**
         * Properties of a DebugLevelResponse.
         * @memberof lnrpc
         * @interface IDebugLevelResponse
         * @property {string|null} [subSystems] DebugLevelResponse subSystems
         */

        /**
         * Constructs a new DebugLevelResponse.
         * @memberof lnrpc
         * @classdesc Represents a DebugLevelResponse.
         * @implements IDebugLevelResponse
         * @constructor
         * @param {lnrpc.IDebugLevelResponse=} [properties] Properties to set
         */
        function DebugLevelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugLevelResponse subSystems.
         * @member {string} subSystems
         * @memberof lnrpc.DebugLevelResponse
         * @instance
         */
        DebugLevelResponse.prototype.subSystems = "";

        /**
         * Creates a new DebugLevelResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse=} [properties] Properties to set
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse instance
         */
        DebugLevelResponse.create = function create(properties) {
            return new DebugLevelResponse(properties);
        };

        /**
         * Encodes the specified DebugLevelResponse message. Does not implicitly {@link lnrpc.DebugLevelResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse} message DebugLevelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.subSystems);
            return writer;
        };

        /**
         * Encodes the specified DebugLevelResponse message, length delimited. Does not implicitly {@link lnrpc.DebugLevelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse} message DebugLevelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugLevelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DebugLevelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subSystems = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugLevelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugLevelResponse message.
         * @function verify
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLevelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                if (!$util.isString(message.subSystems))
                    return "subSystems: string expected";
            return null;
        };

        /**
         * Creates a DebugLevelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         */
        DebugLevelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DebugLevelResponse)
                return object;
            var message = new $root.lnrpc.DebugLevelResponse();
            if (object.subSystems != null)
                message.subSystems = String(object.subSystems);
            return message;
        };

        /**
         * Creates a plain object from a DebugLevelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.DebugLevelResponse} message DebugLevelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLevelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.subSystems = "";
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                object.subSystems = message.subSystems;
            return object;
        };

        /**
         * Converts this DebugLevelResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DebugLevelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLevelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebugLevelResponse;
    })();

    lnrpc.PayReqString = (function() {

        /**
         * Properties of a PayReqString.
         * @memberof lnrpc
         * @interface IPayReqString
         * @property {string|null} [payReq] The payment request string to be decoded
         */

        /**
         * Constructs a new PayReqString.
         * @memberof lnrpc
         * @classdesc Represents a PayReqString.
         * @implements IPayReqString
         * @constructor
         * @param {lnrpc.IPayReqString=} [properties] Properties to set
         */
        function PayReqString(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The payment request string to be decoded
         * @member {string} payReq
         * @memberof lnrpc.PayReqString
         * @instance
         */
        PayReqString.prototype.payReq = "";

        /**
         * Creates a new PayReqString instance using the specified properties.
         * @function create
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString=} [properties] Properties to set
         * @returns {lnrpc.PayReqString} PayReqString instance
         */
        PayReqString.create = function create(properties) {
            return new PayReqString(properties);
        };

        /**
         * Encodes the specified PayReqString message. Does not implicitly {@link lnrpc.PayReqString.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString} message PayReqString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReqString.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payReq);
            return writer;
        };

        /**
         * Encodes the specified PayReqString message, length delimited. Does not implicitly {@link lnrpc.PayReqString.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString} message PayReqString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReqString.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayReqString message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PayReqString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PayReqString} PayReqString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReqString.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PayReqString();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payReq = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayReqString message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PayReqString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PayReqString} PayReqString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReqString.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayReqString message.
         * @function verify
         * @memberof lnrpc.PayReqString
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayReqString.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                if (!$util.isString(message.payReq))
                    return "payReq: string expected";
            return null;
        };

        /**
         * Creates a PayReqString message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PayReqString
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PayReqString} PayReqString
         */
        PayReqString.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PayReqString)
                return object;
            var message = new $root.lnrpc.PayReqString();
            if (object.payReq != null)
                message.payReq = String(object.payReq);
            return message;
        };

        /**
         * Creates a plain object from a PayReqString message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.PayReqString} message PayReqString
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayReqString.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payReq = "";
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                object.payReq = message.payReq;
            return object;
        };

        /**
         * Converts this PayReqString to JSON.
         * @function toJSON
         * @memberof lnrpc.PayReqString
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayReqString.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayReqString;
    })();

    lnrpc.PayReq = (function() {

        /**
         * Properties of a PayReq.
         * @memberof lnrpc
         * @interface IPayReq
         * @property {string|null} [destination] PayReq destination
         * @property {string|null} [paymentHash] PayReq paymentHash
         * @property {number|Long|null} [numSatoshis] PayReq numSatoshis
         * @property {number|Long|null} [timestamp] PayReq timestamp
         * @property {number|Long|null} [expiry] PayReq expiry
         * @property {string|null} [description] PayReq description
         * @property {string|null} [descriptionHash] PayReq descriptionHash
         * @property {string|null} [fallbackAddr] PayReq fallbackAddr
         * @property {number|Long|null} [cltvExpiry] PayReq cltvExpiry
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] PayReq routeHints
         */

        /**
         * Constructs a new PayReq.
         * @memberof lnrpc
         * @classdesc Represents a PayReq.
         * @implements IPayReq
         * @constructor
         * @param {lnrpc.IPayReq=} [properties] Properties to set
         */
        function PayReq(properties) {
            this.routeHints = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayReq destination.
         * @member {string} destination
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.destination = "";

        /**
         * PayReq paymentHash.
         * @member {string} paymentHash
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.paymentHash = "";

        /**
         * PayReq numSatoshis.
         * @member {number|Long} numSatoshis
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.numSatoshis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq timestamp.
         * @member {number|Long} timestamp
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq expiry.
         * @member {number|Long} expiry
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.expiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq description.
         * @member {string} description
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.description = "";

        /**
         * PayReq descriptionHash.
         * @member {string} descriptionHash
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.descriptionHash = "";

        /**
         * PayReq fallbackAddr.
         * @member {string} fallbackAddr
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.fallbackAddr = "";

        /**
         * PayReq cltvExpiry.
         * @member {number|Long} cltvExpiry
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.cltvExpiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq routeHints.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.routeHints = $util.emptyArray;

        /**
         * Creates a new PayReq instance using the specified properties.
         * @function create
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq=} [properties] Properties to set
         * @returns {lnrpc.PayReq} PayReq instance
         */
        PayReq.create = function create(properties) {
            return new PayReq(properties);
        };

        /**
         * Encodes the specified PayReq message. Does not implicitly {@link lnrpc.PayReq.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq} message PayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentHash);
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.numSatoshis);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiry);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.descriptionHash);
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fallbackAddr);
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.cltvExpiry);
            if (message.routeHints != null && message.routeHints.length)
                for (var i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PayReq message, length delimited. Does not implicitly {@link lnrpc.PayReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq} message PayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayReq message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PayReq} PayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PayReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.destination = reader.string();
                    break;
                case 2:
                    message.paymentHash = reader.string();
                    break;
                case 3:
                    message.numSatoshis = reader.int64();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                case 5:
                    message.expiry = reader.int64();
                    break;
                case 6:
                    message.description = reader.string();
                    break;
                case 7:
                    message.descriptionHash = reader.string();
                    break;
                case 8:
                    message.fallbackAddr = reader.string();
                    break;
                case 9:
                    message.cltvExpiry = reader.int64();
                    break;
                case 10:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PayReq} PayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayReq message.
         * @function verify
         * @memberof lnrpc.PayReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!$util.isString(message.destination))
                    return "destination: string expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!$util.isString(message.paymentHash))
                    return "paymentHash: string expected";
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                if (!$util.isInteger(message.numSatoshis) && !(message.numSatoshis && $util.isInteger(message.numSatoshis.low) && $util.isInteger(message.numSatoshis.high)))
                    return "numSatoshis: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry) && !(message.expiry && $util.isInteger(message.expiry.low) && $util.isInteger(message.expiry.high)))
                    return "expiry: integer|Long expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                if (!$util.isString(message.descriptionHash))
                    return "descriptionHash: string expected";
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                if (!$util.isString(message.fallbackAddr))
                    return "fallbackAddr: string expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry) && !(message.cltvExpiry && $util.isInteger(message.cltvExpiry.low) && $util.isInteger(message.cltvExpiry.high)))
                    return "cltvExpiry: integer|Long expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (var i = 0; i < message.routeHints.length; ++i) {
                    var error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PayReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PayReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PayReq} PayReq
         */
        PayReq.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PayReq)
                return object;
            var message = new $root.lnrpc.PayReq();
            if (object.destination != null)
                message.destination = String(object.destination);
            if (object.paymentHash != null)
                message.paymentHash = String(object.paymentHash);
            if (object.numSatoshis != null)
                if ($util.Long)
                    (message.numSatoshis = $util.Long.fromValue(object.numSatoshis)).unsigned = false;
                else if (typeof object.numSatoshis === "string")
                    message.numSatoshis = parseInt(object.numSatoshis, 10);
                else if (typeof object.numSatoshis === "number")
                    message.numSatoshis = object.numSatoshis;
                else if (typeof object.numSatoshis === "object")
                    message.numSatoshis = new $util.LongBits(object.numSatoshis.low >>> 0, object.numSatoshis.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.expiry != null)
                if ($util.Long)
                    (message.expiry = $util.Long.fromValue(object.expiry)).unsigned = false;
                else if (typeof object.expiry === "string")
                    message.expiry = parseInt(object.expiry, 10);
                else if (typeof object.expiry === "number")
                    message.expiry = object.expiry;
                else if (typeof object.expiry === "object")
                    message.expiry = new $util.LongBits(object.expiry.low >>> 0, object.expiry.high >>> 0).toNumber();
            if (object.description != null)
                message.description = String(object.description);
            if (object.descriptionHash != null)
                message.descriptionHash = String(object.descriptionHash);
            if (object.fallbackAddr != null)
                message.fallbackAddr = String(object.fallbackAddr);
            if (object.cltvExpiry != null)
                if ($util.Long)
                    (message.cltvExpiry = $util.Long.fromValue(object.cltvExpiry)).unsigned = false;
                else if (typeof object.cltvExpiry === "string")
                    message.cltvExpiry = parseInt(object.cltvExpiry, 10);
                else if (typeof object.cltvExpiry === "number")
                    message.cltvExpiry = object.cltvExpiry;
                else if (typeof object.cltvExpiry === "object")
                    message.cltvExpiry = new $util.LongBits(object.cltvExpiry.low >>> 0, object.cltvExpiry.high >>> 0).toNumber();
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.PayReq.routeHints: array expected");
                message.routeHints = [];
                for (var i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.PayReq.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PayReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.PayReq} message PayReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.routeHints = [];
            if (options.defaults) {
                object.destination = "";
                object.paymentHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numSatoshis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numSatoshis = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiry = options.longs === String ? "0" : 0;
                object.description = "";
                object.descriptionHash = "";
                object.fallbackAddr = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.cltvExpiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cltvExpiry = options.longs === String ? "0" : 0;
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = message.destination;
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = message.paymentHash;
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                if (typeof message.numSatoshis === "number")
                    object.numSatoshis = options.longs === String ? String(message.numSatoshis) : message.numSatoshis;
                else
                    object.numSatoshis = options.longs === String ? $util.Long.prototype.toString.call(message.numSatoshis) : options.longs === Number ? new $util.LongBits(message.numSatoshis.low >>> 0, message.numSatoshis.high >>> 0).toNumber() : message.numSatoshis;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (typeof message.expiry === "number")
                    object.expiry = options.longs === String ? String(message.expiry) : message.expiry;
                else
                    object.expiry = options.longs === String ? $util.Long.prototype.toString.call(message.expiry) : options.longs === Number ? new $util.LongBits(message.expiry.low >>> 0, message.expiry.high >>> 0).toNumber() : message.expiry;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                object.descriptionHash = message.descriptionHash;
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                object.fallbackAddr = message.fallbackAddr;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (typeof message.cltvExpiry === "number")
                    object.cltvExpiry = options.longs === String ? String(message.cltvExpiry) : message.cltvExpiry;
                else
                    object.cltvExpiry = options.longs === String ? $util.Long.prototype.toString.call(message.cltvExpiry) : options.longs === Number ? new $util.LongBits(message.cltvExpiry.low >>> 0, message.cltvExpiry.high >>> 0).toNumber() : message.cltvExpiry;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (var j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            return object;
        };

        /**
         * Converts this PayReq to JSON.
         * @function toJSON
         * @memberof lnrpc.PayReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayReq;
    })();

    lnrpc.FeeReportRequest = (function() {

        /**
         * Properties of a FeeReportRequest.
         * @memberof lnrpc
         * @interface IFeeReportRequest
         */

        /**
         * Constructs a new FeeReportRequest.
         * @memberof lnrpc
         * @classdesc Represents a FeeReportRequest.
         * @implements IFeeReportRequest
         * @constructor
         * @param {lnrpc.IFeeReportRequest=} [properties] Properties to set
         */
        function FeeReportRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FeeReportRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest=} [properties] Properties to set
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest instance
         */
        FeeReportRequest.create = function create(properties) {
            return new FeeReportRequest(properties);
        };

        /**
         * Encodes the specified FeeReportRequest message. Does not implicitly {@link lnrpc.FeeReportRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest} message FeeReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FeeReportRequest message, length delimited. Does not implicitly {@link lnrpc.FeeReportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest} message FeeReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeReportRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeReportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReportRequest message.
         * @function verify
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FeeReportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         */
        FeeReportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeReportRequest)
                return object;
            return new $root.lnrpc.FeeReportRequest();
        };

        /**
         * Creates a plain object from a FeeReportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.FeeReportRequest} message FeeReportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReportRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FeeReportRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeReportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeReportRequest;
    })();

    lnrpc.ChannelFeeReport = (function() {

        /**
         * Properties of a ChannelFeeReport.
         * @memberof lnrpc
         * @interface IChannelFeeReport
         * @property {string|null} [chanPoint] The channel that this fee report belongs to.
         * @property {number|Long|null} [baseFeeMsat] The base fee charged regardless of the number of milli-satoshis sent.
         * @property {number|Long|null} [feePerMil] The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
         * @property {number|null} [feeRate] The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
         */

        /**
         * Constructs a new ChannelFeeReport.
         * @memberof lnrpc
         * @classdesc Represents a ChannelFeeReport.
         * @implements IChannelFeeReport
         * @constructor
         * @param {lnrpc.IChannelFeeReport=} [properties] Properties to set
         */
        function ChannelFeeReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The channel that this fee report belongs to.
         * @member {string} chanPoint
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.chanPoint = "";

        /**
         * The base fee charged regardless of the number of milli-satoshis sent.
         * @member {number|Long} baseFeeMsat
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.baseFeeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
         * @member {number|Long} feePerMil
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.feePerMil = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
         * @member {number} feeRate
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.feeRate = 0;

        /**
         * Creates a new ChannelFeeReport instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport=} [properties] Properties to set
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport instance
         */
        ChannelFeeReport.create = function create(properties) {
            return new ChannelFeeReport(properties);
        };

        /**
         * Encodes the specified ChannelFeeReport message. Does not implicitly {@link lnrpc.ChannelFeeReport.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport} message ChannelFeeReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFeeReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chanPoint);
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.baseFeeMsat);
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.feePerMil);
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.feeRate);
            return writer;
        };

        /**
         * Encodes the specified ChannelFeeReport message, length delimited. Does not implicitly {@link lnrpc.ChannelFeeReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport} message ChannelFeeReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFeeReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelFeeReport message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFeeReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelFeeReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPoint = reader.string();
                    break;
                case 2:
                    message.baseFeeMsat = reader.int64();
                    break;
                case 3:
                    message.feePerMil = reader.int64();
                    break;
                case 4:
                    message.feeRate = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelFeeReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFeeReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelFeeReport message.
         * @function verify
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelFeeReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                if (!$util.isString(message.chanPoint))
                    return "chanPoint: string expected";
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (!$util.isInteger(message.baseFeeMsat) && !(message.baseFeeMsat && $util.isInteger(message.baseFeeMsat.low) && $util.isInteger(message.baseFeeMsat.high)))
                    return "baseFeeMsat: integer|Long expected";
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                if (!$util.isInteger(message.feePerMil) && !(message.feePerMil && $util.isInteger(message.feePerMil.low) && $util.isInteger(message.feePerMil.high)))
                    return "feePerMil: integer|Long expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (typeof message.feeRate !== "number")
                    return "feeRate: number expected";
            return null;
        };

        /**
         * Creates a ChannelFeeReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         */
        ChannelFeeReport.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelFeeReport)
                return object;
            var message = new $root.lnrpc.ChannelFeeReport();
            if (object.chanPoint != null)
                message.chanPoint = String(object.chanPoint);
            if (object.baseFeeMsat != null)
                if ($util.Long)
                    (message.baseFeeMsat = $util.Long.fromValue(object.baseFeeMsat)).unsigned = false;
                else if (typeof object.baseFeeMsat === "string")
                    message.baseFeeMsat = parseInt(object.baseFeeMsat, 10);
                else if (typeof object.baseFeeMsat === "number")
                    message.baseFeeMsat = object.baseFeeMsat;
                else if (typeof object.baseFeeMsat === "object")
                    message.baseFeeMsat = new $util.LongBits(object.baseFeeMsat.low >>> 0, object.baseFeeMsat.high >>> 0).toNumber();
            if (object.feePerMil != null)
                if ($util.Long)
                    (message.feePerMil = $util.Long.fromValue(object.feePerMil)).unsigned = false;
                else if (typeof object.feePerMil === "string")
                    message.feePerMil = parseInt(object.feePerMil, 10);
                else if (typeof object.feePerMil === "number")
                    message.feePerMil = object.feePerMil;
                else if (typeof object.feePerMil === "object")
                    message.feePerMil = new $util.LongBits(object.feePerMil.low >>> 0, object.feePerMil.high >>> 0).toNumber();
            if (object.feeRate != null)
                message.feeRate = Number(object.feeRate);
            return message;
        };

        /**
         * Creates a plain object from a ChannelFeeReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.ChannelFeeReport} message ChannelFeeReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelFeeReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chanPoint = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.baseFeeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.baseFeeMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.feePerMil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerMil = options.longs === String ? "0" : 0;
                object.feeRate = 0;
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = message.chanPoint;
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (typeof message.baseFeeMsat === "number")
                    object.baseFeeMsat = options.longs === String ? String(message.baseFeeMsat) : message.baseFeeMsat;
                else
                    object.baseFeeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.baseFeeMsat) : options.longs === Number ? new $util.LongBits(message.baseFeeMsat.low >>> 0, message.baseFeeMsat.high >>> 0).toNumber() : message.baseFeeMsat;
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                if (typeof message.feePerMil === "number")
                    object.feePerMil = options.longs === String ? String(message.feePerMil) : message.feePerMil;
                else
                    object.feePerMil = options.longs === String ? $util.Long.prototype.toString.call(message.feePerMil) : options.longs === Number ? new $util.LongBits(message.feePerMil.low >>> 0, message.feePerMil.high >>> 0).toNumber() : message.feePerMil;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = options.json && !isFinite(message.feeRate) ? String(message.feeRate) : message.feeRate;
            return object;
        };

        /**
         * Converts this ChannelFeeReport to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelFeeReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelFeeReport;
    })();

    lnrpc.FeeReportResponse = (function() {

        /**
         * Properties of a FeeReportResponse.
         * @memberof lnrpc
         * @interface IFeeReportResponse
         * @property {Array.<lnrpc.IChannelFeeReport>|null} [channelFees] An array of channel fee reports which describes the current fee schedule for each channel.
         * @property {number|Long|null} [dayFeeSum] The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
         * @property {number|Long|null} [weekFeeSum] The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
         * @property {number|Long|null} [monthFeeSum] The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
         */

        /**
         * Constructs a new FeeReportResponse.
         * @memberof lnrpc
         * @classdesc Represents a FeeReportResponse.
         * @implements IFeeReportResponse
         * @constructor
         * @param {lnrpc.IFeeReportResponse=} [properties] Properties to set
         */
        function FeeReportResponse(properties) {
            this.channelFees = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An array of channel fee reports which describes the current fee schedule for each channel.
         * @member {Array.<lnrpc.IChannelFeeReport>} channelFees
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.channelFees = $util.emptyArray;

        /**
         * The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
         * @member {number|Long} dayFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.dayFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
         * @member {number|Long} weekFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.weekFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
         * @member {number|Long} monthFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.monthFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FeeReportResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse=} [properties] Properties to set
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse instance
         */
        FeeReportResponse.create = function create(properties) {
            return new FeeReportResponse(properties);
        };

        /**
         * Encodes the specified FeeReportResponse message. Does not implicitly {@link lnrpc.FeeReportResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse} message FeeReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelFees != null && message.channelFees.length)
                for (var i = 0; i < message.channelFees.length; ++i)
                    $root.lnrpc.ChannelFeeReport.encode(message.channelFees[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.dayFeeSum);
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.weekFeeSum);
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.monthFeeSum);
            return writer;
        };

        /**
         * Encodes the specified FeeReportResponse message, length delimited. Does not implicitly {@link lnrpc.FeeReportResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse} message FeeReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeReportResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channelFees && message.channelFees.length))
                        message.channelFees = [];
                    message.channelFees.push($root.lnrpc.ChannelFeeReport.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.dayFeeSum = reader.uint64();
                    break;
                case 3:
                    message.weekFeeSum = reader.uint64();
                    break;
                case 4:
                    message.monthFeeSum = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeReportResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReportResponse message.
         * @function verify
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReportResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelFees != null && message.hasOwnProperty("channelFees")) {
                if (!Array.isArray(message.channelFees))
                    return "channelFees: array expected";
                for (var i = 0; i < message.channelFees.length; ++i) {
                    var error = $root.lnrpc.ChannelFeeReport.verify(message.channelFees[i]);
                    if (error)
                        return "channelFees." + error;
                }
            }
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                if (!$util.isInteger(message.dayFeeSum) && !(message.dayFeeSum && $util.isInteger(message.dayFeeSum.low) && $util.isInteger(message.dayFeeSum.high)))
                    return "dayFeeSum: integer|Long expected";
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                if (!$util.isInteger(message.weekFeeSum) && !(message.weekFeeSum && $util.isInteger(message.weekFeeSum.low) && $util.isInteger(message.weekFeeSum.high)))
                    return "weekFeeSum: integer|Long expected";
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                if (!$util.isInteger(message.monthFeeSum) && !(message.monthFeeSum && $util.isInteger(message.monthFeeSum.low) && $util.isInteger(message.monthFeeSum.high)))
                    return "monthFeeSum: integer|Long expected";
            return null;
        };

        /**
         * Creates a FeeReportResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         */
        FeeReportResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeReportResponse)
                return object;
            var message = new $root.lnrpc.FeeReportResponse();
            if (object.channelFees) {
                if (!Array.isArray(object.channelFees))
                    throw TypeError(".lnrpc.FeeReportResponse.channelFees: array expected");
                message.channelFees = [];
                for (var i = 0; i < object.channelFees.length; ++i) {
                    if (typeof object.channelFees[i] !== "object")
                        throw TypeError(".lnrpc.FeeReportResponse.channelFees: object expected");
                    message.channelFees[i] = $root.lnrpc.ChannelFeeReport.fromObject(object.channelFees[i]);
                }
            }
            if (object.dayFeeSum != null)
                if ($util.Long)
                    (message.dayFeeSum = $util.Long.fromValue(object.dayFeeSum)).unsigned = true;
                else if (typeof object.dayFeeSum === "string")
                    message.dayFeeSum = parseInt(object.dayFeeSum, 10);
                else if (typeof object.dayFeeSum === "number")
                    message.dayFeeSum = object.dayFeeSum;
                else if (typeof object.dayFeeSum === "object")
                    message.dayFeeSum = new $util.LongBits(object.dayFeeSum.low >>> 0, object.dayFeeSum.high >>> 0).toNumber(true);
            if (object.weekFeeSum != null)
                if ($util.Long)
                    (message.weekFeeSum = $util.Long.fromValue(object.weekFeeSum)).unsigned = true;
                else if (typeof object.weekFeeSum === "string")
                    message.weekFeeSum = parseInt(object.weekFeeSum, 10);
                else if (typeof object.weekFeeSum === "number")
                    message.weekFeeSum = object.weekFeeSum;
                else if (typeof object.weekFeeSum === "object")
                    message.weekFeeSum = new $util.LongBits(object.weekFeeSum.low >>> 0, object.weekFeeSum.high >>> 0).toNumber(true);
            if (object.monthFeeSum != null)
                if ($util.Long)
                    (message.monthFeeSum = $util.Long.fromValue(object.monthFeeSum)).unsigned = true;
                else if (typeof object.monthFeeSum === "string")
                    message.monthFeeSum = parseInt(object.monthFeeSum, 10);
                else if (typeof object.monthFeeSum === "number")
                    message.monthFeeSum = object.monthFeeSum;
                else if (typeof object.monthFeeSum === "object")
                    message.monthFeeSum = new $util.LongBits(object.monthFeeSum.low >>> 0, object.monthFeeSum.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a FeeReportResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.FeeReportResponse} message FeeReportResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReportResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.channelFees = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.dayFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dayFeeSum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.weekFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.weekFeeSum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.monthFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.monthFeeSum = options.longs === String ? "0" : 0;
            }
            if (message.channelFees && message.channelFees.length) {
                object.channelFees = [];
                for (var j = 0; j < message.channelFees.length; ++j)
                    object.channelFees[j] = $root.lnrpc.ChannelFeeReport.toObject(message.channelFees[j], options);
            }
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                if (typeof message.dayFeeSum === "number")
                    object.dayFeeSum = options.longs === String ? String(message.dayFeeSum) : message.dayFeeSum;
                else
                    object.dayFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.dayFeeSum) : options.longs === Number ? new $util.LongBits(message.dayFeeSum.low >>> 0, message.dayFeeSum.high >>> 0).toNumber(true) : message.dayFeeSum;
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                if (typeof message.weekFeeSum === "number")
                    object.weekFeeSum = options.longs === String ? String(message.weekFeeSum) : message.weekFeeSum;
                else
                    object.weekFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.weekFeeSum) : options.longs === Number ? new $util.LongBits(message.weekFeeSum.low >>> 0, message.weekFeeSum.high >>> 0).toNumber(true) : message.weekFeeSum;
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                if (typeof message.monthFeeSum === "number")
                    object.monthFeeSum = options.longs === String ? String(message.monthFeeSum) : message.monthFeeSum;
                else
                    object.monthFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.monthFeeSum) : options.longs === Number ? new $util.LongBits(message.monthFeeSum.low >>> 0, message.monthFeeSum.high >>> 0).toNumber(true) : message.monthFeeSum;
            return object;
        };

        /**
         * Converts this FeeReportResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeReportResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReportResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeReportResponse;
    })();

    lnrpc.PolicyUpdateRequest = (function() {

        /**
         * Properties of a PolicyUpdateRequest.
         * @memberof lnrpc
         * @interface IPolicyUpdateRequest
         * @property {boolean|null} [global] If set, then this update applies to all currently active channels.
         * @property {lnrpc.IChannelPoint|null} [chanPoint] If set, this update will target a specific channel.
         * @property {number|Long|null} [baseFeeMsat] The base fee charged regardless of the number of milli-satoshis sent.
         * @property {number|null} [feeRate] The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
         * @property {number|null} [timeLockDelta] The required timelock delta for HTLCs forwarded over the channel.
         */

        /**
         * Constructs a new PolicyUpdateRequest.
         * @memberof lnrpc
         * @classdesc Represents a PolicyUpdateRequest.
         * @implements IPolicyUpdateRequest
         * @constructor
         * @param {lnrpc.IPolicyUpdateRequest=} [properties] Properties to set
         */
        function PolicyUpdateRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * If set, then this update applies to all currently active channels.
         * @member {boolean} global
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.global = false;

        /**
         * If set, this update will target a specific channel.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.chanPoint = null;

        /**
         * The base fee charged regardless of the number of milli-satoshis sent.
         * @member {number|Long} baseFeeMsat
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.baseFeeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
         * @member {number} feeRate
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.feeRate = 0;

        /**
         * The required timelock delta for HTLCs forwarded over the channel.
         * @member {number} timeLockDelta
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.timeLockDelta = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PolicyUpdateRequest scope.
         * @member {"global"|"chanPoint"|undefined} scope
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        Object.defineProperty(PolicyUpdateRequest.prototype, "scope", {
            get: $util.oneOfGetter($oneOfFields = ["global", "chanPoint"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PolicyUpdateRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest=} [properties] Properties to set
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest instance
         */
        PolicyUpdateRequest.create = function create(properties) {
            return new PolicyUpdateRequest(properties);
        };

        /**
         * Encodes the specified PolicyUpdateRequest message. Does not implicitly {@link lnrpc.PolicyUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest} message PolicyUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.global != null && message.hasOwnProperty("global"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.global);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.baseFeeMsat);
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.feeRate);
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.timeLockDelta);
            return writer;
        };

        /**
         * Encodes the specified PolicyUpdateRequest message, length delimited. Does not implicitly {@link lnrpc.PolicyUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest} message PolicyUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PolicyUpdateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.global = reader.bool();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.baseFeeMsat = reader.int64();
                    break;
                case 4:
                    message.feeRate = reader.double();
                    break;
                case 5:
                    message.timeLockDelta = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyUpdateRequest message.
         * @function verify
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.global != null && message.hasOwnProperty("global")) {
                properties.scope = 1;
                if (typeof message.global !== "boolean")
                    return "global: boolean expected";
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                if (properties.scope === 1)
                    return "scope: multiple values";
                properties.scope = 1;
                {
                    var error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                    if (error)
                        return "chanPoint." + error;
                }
            }
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (!$util.isInteger(message.baseFeeMsat) && !(message.baseFeeMsat && $util.isInteger(message.baseFeeMsat.low) && $util.isInteger(message.baseFeeMsat.high)))
                    return "baseFeeMsat: integer|Long expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (typeof message.feeRate !== "number")
                    return "feeRate: number expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            return null;
        };

        /**
         * Creates a PolicyUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         */
        PolicyUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PolicyUpdateRequest)
                return object;
            var message = new $root.lnrpc.PolicyUpdateRequest();
            if (object.global != null)
                message.global = Boolean(object.global);
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.PolicyUpdateRequest.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.baseFeeMsat != null)
                if ($util.Long)
                    (message.baseFeeMsat = $util.Long.fromValue(object.baseFeeMsat)).unsigned = false;
                else if (typeof object.baseFeeMsat === "string")
                    message.baseFeeMsat = parseInt(object.baseFeeMsat, 10);
                else if (typeof object.baseFeeMsat === "number")
                    message.baseFeeMsat = object.baseFeeMsat;
                else if (typeof object.baseFeeMsat === "object")
                    message.baseFeeMsat = new $util.LongBits(object.baseFeeMsat.low >>> 0, object.baseFeeMsat.high >>> 0).toNumber();
            if (object.feeRate != null)
                message.feeRate = Number(object.feeRate);
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PolicyUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.PolicyUpdateRequest} message PolicyUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.baseFeeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.baseFeeMsat = options.longs === String ? "0" : 0;
                object.feeRate = 0;
                object.timeLockDelta = 0;
            }
            if (message.global != null && message.hasOwnProperty("global")) {
                object.global = message.global;
                if (options.oneofs)
                    object.scope = "global";
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
                if (options.oneofs)
                    object.scope = "chanPoint";
            }
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (typeof message.baseFeeMsat === "number")
                    object.baseFeeMsat = options.longs === String ? String(message.baseFeeMsat) : message.baseFeeMsat;
                else
                    object.baseFeeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.baseFeeMsat) : options.longs === Number ? new $util.LongBits(message.baseFeeMsat.low >>> 0, message.baseFeeMsat.high >>> 0).toNumber() : message.baseFeeMsat;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = options.json && !isFinite(message.feeRate) ? String(message.feeRate) : message.feeRate;
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            return object;
        };

        /**
         * Converts this PolicyUpdateRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyUpdateRequest;
    })();

    lnrpc.PolicyUpdateResponse = (function() {

        /**
         * Properties of a PolicyUpdateResponse.
         * @memberof lnrpc
         * @interface IPolicyUpdateResponse
         */

        /**
         * Constructs a new PolicyUpdateResponse.
         * @memberof lnrpc
         * @classdesc Represents a PolicyUpdateResponse.
         * @implements IPolicyUpdateResponse
         * @constructor
         * @param {lnrpc.IPolicyUpdateResponse=} [properties] Properties to set
         */
        function PolicyUpdateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PolicyUpdateResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse=} [properties] Properties to set
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse instance
         */
        PolicyUpdateResponse.create = function create(properties) {
            return new PolicyUpdateResponse(properties);
        };

        /**
         * Encodes the specified PolicyUpdateResponse message. Does not implicitly {@link lnrpc.PolicyUpdateResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse} message PolicyUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PolicyUpdateResponse message, length delimited. Does not implicitly {@link lnrpc.PolicyUpdateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse} message PolicyUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyUpdateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PolicyUpdateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyUpdateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyUpdateResponse message.
         * @function verify
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyUpdateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PolicyUpdateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         */
        PolicyUpdateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PolicyUpdateResponse)
                return object;
            return new $root.lnrpc.PolicyUpdateResponse();
        };

        /**
         * Creates a plain object from a PolicyUpdateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.PolicyUpdateResponse} message PolicyUpdateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyUpdateResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PolicyUpdateResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.PolicyUpdateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyUpdateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyUpdateResponse;
    })();

    lnrpc.ForwardingHistoryRequest = (function() {

        /**
         * Properties of a ForwardingHistoryRequest.
         * @memberof lnrpc
         * @interface IForwardingHistoryRequest
         * @property {number|Long|null} [startTime] Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
         * @property {number|Long|null} [endTime] End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
         * @property {number|null} [indexOffset] Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
         * @property {number|null} [numMaxEvents] The max number of events to return in the response to this query.
         */

        /**
         * Constructs a new ForwardingHistoryRequest.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingHistoryRequest.
         * @implements IForwardingHistoryRequest
         * @constructor
         * @param {lnrpc.IForwardingHistoryRequest=} [properties] Properties to set
         */
        function ForwardingHistoryRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
         * @member {number|Long} startTime
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
         * @member {number|Long} endTime
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
         * @member {number} indexOffset
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.indexOffset = 0;

        /**
         * The max number of events to return in the response to this query.
         * @member {number} numMaxEvents
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.numMaxEvents = 0;

        /**
         * Creates a new ForwardingHistoryRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest=} [properties] Properties to set
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest instance
         */
        ForwardingHistoryRequest.create = function create(properties) {
            return new ForwardingHistoryRequest(properties);
        };

        /**
         * Encodes the specified ForwardingHistoryRequest message. Does not implicitly {@link lnrpc.ForwardingHistoryRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest} message ForwardingHistoryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.endTime);
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.indexOffset);
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numMaxEvents);
            return writer;
        };

        /**
         * Encodes the specified ForwardingHistoryRequest message, length delimited. Does not implicitly {@link lnrpc.ForwardingHistoryRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest} message ForwardingHistoryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingHistoryRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingHistoryRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTime = reader.uint64();
                    break;
                case 2:
                    message.endTime = reader.uint64();
                    break;
                case 3:
                    message.indexOffset = reader.uint32();
                    break;
                case 4:
                    message.numMaxEvents = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingHistoryRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingHistoryRequest message.
         * @function verify
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingHistoryRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (!$util.isInteger(message.indexOffset))
                    return "indexOffset: integer expected";
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                if (!$util.isInteger(message.numMaxEvents))
                    return "numMaxEvents: integer expected";
            return null;
        };

        /**
         * Creates a ForwardingHistoryRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         */
        ForwardingHistoryRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingHistoryRequest)
                return object;
            var message = new $root.lnrpc.ForwardingHistoryRequest();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = true;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber(true);
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = true;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber(true);
            if (object.indexOffset != null)
                message.indexOffset = object.indexOffset >>> 0;
            if (object.numMaxEvents != null)
                message.numMaxEvents = object.numMaxEvents >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ForwardingHistoryRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.ForwardingHistoryRequest} message ForwardingHistoryRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingHistoryRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
                object.indexOffset = 0;
                object.numMaxEvents = 0;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                object.indexOffset = message.indexOffset;
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                object.numMaxEvents = message.numMaxEvents;
            return object;
        };

        /**
         * Converts this ForwardingHistoryRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingHistoryRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingHistoryRequest;
    })();

    lnrpc.ForwardingEvent = (function() {

        /**
         * Properties of a ForwardingEvent.
         * @memberof lnrpc
         * @interface IForwardingEvent
         * @property {number|Long|null} [timestamp] Timestamp is the time (unix epoch offset) that this circuit was completed.
         * @property {number|Long|null} [chanIdIn] The incoming channel ID that carried the HTLC that created the circuit.
         * @property {number|Long|null} [chanIdOut] The outgoing channel ID that carried the preimage that completed the circuit.
         * @property {number|Long|null} [amtIn] The total amount of the incoming HTLC that created half the circuit.
         * @property {number|Long|null} [amtOut] The total amount of the outgoign HTLC that created the second half of the circuit.
         * @property {number|Long|null} [fee] The total fee that this payment circuit carried.
         */

        /**
         * Constructs a new ForwardingEvent.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingEvent.
         * @implements IForwardingEvent
         * @constructor
         * @param {lnrpc.IForwardingEvent=} [properties] Properties to set
         */
        function ForwardingEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timestamp is the time (unix epoch offset) that this circuit was completed.
         * @member {number|Long} timestamp
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The incoming channel ID that carried the HTLC that created the circuit.
         * @member {number|Long} chanIdIn
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.chanIdIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The outgoing channel ID that carried the preimage that completed the circuit.
         * @member {number|Long} chanIdOut
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.chanIdOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of the incoming HTLC that created half the circuit.
         * @member {number|Long} amtIn
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of the outgoign HTLC that created the second half of the circuit.
         * @member {number|Long} amtOut
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total fee that this payment circuit carried.
         * @member {number|Long} fee
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ForwardingEvent instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent=} [properties] Properties to set
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent instance
         */
        ForwardingEvent.create = function create(properties) {
            return new ForwardingEvent(properties);
        };

        /**
         * Encodes the specified ForwardingEvent message. Does not implicitly {@link lnrpc.ForwardingEvent.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent} message ForwardingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanIdIn);
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.chanIdOut);
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.amtIn);
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.amtOut);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.fee);
            return writer;
        };

        /**
         * Encodes the specified ForwardingEvent message, length delimited. Does not implicitly {@link lnrpc.ForwardingEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent} message ForwardingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingEvent message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.chanIdIn = reader.uint64();
                    break;
                case 4:
                    message.chanIdOut = reader.uint64();
                    break;
                case 5:
                    message.amtIn = reader.uint64();
                    break;
                case 6:
                    message.amtOut = reader.uint64();
                    break;
                case 7:
                    message.fee = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingEvent message.
         * @function verify
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                if (!$util.isInteger(message.chanIdIn) && !(message.chanIdIn && $util.isInteger(message.chanIdIn.low) && $util.isInteger(message.chanIdIn.high)))
                    return "chanIdIn: integer|Long expected";
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                if (!$util.isInteger(message.chanIdOut) && !(message.chanIdOut && $util.isInteger(message.chanIdOut.low) && $util.isInteger(message.chanIdOut.high)))
                    return "chanIdOut: integer|Long expected";
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                if (!$util.isInteger(message.amtIn) && !(message.amtIn && $util.isInteger(message.amtIn.low) && $util.isInteger(message.amtIn.high)))
                    return "amtIn: integer|Long expected";
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                if (!$util.isInteger(message.amtOut) && !(message.amtOut && $util.isInteger(message.amtOut.low) && $util.isInteger(message.amtOut.high)))
                    return "amtOut: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            return null;
        };

        /**
         * Creates a ForwardingEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         */
        ForwardingEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingEvent)
                return object;
            var message = new $root.lnrpc.ForwardingEvent();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.chanIdIn != null)
                if ($util.Long)
                    (message.chanIdIn = $util.Long.fromValue(object.chanIdIn)).unsigned = true;
                else if (typeof object.chanIdIn === "string")
                    message.chanIdIn = parseInt(object.chanIdIn, 10);
                else if (typeof object.chanIdIn === "number")
                    message.chanIdIn = object.chanIdIn;
                else if (typeof object.chanIdIn === "object")
                    message.chanIdIn = new $util.LongBits(object.chanIdIn.low >>> 0, object.chanIdIn.high >>> 0).toNumber(true);
            if (object.chanIdOut != null)
                if ($util.Long)
                    (message.chanIdOut = $util.Long.fromValue(object.chanIdOut)).unsigned = true;
                else if (typeof object.chanIdOut === "string")
                    message.chanIdOut = parseInt(object.chanIdOut, 10);
                else if (typeof object.chanIdOut === "number")
                    message.chanIdOut = object.chanIdOut;
                else if (typeof object.chanIdOut === "object")
                    message.chanIdOut = new $util.LongBits(object.chanIdOut.low >>> 0, object.chanIdOut.high >>> 0).toNumber(true);
            if (object.amtIn != null)
                if ($util.Long)
                    (message.amtIn = $util.Long.fromValue(object.amtIn)).unsigned = true;
                else if (typeof object.amtIn === "string")
                    message.amtIn = parseInt(object.amtIn, 10);
                else if (typeof object.amtIn === "number")
                    message.amtIn = object.amtIn;
                else if (typeof object.amtIn === "object")
                    message.amtIn = new $util.LongBits(object.amtIn.low >>> 0, object.amtIn.high >>> 0).toNumber(true);
            if (object.amtOut != null)
                if ($util.Long)
                    (message.amtOut = $util.Long.fromValue(object.amtOut)).unsigned = true;
                else if (typeof object.amtOut === "string")
                    message.amtOut = parseInt(object.amtOut, 10);
                else if (typeof object.amtOut === "number")
                    message.amtOut = object.amtOut;
                else if (typeof object.amtOut === "object")
                    message.amtOut = new $util.LongBits(object.amtOut.low >>> 0, object.amtOut.high >>> 0).toNumber(true);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ForwardingEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.ForwardingEvent} message ForwardingEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanIdIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanIdIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.chanIdOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanIdOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amtIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amtOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                if (typeof message.chanIdIn === "number")
                    object.chanIdIn = options.longs === String ? String(message.chanIdIn) : message.chanIdIn;
                else
                    object.chanIdIn = options.longs === String ? $util.Long.prototype.toString.call(message.chanIdIn) : options.longs === Number ? new $util.LongBits(message.chanIdIn.low >>> 0, message.chanIdIn.high >>> 0).toNumber(true) : message.chanIdIn;
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                if (typeof message.chanIdOut === "number")
                    object.chanIdOut = options.longs === String ? String(message.chanIdOut) : message.chanIdOut;
                else
                    object.chanIdOut = options.longs === String ? $util.Long.prototype.toString.call(message.chanIdOut) : options.longs === Number ? new $util.LongBits(message.chanIdOut.low >>> 0, message.chanIdOut.high >>> 0).toNumber(true) : message.chanIdOut;
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                if (typeof message.amtIn === "number")
                    object.amtIn = options.longs === String ? String(message.amtIn) : message.amtIn;
                else
                    object.amtIn = options.longs === String ? $util.Long.prototype.toString.call(message.amtIn) : options.longs === Number ? new $util.LongBits(message.amtIn.low >>> 0, message.amtIn.high >>> 0).toNumber(true) : message.amtIn;
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                if (typeof message.amtOut === "number")
                    object.amtOut = options.longs === String ? String(message.amtOut) : message.amtOut;
                else
                    object.amtOut = options.longs === String ? $util.Long.prototype.toString.call(message.amtOut) : options.longs === Number ? new $util.LongBits(message.amtOut.low >>> 0, message.amtOut.high >>> 0).toNumber(true) : message.amtOut;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
            return object;
        };

        /**
         * Converts this ForwardingEvent to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingEvent;
    })();

    lnrpc.ForwardingHistoryResponse = (function() {

        /**
         * Properties of a ForwardingHistoryResponse.
         * @memberof lnrpc
         * @interface IForwardingHistoryResponse
         * @property {Array.<lnrpc.IForwardingEvent>|null} [forwardingEvents] A list of forwarding events from the time slice of the time series specified in the request.
         * @property {number|null} [lastOffsetIndex] The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
         */

        /**
         * Constructs a new ForwardingHistoryResponse.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingHistoryResponse.
         * @implements IForwardingHistoryResponse
         * @constructor
         * @param {lnrpc.IForwardingHistoryResponse=} [properties] Properties to set
         */
        function ForwardingHistoryResponse(properties) {
            this.forwardingEvents = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A list of forwarding events from the time slice of the time series specified in the request.
         * @member {Array.<lnrpc.IForwardingEvent>} forwardingEvents
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         */
        ForwardingHistoryResponse.prototype.forwardingEvents = $util.emptyArray;

        /**
         * The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
         * @member {number} lastOffsetIndex
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         */
        ForwardingHistoryResponse.prototype.lastOffsetIndex = 0;

        /**
         * Creates a new ForwardingHistoryResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse=} [properties] Properties to set
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse instance
         */
        ForwardingHistoryResponse.create = function create(properties) {
            return new ForwardingHistoryResponse(properties);
        };

        /**
         * Encodes the specified ForwardingHistoryResponse message. Does not implicitly {@link lnrpc.ForwardingHistoryResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse} message ForwardingHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forwardingEvents != null && message.forwardingEvents.length)
                for (var i = 0; i < message.forwardingEvents.length; ++i)
                    $root.lnrpc.ForwardingEvent.encode(message.forwardingEvents[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lastOffsetIndex);
            return writer;
        };

        /**
         * Encodes the specified ForwardingHistoryResponse message, length delimited. Does not implicitly {@link lnrpc.ForwardingHistoryResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse} message ForwardingHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingHistoryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingHistoryResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.forwardingEvents && message.forwardingEvents.length))
                        message.forwardingEvents = [];
                    message.forwardingEvents.push($root.lnrpc.ForwardingEvent.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastOffsetIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingHistoryResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingHistoryResponse message.
         * @function verify
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingHistoryResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forwardingEvents != null && message.hasOwnProperty("forwardingEvents")) {
                if (!Array.isArray(message.forwardingEvents))
                    return "forwardingEvents: array expected";
                for (var i = 0; i < message.forwardingEvents.length; ++i) {
                    var error = $root.lnrpc.ForwardingEvent.verify(message.forwardingEvents[i]);
                    if (error)
                        return "forwardingEvents." + error;
                }
            }
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                if (!$util.isInteger(message.lastOffsetIndex))
                    return "lastOffsetIndex: integer expected";
            return null;
        };

        /**
         * Creates a ForwardingHistoryResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         */
        ForwardingHistoryResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingHistoryResponse)
                return object;
            var message = new $root.lnrpc.ForwardingHistoryResponse();
            if (object.forwardingEvents) {
                if (!Array.isArray(object.forwardingEvents))
                    throw TypeError(".lnrpc.ForwardingHistoryResponse.forwardingEvents: array expected");
                message.forwardingEvents = [];
                for (var i = 0; i < object.forwardingEvents.length; ++i) {
                    if (typeof object.forwardingEvents[i] !== "object")
                        throw TypeError(".lnrpc.ForwardingHistoryResponse.forwardingEvents: object expected");
                    message.forwardingEvents[i] = $root.lnrpc.ForwardingEvent.fromObject(object.forwardingEvents[i]);
                }
            }
            if (object.lastOffsetIndex != null)
                message.lastOffsetIndex = object.lastOffsetIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ForwardingHistoryResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.ForwardingHistoryResponse} message ForwardingHistoryResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingHistoryResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.forwardingEvents = [];
            if (options.defaults)
                object.lastOffsetIndex = 0;
            if (message.forwardingEvents && message.forwardingEvents.length) {
                object.forwardingEvents = [];
                for (var j = 0; j < message.forwardingEvents.length; ++j)
                    object.forwardingEvents[j] = $root.lnrpc.ForwardingEvent.toObject(message.forwardingEvents[j], options);
            }
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                object.lastOffsetIndex = message.lastOffsetIndex;
            return object;
        };

        /**
         * Converts this ForwardingHistoryResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingHistoryResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingHistoryResponse;
    })();

    return lnrpc;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        var api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp=} [properties] Properties to set
             * @returns {google.api.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encode
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rules != null && message.rules.length)
                    for (var i = 0; i < message.rules.length; ++i)
                        $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (var i = 0; i < message.rules.length; ++i) {
                        var error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                var message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (var i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (var j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [body] HttpRule body
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule get.
             * @member {string} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @member {string} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @member {string} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @member {string} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @member {string} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @function create
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encode
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && message.hasOwnProperty("selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.get != null && message.hasOwnProperty("get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && message.hasOwnProperty("put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && message.hasOwnProperty("post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additionalBindings != null && message.additionalBindings.length)
                    for (var i = 0; i < message.additionalBindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.get = reader.string();
                        break;
                    case 3:
                        message.put = reader.string();
                        break;
                    case 4:
                        message.post = reader.string();
                        break;
                    case 5:
                        message["delete"] = reader.string();
                        break;
                    case 6:
                        message.patch = reader.string();
                        break;
                    case 8:
                        message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.selector = reader.string();
                        break;
                    case 7:
                        message.body = reader.string();
                        break;
                    case 11:
                        if (!(message.additionalBindings && message.additionalBindings.length))
                            message.additionalBindings = [];
                        message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        var error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (var i = 0; i < message.additionalBindings.length; ++i) {
                        var error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                var message = new $root.google.api.HttpRule();
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.body != null)
                    message.body = String(object.body);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (var i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (var j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @function create
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                var message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i) {
                        var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (var i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (var i = 0; i < message.messageType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i) {
                        var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (var i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (var i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (var i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (var j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (var j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (var j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (var i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (var i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (var i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (var i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (var i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (var i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (var i = 0; i < message.field.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (var i = 0; i < message.nestedType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (var i = 0; i < message.extensionRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (var i = 0; i < message.oneofDecl.length; ++i) {
                        var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (var i = 0; i < message.reservedRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (var i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                var message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (var i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (var i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (var i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (var i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (var i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (var i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (var j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (var j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (var j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (var j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (var j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (var j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (var i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (var i = 0; i < message.method.length; ++i) {
                        var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (var i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (var j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                var message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                var message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                var message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                var message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                var message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                var message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                var message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 72295728:
                        message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    var error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                var message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (var i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (var i = 0; i < message.name.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                var message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (var i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (var j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                var message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (var i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (var i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (var j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (var i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (var i = 0; i < message.annotation.length; ++i) {
                        var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                var message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (var i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (var j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
